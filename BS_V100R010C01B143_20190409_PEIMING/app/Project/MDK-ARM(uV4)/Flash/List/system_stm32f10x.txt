; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\system_stm32f10x.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\MQTT -I..\..\Ethernet -I..\..\Ethernet\W5500 -I..\..\Internet\DHCP -I..\..\Internet\DNS -I..\..\User\app\src -I..\..\User\app\inc -I..\..\Internet\NTP -I..\..\Internet\HTTP -I.\RTE\_Flash -ID:\MDK5\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\MDK5\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\system_stm32f10x.crf ..\..\User\bsp\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=1

                  SetSysClock PROC
;;;490      */
;;;491    static void SetSysClock(void)
000000  b510              PUSH     {r4,lr}
;;;492    {
;;;493    #ifdef SYSCLK_FREQ_HSE
;;;494      SetSysClockToHSE();
;;;495    #elif defined SYSCLK_FREQ_24MHz
;;;496      SetSysClockTo24();
;;;497    #elif defined SYSCLK_FREQ_36MHz
;;;498      SetSysClockTo36();
;;;499    #elif defined SYSCLK_FREQ_48MHz
;;;500      SetSysClockTo48();
;;;501    #elif defined SYSCLK_FREQ_56MHz
;;;502      SetSysClockTo56();  
;;;503    #elif defined SYSCLK_FREQ_72MHz
;;;504      SetSysClockTo72();
000002  f7fffffe          BL       SetSysClockTo72
;;;505    #endif
;;;506     
;;;507     /* If none of the define above is enabled, the HSI is used as System clock
;;;508        source (default after reset) */ 
;;;509    }
000006  bd10              POP      {r4,pc}
;;;510    
                          ENDP


                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;1058     */
;;;1059   static void SetSysClockTo72(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;1060   {
;;;1061     __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  9000              STR      r0,[sp,#0]
;;;1062     
;;;1063     /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;1064     /* Enable HSE */    
;;;1065     RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000008  4833              LDR      r0,|L2.216|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4403080          ORR      r0,r0,#0x10000
000010  4931              LDR      r1,|L2.216|
000012  6008              STR      r0,[r1,#0]
;;;1066    
;;;1067     /* Wait till HSE is ready and if Time out is reached exit */
;;;1068     do
000014  bf00              NOP      
                  |L2.22|
;;;1069     {
;;;1070       HSEStatus = RCC->CR & RCC_CR_HSERDY;
000016  4830              LDR      r0,|L2.216|
000018  6800              LDR      r0,[r0,#0]
00001a  f4003000          AND      r0,r0,#0x20000
00001e  9000              STR      r0,[sp,#0]
;;;1071       StartUpCounter++;  
000020  9801              LDR      r0,[sp,#4]
000022  1c40              ADDS     r0,r0,#1
000024  9001              STR      r0,[sp,#4]
;;;1072     } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000026  9800              LDR      r0,[sp,#0]
000028  b918              CBNZ     r0,|L2.50|
00002a  9801              LDR      r0,[sp,#4]
00002c  f5b06fa0          CMP      r0,#0x500
000030  d1f1              BNE      |L2.22|
                  |L2.50|
;;;1073   
;;;1074     if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000032  4829              LDR      r0,|L2.216|
000034  6800              LDR      r0,[r0,#0]
000036  f4003000          AND      r0,r0,#0x20000
00003a  b110              CBZ      r0,|L2.66|
;;;1075     {
;;;1076       HSEStatus = (uint32_t)0x01;
00003c  2001              MOVS     r0,#1
00003e  9000              STR      r0,[sp,#0]
000040  e001              B        |L2.70|
                  |L2.66|
;;;1077     }
;;;1078     else
;;;1079     {
;;;1080       HSEStatus = (uint32_t)0x00;
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
                  |L2.70|
;;;1081     }  
;;;1082   
;;;1083     if (HSEStatus == (uint32_t)0x01)
000046  9800              LDR      r0,[sp,#0]
000048  2801              CMP      r0,#1
00004a  d143              BNE      |L2.212|
;;;1084     {
;;;1085       /* Enable Prefetch Buffer */
;;;1086       FLASH->ACR |= FLASH_ACR_PRFTBE;
00004c  4823              LDR      r0,|L2.220|
00004e  6800              LDR      r0,[r0,#0]
000050  f0400010          ORR      r0,r0,#0x10
000054  4921              LDR      r1,|L2.220|
000056  6008              STR      r0,[r1,#0]
;;;1087   
;;;1088       /* Flash 2 wait state */
;;;1089       FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]
00005c  f0200003          BIC      r0,r0,#3
000060  6008              STR      r0,[r1,#0]
;;;1090       FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]
000066  f0400002          ORR      r0,r0,#2
00006a  6008              STR      r0,[r1,#0]
;;;1091   
;;;1092    
;;;1093       /* HCLK = SYSCLK */
;;;1094       RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00006c  481a              LDR      r0,|L2.216|
00006e  6840              LDR      r0,[r0,#4]
000070  4919              LDR      r1,|L2.216|
000072  6048              STR      r0,[r1,#4]
;;;1095         
;;;1096       /* PCLK2 = HCLK */
;;;1097       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000074  4608              MOV      r0,r1
000076  6840              LDR      r0,[r0,#4]
000078  6048              STR      r0,[r1,#4]
;;;1098       
;;;1099       /* PCLK1 = HCLK */
;;;1100       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00007a  4608              MOV      r0,r1
00007c  6840              LDR      r0,[r0,#4]
00007e  f4406080          ORR      r0,r0,#0x400
000082  6048              STR      r0,[r1,#4]
;;;1101   
;;;1102   #ifdef STM32F10X_CL
;;;1103       /* Configure PLLs ------------------------------------------------------*/
;;;1104       /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;1105       /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;1106           
;;;1107       RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;1108                                 RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;1109       RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;1110                                RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;1111     
;;;1112       /* Enable PLL2 */
;;;1113       RCC->CR |= RCC_CR_PLL2ON;
;;;1114       /* Wait till PLL2 is ready */
;;;1115       while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;1116       {
;;;1117       }
;;;1118       
;;;1119      
;;;1120       /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;1121       RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;1122       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;1123                               RCC_CFGR_PLLMULL9); 
;;;1124   #else    
;;;1125       /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;1126       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000084  4608              MOV      r0,r1
000086  6840              LDR      r0,[r0,#4]
000088  f420107c          BIC      r0,r0,#0x3f0000
00008c  6048              STR      r0,[r1,#4]
;;;1127                                           RCC_CFGR_PLLMULL));
;;;1128       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
00008e  4608              MOV      r0,r1
000090  6840              LDR      r0,[r0,#4]
000092  f44010e8          ORR      r0,r0,#0x1d0000
000096  6048              STR      r0,[r1,#4]
;;;1129   #endif /* STM32F10X_CL */
;;;1130   
;;;1131       /* Enable PLL */
;;;1132       RCC->CR |= RCC_CR_PLLON;
000098  4608              MOV      r0,r1
00009a  6800              LDR      r0,[r0,#0]
00009c  f0407080          ORR      r0,r0,#0x1000000
0000a0  6008              STR      r0,[r1,#0]
;;;1133   
;;;1134       /* Wait till PLL is ready */
;;;1135       while((RCC->CR & RCC_CR_PLLRDY) == 0)
0000a2  bf00              NOP      
                  |L2.164|
0000a4  480c              LDR      r0,|L2.216|
0000a6  6800              LDR      r0,[r0,#0]
0000a8  f0007000          AND      r0,r0,#0x2000000
0000ac  2800              CMP      r0,#0
0000ae  d0f9              BEQ      |L2.164|
;;;1136       {
;;;1137       }
;;;1138       
;;;1139       /* Select PLL as system clock source */
;;;1140       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
0000b0  4809              LDR      r0,|L2.216|
0000b2  6840              LDR      r0,[r0,#4]
0000b4  f0200003          BIC      r0,r0,#3
0000b8  4907              LDR      r1,|L2.216|
0000ba  6048              STR      r0,[r1,#4]
;;;1141       RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
0000bc  4608              MOV      r0,r1
0000be  6840              LDR      r0,[r0,#4]
0000c0  f0400002          ORR      r0,r0,#2
0000c4  6048              STR      r0,[r1,#4]
;;;1142   
;;;1143       /* Wait till PLL is used as system clock source */
;;;1144       while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000c6  bf00              NOP      
                  |L2.200|
0000c8  4803              LDR      r0,|L2.216|
0000ca  6840              LDR      r0,[r0,#4]
0000cc  f000000c          AND      r0,r0,#0xc
0000d0  2808              CMP      r0,#8
0000d2  d1f9              BNE      |L2.200|
                  |L2.212|
;;;1145       {
;;;1146       }
;;;1147     }
;;;1148     else
;;;1149     { /* If HSE fails to start-up, the application will have wrong clock 
;;;1150            configuration. User can add here some code to deal with this error */
;;;1151     }
;;;1152   }
0000d4  bd0c              POP      {r2,r3,pc}
;;;1153   #endif
                          ENDP

0000d6  0000              DCW      0x0000
                  |L2.216|
                          DCD      0x40021000
                  |L2.220|
                          DCD      0x40022000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;377      */
;;;378    void SystemCoreClockUpdate (void)
000000  b510              PUSH     {r4,lr}
;;;379    {
;;;380      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
000002  2100              MOVS     r1,#0
000004  2000              MOVS     r0,#0
000006  2200              MOVS     r2,#0
;;;381    
;;;382    #ifdef  STM32F10X_CL
;;;383      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;384    #endif /* STM32F10X_CL */
;;;385    
;;;386    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;387      uint32_t prediv1factor = 0;
;;;388    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;389        
;;;390      /* Get SYSCLK source -------------------------------------------------------*/
;;;391      tmp = RCC->CFGR & RCC_CFGR_SWS;
000008  4b21              LDR      r3,|L3.144|
00000a  685b              LDR      r3,[r3,#4]
00000c  f003010c          AND      r1,r3,#0xc
;;;392      
;;;393      switch (tmp)
000010  b121              CBZ      r1,|L3.28|
000012  2904              CMP      r1,#4
000014  d006              BEQ      |L3.36|
000016  2908              CMP      r1,#8
000018  d128              BNE      |L3.108|
00001a  e007              B        |L3.44|
                  |L3.28|
;;;394      {
;;;395        case 0x00:  /* HSI used as system clock */
;;;396          SystemCoreClock = HSI_VALUE;
00001c  4b1d              LDR      r3,|L3.148|
00001e  4c1e              LDR      r4,|L3.152|
000020  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;397          break;
000022  e027              B        |L3.116|
                  |L3.36|
;;;398        case 0x04:  /* HSE used as system clock */
;;;399          SystemCoreClock = HSE_VALUE;
000024  4b1b              LDR      r3,|L3.148|
000026  4c1c              LDR      r4,|L3.152|
000028  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;400          break;
00002a  e023              B        |L3.116|
                  |L3.44|
;;;401        case 0x08:  /* PLL used as system clock */
;;;402    
;;;403          /* Get PLL clock source and multiplication factor ----------------------*/
;;;404          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00002c  4b18              LDR      r3,|L3.144|
00002e  685b              LDR      r3,[r3,#4]
000030  f4031070          AND      r0,r3,#0x3c0000
;;;405          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000034  4b16              LDR      r3,|L3.144|
000036  685b              LDR      r3,[r3,#4]
000038  f4033280          AND      r2,r3,#0x10000
;;;406          
;;;407    #ifndef STM32F10X_CL      
;;;408          pllmull = ( pllmull >> 18) + 2;
00003c  2302              MOVS     r3,#2
00003e  eb034090          ADD      r0,r3,r0,LSR #18
;;;409          
;;;410          if (pllsource == 0x00)
000042  b922              CBNZ     r2,|L3.78|
;;;411          {
;;;412            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;413            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
000044  4b15              LDR      r3,|L3.156|
000046  4343              MULS     r3,r0,r3
000048  4c13              LDR      r4,|L3.152|
00004a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
00004c  e00d              B        |L3.106|
                  |L3.78|
;;;414          }
;;;415          else
;;;416          {
;;;417     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;418           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;419           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;420           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;421     #else
;;;422            /* HSE selected as PLL clock entry */
;;;423            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
00004e  4b10              LDR      r3,|L3.144|
000050  685b              LDR      r3,[r3,#4]
000052  f4033300          AND      r3,r3,#0x20000
000056  b123              CBZ      r3,|L3.98|
;;;424            {/* HSE oscillator clock divided by 2 */
;;;425              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
000058  4b10              LDR      r3,|L3.156|
00005a  4343              MULS     r3,r0,r3
00005c  4c0e              LDR      r4,|L3.152|
00005e  6023              STR      r3,[r4,#0]  ; SystemCoreClock
000060  e003              B        |L3.106|
                  |L3.98|
;;;426            }
;;;427            else
;;;428            {
;;;429              SystemCoreClock = HSE_VALUE * pllmull;
000062  4b0c              LDR      r3,|L3.148|
000064  4343              MULS     r3,r0,r3
000066  4c0c              LDR      r4,|L3.152|
000068  6023              STR      r3,[r4,#0]  ; SystemCoreClock
                  |L3.106|
;;;430            }
;;;431     #endif
;;;432          }
;;;433    #else
;;;434          pllmull = pllmull >> 18;
;;;435          
;;;436          if (pllmull != 0x0D)
;;;437          {
;;;438             pllmull += 2;
;;;439          }
;;;440          else
;;;441          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;442            pllmull = 13 / 2; 
;;;443          }
;;;444                
;;;445          if (pllsource == 0x00)
;;;446          {
;;;447            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;448            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;449          }
;;;450          else
;;;451          {/* PREDIV1 selected as PLL clock entry */
;;;452            
;;;453            /* Get PREDIV1 clock source and division factor */
;;;454            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;455            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;456            
;;;457            if (prediv1source == 0)
;;;458            { 
;;;459              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;460              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;461            }
;;;462            else
;;;463            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;464              
;;;465              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;466              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;467              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;468              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;469            }
;;;470          }
;;;471    #endif /* STM32F10X_CL */ 
;;;472          break;
00006a  e003              B        |L3.116|
                  |L3.108|
;;;473    
;;;474        default:
;;;475          SystemCoreClock = HSI_VALUE;
00006c  4b09              LDR      r3,|L3.148|
00006e  4c0a              LDR      r4,|L3.152|
000070  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;476          break;
000072  bf00              NOP      
                  |L3.116|
000074  bf00              NOP                            ;397
;;;477      }
;;;478      
;;;479      /* Compute HCLK clock frequency ----------------*/
;;;480      /* Get HCLK prescaler */
;;;481      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000076  4b06              LDR      r3,|L3.144|
000078  685b              LDR      r3,[r3,#4]
00007a  f3c31303          UBFX     r3,r3,#4,#4
00007e  4c08              LDR      r4,|L3.160|
000080  5ce1              LDRB     r1,[r4,r3]
;;;482      /* HCLK clock frequency */
;;;483      SystemCoreClock >>= tmp;  
000082  4b05              LDR      r3,|L3.152|
000084  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
000086  40cb              LSRS     r3,r3,r1
000088  4c03              LDR      r4,|L3.152|
00008a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;484    }
00008c  bd10              POP      {r4,pc}
;;;485    
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      0x40021000
                  |L3.148|
                          DCD      0x007a1200
                  |L3.152|
                          DCD      SystemCoreClock
                  |L3.156|
                          DCD      0x003d0900
                  |L3.160|
                          DCD      AHBPrescTable

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;217      */
;;;218    void SystemInit (void)
000000  b51c              PUSH     {r2-r4,lr}
;;;219    {
;;;220    	#ifndef  MCBR03 /**ÄÚ²¿¾§Õñ 64M**/
;;;221    	volatile uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  9000              STR      r0,[sp,#0]
;;;222    	
;;;223      RCC_DeInit();
000008  f7fffffe          BL       RCC_DeInit
;;;224      
;;;225      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;226      /* Enable HSI */    
;;;227      RCC->CR |= ((uint32_t)RCC_CR_HSION);
00000c  4833              LDR      r0,|L4.220|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400001          ORR      r0,r0,#1
000014  4931              LDR      r1,|L4.220|
000016  6008              STR      r0,[r1,#0]
;;;228     
;;;229      /* Wait till HSI is ready and if Time out is reached exit */
;;;230      do
000018  bf00              NOP      
                  |L4.26|
;;;231      {
;;;232        HSEStatus = RCC->CR & RCC_CR_HSIRDY;
00001a  4830              LDR      r0,|L4.220|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0000002          AND      r0,r0,#2
000022  9000              STR      r0,[sp,#0]
;;;233        StartUpCounter++;  
000024  9801              LDR      r0,[sp,#4]
000026  1c40              ADDS     r0,r0,#1
000028  9001              STR      r0,[sp,#4]
;;;234      } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
00002a  9800              LDR      r0,[sp,#0]
00002c  b918              CBNZ     r0,|L4.54|
00002e  9801              LDR      r0,[sp,#4]
000030  f5b06fa0          CMP      r0,#0x500
000034  d1f1              BNE      |L4.26|
                  |L4.54|
;;;235      if ((RCC->CR & RCC_CR_HSIRDY) != RESET)
000036  4829              LDR      r0,|L4.220|
000038  6800              LDR      r0,[r0,#0]
00003a  f0000002          AND      r0,r0,#2
00003e  b110              CBZ      r0,|L4.70|
;;;236      {
;;;237        HSEStatus = (uint32_t)0x01;
000040  2001              MOVS     r0,#1
000042  9000              STR      r0,[sp,#0]
000044  e001              B        |L4.74|
                  |L4.70|
;;;238      }
;;;239      else
;;;240      {
;;;241        HSEStatus = (uint32_t)0x00;
000046  2000              MOVS     r0,#0
000048  9000              STR      r0,[sp,#0]
                  |L4.74|
;;;242      }  
;;;243      if (HSEStatus == (uint32_t)0x01)
00004a  9800              LDR      r0,[sp,#0]
00004c  2801              CMP      r0,#1
00004e  d143              BNE      |L4.216|
;;;244      {
;;;245        /* Enable Prefetch Buffer */
;;;246        FLASH->ACR |= FLASH_ACR_PRFTBE;
000050  4823              LDR      r0,|L4.224|
000052  6800              LDR      r0,[r0,#0]
000054  f0400010          ORR      r0,r0,#0x10
000058  4921              LDR      r1,|L4.224|
00005a  6008              STR      r0,[r1,#0]
;;;247        /* Flash 2 wait state */
;;;248        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
00005c  4608              MOV      r0,r1
00005e  6800              LDR      r0,[r0,#0]
000060  f0200003          BIC      r0,r0,#3
000064  6008              STR      r0,[r1,#0]
;;;249        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000066  4608              MOV      r0,r1
000068  6800              LDR      r0,[r0,#0]
00006a  f0400002          ORR      r0,r0,#2
00006e  6008              STR      r0,[r1,#0]
;;;250     
;;;251        /* HCLK = SYSCLK */
;;;252        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
000070  481a              LDR      r0,|L4.220|
000072  6840              LDR      r0,[r0,#4]
000074  4919              LDR      r1,|L4.220|
000076  6048              STR      r0,[r1,#4]
;;;253          
;;;254        /* PCLK2 = HCLK */
;;;255        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000078  4608              MOV      r0,r1
00007a  6840              LDR      r0,[r0,#4]
00007c  6048              STR      r0,[r1,#4]
;;;256        
;;;257        /* PCLK1 = HCLK */
;;;258        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00007e  4608              MOV      r0,r1
000080  6840              LDR      r0,[r0,#4]
000082  f4406080          ORR      r0,r0,#0x400
000086  6048              STR      r0,[r1,#4]
;;;259      
;;;260        /*  PLL configuration: PLLCLK = HSI/2 * 16 = 64 MHz */
;;;261        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000088  4608              MOV      r0,r1
00008a  6840              LDR      r0,[r0,#4]
00008c  f420107c          BIC      r0,r0,#0x3f0000
000090  6048              STR      r0,[r1,#4]
;;;262                                            RCC_CFGR_PLLMULL));
;;;263        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSI_Div2| RCC_CFGR_PLLMULL16);
000092  4608              MOV      r0,r1
000094  6840              LDR      r0,[r0,#4]
000096  f4401060          ORR      r0,r0,#0x380000
00009a  6048              STR      r0,[r1,#4]
;;;264     
;;;265        /* Enable PLL */
;;;266        RCC->CR |= RCC_CR_PLLON;
00009c  4608              MOV      r0,r1
00009e  6800              LDR      r0,[r0,#0]
0000a0  f0407080          ORR      r0,r0,#0x1000000
0000a4  6008              STR      r0,[r1,#0]
;;;267        /* Wait till PLL is ready */
;;;268        while((RCC->CR & RCC_CR_PLLRDY) == 0)
0000a6  bf00              NOP      
                  |L4.168|
0000a8  480c              LDR      r0,|L4.220|
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0007000          AND      r0,r0,#0x2000000
0000b0  2800              CMP      r0,#0
0000b2  d0f9              BEQ      |L4.168|
;;;269        {
;;;270        }
;;;271        
;;;272        /* Select PLL as system clock source */
;;;273        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
0000b4  4809              LDR      r0,|L4.220|
0000b6  6840              LDR      r0,[r0,#4]
0000b8  f0200003          BIC      r0,r0,#3
0000bc  4907              LDR      r1,|L4.220|
0000be  6048              STR      r0,[r1,#4]
;;;274        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
0000c0  4608              MOV      r0,r1
0000c2  6840              LDR      r0,[r0,#4]
0000c4  f0400002          ORR      r0,r0,#2
0000c8  6048              STR      r0,[r1,#4]
;;;275        /* Wait till PLL is used as system clock source */
;;;276        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000ca  bf00              NOP      
                  |L4.204|
0000cc  4803              LDR      r0,|L4.220|
0000ce  6840              LDR      r0,[r0,#4]
0000d0  f000000c          AND      r0,r0,#0xc
0000d4  2808              CMP      r0,#8
0000d6  d1f9              BNE      |L4.204|
                  |L4.216|
;;;277        {
;;;278        }
;;;279      }
;;;280      else
;;;281      { /* If HSE fails to start-up, the application will have wrong clock 
;;;282             configuration. User can add here some code to deal with this error */
;;;283      }
;;;284      #else
;;;285    		/* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;286    		/* Set HSION bit */
;;;287    		RCC->CR |= (uint32_t)0x00000001;
;;;288    
;;;289    		/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;290    	#ifndef STM32F10X_CL
;;;291    		RCC->CFGR &= (uint32_t)0xF8FF0000;
;;;292    	#else
;;;293    		RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;294    	#endif /* STM32F10X_CL */   
;;;295    		
;;;296    		/* Reset HSEON, CSSON and PLLON bits */
;;;297    		RCC->CR &= (uint32_t)0xFEF6FFFF;
;;;298    
;;;299    		/* Reset HSEBYP bit */
;;;300    		RCC->CR &= (uint32_t)0xFFFBFFFF;
;;;301    
;;;302    		/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;303    		RCC->CFGR &= (uint32_t)0xFF80FFFF;
;;;304    
;;;305    	#ifdef STM32F10X_CL
;;;306    		/* Reset PLL2ON and PLL3ON bits */
;;;307    		RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;308    
;;;309    		/* Disable all interrupts and clear pending bits  */
;;;310    		RCC->CIR = 0x00FF0000;
;;;311    
;;;312    		/* Reset CFGR2 register */
;;;313    		RCC->CFGR2 = 0x00000000;
;;;314    	#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;315    		/* Disable all interrupts and clear pending bits  */
;;;316    		RCC->CIR = 0x009F0000;
;;;317    
;;;318    		/* Reset CFGR2 register */
;;;319    		RCC->CFGR2 = 0x00000000;      
;;;320    	#else
;;;321    		/* Disable all interrupts and clear pending bits  */
;;;322    		RCC->CIR = 0x009F0000;
;;;323    	#endif /* STM32F10X_CL */
;;;324    			
;;;325    	#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;326    		#ifdef DATA_IN_ExtSRAM
;;;327    			SystemInit_ExtMemCtl(); 
;;;328    		#endif /* DATA_IN_ExtSRAM */
;;;329    	#endif 
;;;330    
;;;331    		/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;332    		/* Configure the Flash Latency cycles and enable prefetch buffer */
;;;333    		SetSysClock();
;;;334    
;;;335    	#ifdef VECT_TAB_SRAM
;;;336    		SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;337    	#else
;;;338    		SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
;;;339    	#endif 
;;;340      #endif
;;;341    }
0000d8  bd1c              POP      {r2-r4,pc}
;;;342    
                          ENDP

0000da  0000              DCW      0x0000
                  |L4.220|
                          DCD      0x40021000
                  |L4.224|
                          DCD      0x40022000

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\system_stm32f10x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_system_stm32f10x_c_5d646a67____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REVSH|
#line 128
|__asm___18_system_stm32f10x_c_5d646a67____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
