L 1 "..\..\Internet\DHCP\dhcp.c"
N//*****************************************************************************
N//
N//! \file dhcp.c
N//! \brief DHCP APIs implement file.
N//! \details Processig DHCP protocol as DISCOVER, OFFER, REQUEST, ACK, NACK and DECLINE.
N//! \version 1.1.0
N//! \date 2013/11/18
N//! \par  Revision history
N//!       <2013/11/18> 1st Release
N//!       <2012/12/20> V1.1.0
N//!         1. Optimize code
N//!         2. Add reg_dhcp_cbfunc()
N//!         3. Add DHCP_stop() 
N//!         4. Integrate check_DHCP_state() & DHCP_run() to DHCP_run()
N//!         5. Don't care system endian
N//!         6. Add comments
N//!       <2012/12/26> V1.1.1
N//!         1. Modify variable declaration: dhcp_tick_1s is declared volatile for code optimization
N//! \author Eric Jung & MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#include "socket.h"
L 1 "..\..\Ethernet\socket.h" 1
N//*****************************************************************************
N//
N//! \file socket.h
N//! \brief SOCKET APIs Header file.
N//! \details SOCKET APIs like as berkeley socket api. 
N//! \version 1.0.2
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2014/05/01> V1.0.2. Refer to M20140501
N//!         1. Modify the comment : SO_REMAINED -> PACK_REMAINED
N//!         2. Add the comment as zero byte udp data reception in getsockopt(). 
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N/**
N * @defgroup WIZnet_socket_APIs 1. WIZnet socket APIs
N * @brief WIZnet socket APIs are based on Berkeley socket APIs,  thus it has much similar name and interface.
N *        But there is a little bit of difference.
N * @details
N * <b> Comparison between WIZnet and Berkeley SOCKET APIs </b>
N * <table>
N *    <tr>   <td><b>API</b></td> <td><b>WIZnet</b></td> <td><b>Berkeley</b></td>   </tr>
N *    <tr>   <td>socket()</td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>bind()</b></td> <td>X</td> <td>O</td>   </tr>
N *    <tr>   <td><b>listen()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>connect()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>accept()</b></td> <td>X</td> <td>O</td>   </tr>
N *    <tr>   <td><b>recv()</b></td> <td>O</td> <td>O</td>    </tr>
N *    <tr>   <td><b>send()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>recvfrom()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>sendto()</b></td> <td>O</td> <td>O</td>    </tr>
N *    <tr>   <td><b>closesocket()</b></td> <td>O<br>close() & disconnect()</td> <td>O</td>   </tr>
N * </table>
N * There are @b bind() and @b accept() functions in @b Berkeley SOCKET API but,
N * not in @b WIZnet SOCKET API. Because socket() of WIZnet is not only creating a SOCKET but also binding a local port number,
N * and listen() of WIZnet is not only listening to connection request from client but also accepting the connection request. \n
N * When you program "TCP SERVER" with Berkeley SOCKET API, you can use only one listen port.
N * When the listen SOCKET accepts a connection request from a client, it keeps listening.
N * After accepting the connection request, a new SOCKET is created and the new SOCKET is used in communication with the client. \n
N * Following figure shows network flow diagram by Berkeley SOCKET API.
N * @image html Berkeley_SOCKET.jpg "<Berkeley SOCKET API>"
N * But, When you program "TCP SERVER" with WIZnet SOCKET API, you can use as many as 8 listen SOCKET with same port number. \n
N * Because there's no accept() in WIZnet SOCKET APIs, when the listen SOCKET accepts a connection request from a client,
N * it is changed in order to communicate with the client.
N * And the changed SOCKET is not listening any more and is dedicated for communicating with the client. \n
N * If there're many listen SOCKET with same listen port number and a client requests a connection,
N * the SOCKET which has the smallest SOCKET number accepts the request and is changed as communication SOCKET. \n
N * Following figure shows network flow diagram by WIZnet SOCKET API.
N * @image html WIZnet_SOCKET.jpg "<WIZnet SOCKET API>"
N */
N#ifndef _SOCKET_H_
N#define _SOCKET_H_
N
N#include "wizchip_conf.h"
L 1 "..\..\Ethernet\wizchip_conf.h" 1
N//*****************************************************************************
N//
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. It could be replaced at WIZCHIP I/O function because they were made by WIZCHIP I/O functions.  
N * @details There are functions of configuring WIZCHIP, network, interrupt, phy, network information and timer. \n
N * 
N */
N
N#ifndef  _WIZCHIP_CONF_H_
N#define  _WIZCHIP_CONF_H_
N
N#include <stdint.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 54 "..\..\Ethernet\wizchip_conf.h" 2
N/**
N * @brief Select WIZCHIP.
N * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
N *       ex> <code> #define \_WIZCHIP_      5500 </code>
N */
N#define _WIZCHIP_                      5500   // 5100, 5200, 5500
N
N#define _WIZCHIP_IO_MODE_NONE_         0x0000
N#define _WIZCHIP_IO_MODE_BUS_          0x0100 /**< Bus interface mode */
N#define _WIZCHIP_IO_MODE_SPI_          0x0200 /**< SPI interface mode */
N//#define _WIZCHIP_IO_MODE_IIC_          0x0400
N//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
N// Add to
N//
N
N#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) /**< BUS interface mode for direct  */
N#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) /**< BUS interface mode for indirect */
N
N#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
N#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
N
N
N#if   (_WIZCHIP_ == 5100)
X#if   (5500 == 5100)
S   #define _WIZCHIP_ID_                "W5100\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S
S#elif (_WIZCHIP_ == 5200)
X#elif (5500 == 5200)
S   #define _WIZCHIP_ID_                "W5200\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S   #include "W5200/w5200.h"
N#elif (_WIZCHIP_ == 5500)
X#elif (5500 == 5500)
N  #define _WIZCHIP_ID_                 "W5500\0"
N  
N/**
N * @brief Define interface mode. \n
N * @todo Should select interface mode as chip. 
N *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
N *        - Others will be defined in future. \n\n
N *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
N *       
N */
N   //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
N   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
N   #include "W5500/w5500.h"
L 1 "..\..\Ethernet\W5500/w5500.h" 1
N//*****************************************************************************
N//
N//! \file w5500.h
N//! \brief W5500 HAL Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#ifndef  _W5500_H_
N#define  _W5500_H_
N
N#include <stdint.h>
N#include "wizchip_conf.h"
L 1 "..\..\Ethernet\wizchip_conf.h" 1
N//*****************************************************************************
N//
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. It could be replaced at WIZCHIP I/O function because they were made by WIZCHIP I/O functions.  
N * @details There are functions of configuring WIZCHIP, network, interrupt, phy, network information and timer. \n
N * 
N */
N
N#ifndef  _WIZCHIP_CONF_H_
S#define  _WIZCHIP_CONF_H_
S
S#include <stdint.h>
S/**
S * @brief Select WIZCHIP.
S * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
S *       ex> <code> #define \_WIZCHIP_      5500 </code>
S */
S#define _WIZCHIP_                      5500   // 5100, 5200, 5500
S
S#define _WIZCHIP_IO_MODE_NONE_         0x0000
S#define _WIZCHIP_IO_MODE_BUS_          0x0100 /**< Bus interface mode */
S#define _WIZCHIP_IO_MODE_SPI_          0x0200 /**< SPI interface mode */
S//#define _WIZCHIP_IO_MODE_IIC_          0x0400
S//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
S// Add to
S//
S
S#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) /**< BUS interface mode for direct  */
S#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) /**< BUS interface mode for indirect */
S
S#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
S#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
S
S
S#if   (_WIZCHIP_ == 5100)
S   #define _WIZCHIP_ID_                "W5100\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S
S#elif (_WIZCHIP_ == 5200)
S   #define _WIZCHIP_ID_                "W5200\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S   #include "W5200/w5200.h"
S#elif (_WIZCHIP_ == 5500)
S  #define _WIZCHIP_ID_                 "W5500\0"
S  
S/**
S * @brief Define interface mode. \n
S * @todo Should select interface mode as chip. 
S *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
S *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
S *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
S *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
S *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
S *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
S *        - Others will be defined in future. \n\n
S *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
S *       
S */
S   //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
S   #include "W5500/w5500.h"
S#else 
S   #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
S#endif
S
S#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
S#endif
S
S/**
S * @brief Define I/O base address when BUS IF mode.
S * @todo Should re-define it to fit your system when BUS IF Mode (@ref \_WIZCHIP_IO_MODE_BUS_,
S *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
S *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
S */
S#define _WIZCHIP_IO_BASE_              0x00000000  // 
S
S#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
S   #ifndef _WIZCHIP_IO_BASE_
S      #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
S   #endif
S#endif   
S
S#if _WIZCHIP_ > 5100
S   #define _WIZCHIP_SOCK_NUM_   8   ///< The count of independant socket of @b WIZCHIP
S#else
S   #define _WIZCHIP_SOCK_NUM_   4   ///< The count of independant socket of @b WIZCHIP
S#endif      
S
S
S/********************************************************
S* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
S*********************************************************/
S/**
S * @ingroup DATA_TYPE
S * @brief The set of callback functions for W5500:@ref WIZCHIP_IO_Functions W5200:@ref WIZCHIP_IO_Functions_W5200
S */
Stypedef struct __WIZCHIP
S{
S   uint16_t  if_mode;               ///< host interface mode
S   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
S   /**
S    * The set of critical section callback func.
S    */
S   struct _CRIS
S   {
S      void (*_enter)  (void);       ///< crtical section enter 
S      void (*_exit) (void);         ///< critial section exit  
S   }CRIS;  
S   /**
S    *  The set of @ref\_WIZCHIP_ select control callback func.
S    */
S   struct _CS
S   {
S      void (*_select)  (void);      ///< @ref \_WIZCHIP_ selected
S      void (*_deselect)(void);      ///< @ref \_WIZCHIP_ deselected
S   }CS;  
S   /**
S    * The set of interface IO callback func.
S    */
S   union _IF
S   {	 
S      /**
S       * For BUS interface IO
S       */  
S      struct
S      {
S         uint8_t  (*_read_byte)  (uint32_t AddrSel);
S         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
S      }BUS;      
S      /**
S       * For SPI interface IO
S       */
S      struct
S      {
S         uint8_t (*_read_byte)   (void);
S         void    (*_write_byte)  (uint8_t wb);
S      }SPI;
S      // To be added
S      //
S   }IF;
S}_WIZCHIP;
S
Sextern _WIZCHIP  WIZCHIP;
S
S/**
S * @ingroup DATA_TYPE
S *  WIZCHIP control type enumration used in @ref ctlwizchip().
S */
Stypedef enum
S{
S   CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
S   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
S   CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
S   CW_CLR_INTERRUPT,   ///< Clears interrupt
S   CW_SET_INTRMASK,    ///< Masks interrupt
S   CW_GET_INTRMASK,    ///< Get interrupt mask
S   CW_SET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
S   CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
S   CW_GET_ID,          ///< Gets WIZCHIP name.
S
S#if _WIZCHIP_ ==  5500
S   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
S   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
S   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
S   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
S   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
S#endif
S   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
S   CW_GET_PHYLINK      ///< Get PHY Link status
S}ctlwizchip_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Network control type enumration used in @ref ctlnetwork().
S */
Stypedef enum
S{
S   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
S   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
S   CN_SET_NETMODE,  ///< Set network mode as WOL, PPPoE, Ping Block, and Force ARP mode
S   CN_GET_NETMODE,  ///< Get network mode as WOL, PPPoE, Ping Block, and Force ARP mode
S   CN_SET_TIMEOUT,  ///< Set network timeout as retry count and time.
S   CN_GET_TIMEOUT,  ///< Get network timeout as retry count and time.
S}ctlnetwork_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Interrupt kind when CW_SET_INTRRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK
S *  and CW_GET_INTRMASK is used in @ref ctlnetwork().
S *  It can be used with OR operation.
S */
Stypedef enum
S{
S#if _WIZCHIP_ > 5200
S   IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
S#endif   
S
S   IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
S
S#if _WIZCHIP_ != 5200
S   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
S#endif   
S
S   IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
S
S   IK_SOCK_0            = (1 << 8),   ///< Socket 0 interrupt
S   IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
S   IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
S   IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
S#if _WIZCHIP_ > 5100   
S   IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
S   IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
S   IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
S   IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
S#endif   
S
S#if _WIZCHIP_ > 5100
S   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
S#else
S   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
S#endif      
S}intr_kind;
S
S#define PHY_CONFBY_HW            0     ///< Configured PHY operation mode by HW pin
S#define PHY_CONFBY_SW            1     ///< Configured PHY operation mode by SW register   
S#define PHY_MODE_MANUAL          0     ///< Configured PHY operation mode with user setting.
S#define PHY_MODE_AUTONEGO        1     ///< Configured PHY operation mode with auto-negotiation
S#define PHY_SPEED_10             0     ///< Link Speed 10
S#define PHY_SPEED_100            1     ///< Link Speed 100
S#define PHY_DUPLEX_HALF          0     ///< Link Half-Duplex
S#define PHY_DUPLEX_FULL          1     ///< Link Full-Duplex
S#define PHY_LINK_OFF             0     ///< Link Off
S#define PHY_LINK_ON              1     ///< Link On
S#define PHY_POWER_NORM           0     ///< PHY power normal mode
S#define PHY_POWER_DOWN           1     ///< PHY power down mode 
S
S
S#if _WIZCHIP_ == 5500 
S/**
S * @ingroup DATA_TYPE
S *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
S *  and it indicates the real PHY status configured by HW or SW in all WIZCHIP. \n
S *  Valid only in W5500.
S */
Stypedef struct wiz_PhyConf_t
S{
S      uint8_t by;       ///< set by @ref PHY_CONFBY_HW or @ref PHY_CONFBY_SW
S      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL or @ref PHY_MODE_AUTONEGO
S      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
S      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
S      //uint8_t power;  ///< set by @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
S      //uint8_t link;   ///< Valid only in CW_GET_PHYSTATUS. set by @ref PHY_LINK_ON or PHY_DUPLEX_OFF 
S   }wiz_PhyConf;
S#endif   
S
S/**
S * @ingroup DATA_TYPE
S *  It used in setting dhcp_mode of @ref wiz_NetInfo.
S */
Stypedef enum
S{
S   NETINFO_STATIC = 1,    ///< Static IP configuration by manually.
S   NETINFO_DHCP           ///< Dynamic IP configruation from a DHCP sever
S}dhcp_mode;
S
S/**
S * @ingroup DATA_TYPE
S *  Network Information for WIZCHIP
S */
Stypedef struct wiz_NetInfo_t
S{
S   uint8_t mac[6];  ///< Source Mac Address
S   uint8_t ip[4];   ///< Source IP Address
S   uint8_t sn[4];   ///< Subnet Mask 
S   uint8_t gw[4];   ///< Gateway IP Address
S   uint8_t dns[4];  ///< DNS server IP Address
S   dhcp_mode dhcp;  ///< 1 - Static, 2 - DHCP
S}wiz_NetInfo;
S
S/**
S * @ingroup DATA_TYPE
S *  Network mode
S */
Stypedef enum
S{
S#if _WIZCHIP_ == 5500   
S   NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
S#endif   
S   NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
S   NM_PINGBLOCK   = (1<<4),  ///< Block ping-request
S   NM_PPPOE       = (1<<3),  ///< PPPoE mode
S}netmode_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Used in CN_SET_TIMEOUT or CN_GET_TIMEOUT of @ref ctlwizchip() for timeout configruation.
S */
Stypedef struct wiz_NetTimeout_t
S{
S   uint8_t  retry_cnt;     ///< retry count 
S   uint16_t time_100us;    ///< time unit 100us
S}wiz_NetTimeout;
S
S/**
S *@brief Registers call back function for critical section of I/O functions such as
S *\ref WIZCHIP_READ, @ref WIZCHIP_WRITE, @ref WIZCHIP_READ_BUF and @ref WIZCHIP_WRITE_BUF.
S *@param cris_en : callback function for critical section enter.
S *@param cris_ex : callback function for critical section exit.
S *@todo Describe @ref WIZCHIP_CRITICAL_ENTER and @ref WIZCHIP_CRITICAL_EXIT marco or register your functions.
S *@note If you do not describe or register, default functions(@ref wizchip_cris_enter & @ref wizchip_cris_exit) is called.
S */
Svoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
S
S
S/**
S *@brief Registers call back function for WIZCHIP select & deselect.
S *@param cs_sel : callback function for WIZCHIP select
S *@param cs_desel : callback fucntion for WIZCHIP deselect
S *@todo Describe @ref wizchip_cs_select and @ref wizchip_cs_deselect function or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
S
S/**
S *@brief Registers call back function for bus interface.
S *@param bus_rb   : callback function to read byte data using system bus
S *@param bus_wb   : callback function to write byte data using system bus
S *@todo Describe @ref wizchip_bus_readbyte and @ref wizchip_bus_writebyte function
S *or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
S
S/**
S *@brief Registers call back function for SPI interface.
S *@param spi_rb : callback function to read byte usig SPI 
S *@param spi_wb : callback function to write byte usig SPI 
S *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
S *or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb));
S
S/**
S * @ingroup extra_functions
S * @brief Controls to the WIZCHIP.
S * @details Resets WIZCHIP & internal PHY, Configures PHY mode, Monitor PHY(Link,Speed,Half/Full/Auto),
S * controls interrupt & mask and so on.
S * @param cwtype : Decides to the control type
S * @param arg : arg type is dependent on cwtype.
S * @return  0 : Success \n
S *         -1 : Fail because of invalid \ref ctlwizchip_type or unsupported \ref ctlwizchip_type in WIZCHIP 
S */          
Sint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
S
S/**
S * @ingroup extra_functions
S * @brief Controls to network.
S * @details Controls to network environment, mode, timeout and so on.
S * @param cntype : Input. Decides to the control type
S * @param arg : Inout. arg type is dependent on cntype.
S * @return -1 : Fail because of invalid \ref ctlnetwork_type or unsupported \ref ctlnetwork_type in WIZCHIP \n
S *          0 : Success      
S */          
Sint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
S
S
S/* 
S * The following functions are implemented for internal use. 
S * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
S */
S 
S/**
S * @ingroup extra_functions
S * @brief Reset WIZCHIP by softly.
S */ 
Svoid   wizchip_sw_reset(void);
S
S/**
S * @ingroup extra_functions
S * @brief Initializes WIZCHIP with socket buffer size
S * @param txsize Socket tx buffer sizes. If null, initialized the default size 2KB.
S * @param rxsize Socket rx buffer sizes. If null, initialized the default size 2KB.
S * @return 0 : succcess \n
S *        -1 : fail. Invalid buffer size
S */
Sint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
S
S/** 
S * @ingroup extra_functions
S * @brief Clear Interrupt of WIZCHIP.
S * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Svoid wizchip_clrinterrupt(intr_kind intr);
S
S/** 
S * @ingroup extra_functions
S * @brief Get Interrupt of WIZCHIP.
S * @return @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Sintr_kind wizchip_getinterrupt(void);
S
S/** 
S * @ingroup extra_functions
S * @brief Mask or Unmask Interrupt of WIZCHIP.
S * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Svoid wizchip_setinterruptmask(intr_kind intr);
S
S/** 
S * @ingroup extra_functions
S * @brief Get Interrupt mask of WIZCHIP.
S * @return : The operated OR vaule of @ref intr_kind. It can type-cast to uint16_t.
S */
Sintr_kind wizchip_getinterruptmask(void);
S
S#if _WIZCHIP_ > 5100
S   int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
S   int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
S#endif
S
S#if _WIZCHIP_ == 5500
S   void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
S/**
S * @ingroup extra_functions
S * @brief Set the phy information for WIZCHIP without power mode
S * @param phyconf : @ref wiz_PhyConf
S */
S   void   wizphy_setphyconf(wiz_PhyConf* phyconf);  
S /**
S * @ingroup extra_functions
S * @brief Get phy configuration information.
S * @param phyconf : @ref wiz_PhyConf
S */
S   void   wizphy_getphyconf(wiz_PhyConf* phyconf); 
S /**
S * @ingroup extra_functions
S * @brief Get phy status.
S * @param phyconf : @ref wiz_PhyConf
S */ 
S   void   wizphy_getphystat(wiz_PhyConf* phyconf);
S /**
S * @ingroup extra_functions
S * @brief set the power mode of phy inside WIZCHIP. Refer to @ref PHYCFGR in W5500, @ref PHYSTATUS in W5200
S * @param pmode Settig value of power down mode.
S */   
S   int8_t wizphy_setphypmode(uint8_t pmode);    
S#endif
S
S/**
S* @ingroup extra_functions
S * @brief Set the network information for WIZCHIP
S * @param pnetinfo : @ref wizNetInfo
S */
Svoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
S
S/**
S * @ingroup extra_functions
S * @brief Get the network information for WIZCHIP
S * @param pnetinfo : @ref wizNetInfo
S */
Svoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
S
S/**
S * @ingroup extra_functions
S * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
S * @param pnetinfo Value of network mode. Refer to @ref netmode_type.
S */
Sint8_t wizchip_setnetmode(netmode_type netmode);
S
S/**
S * @ingroup extra_functions
S * @brief Get the network mode such WOL, PPPoE, Ping Block, and etc. 
S * @return Value of network mode. Refer to @ref netmode_type.
S */
Snetmode_type wizchip_getnetmode(void);
S
S/**
S * @ingroup extra_functions
S * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
S * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
S * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
S */
Svoid wizchip_settimeout(wiz_NetTimeout* nettime);
S
S/**
S * @ingroup extra_functions
S * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
S * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
S * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
S */
Svoid wizchip_gettimeout(wiz_NetTimeout* nettime);
S
N#endif   // _WIZCHIP_CONF_H_
L 47 "..\..\Ethernet\W5500/w5500.h" 2
N
N#define _W5500_IO_BASE_              0x00000000
N
N#define _W5500_SPI_READ_			   (0x00 << 2) //< SPI interface Read operation in Control Phase
N#define _W5500_SPI_WRITE_			   (0x01 << 2) //< SPI interface Write operation in Control Phase
N
N#define WIZCHIP_CREG_BLOCK          0x00 	//< Common register block
N#define WIZCHIP_SREG_BLOCK(N)       (1+4*N) //< Socket N register block
N#define WIZCHIP_TXBUF_BLOCK(N)      (2+4*N) //< Socket N Tx buffer address block
N#define WIZCHIP_RXBUF_BLOCK(N)      (3+4*N) //< Socket N Rx buffer address block
N
N#define WIZCHIP_OFFSET_INC(ADDR, N)    (ADDR + (N<<8)) //< Increase offset address
N
N
N///////////////////////////////////////
N// Definition For Legacy Chip Driver //
N///////////////////////////////////////
N#define IINCHIP_READ(ADDR)                WIZCHIP_READ(ADDR)               ///< The defined for legacy chip driver
N#define IINCHIP_WRITE(ADDR,VAL)           WIZCHIP_WRITE(ADDR,VAL)          ///< The defined for legacy chip driver
N#define IINCHIP_READ_BUF(ADDR,BUF,LEN)    WIZCHIP_READ_BUF(ADDR,BUF,LEN)   ///< The defined for legacy chip driver
N#define IINCHIP_WRITE_BUF(ADDR,BUF,LEN)   WIZCHIP_WRITE(ADDR,BUF,LEN)      ///< The defined for legacy chip driver
N
N//////////////////////////////
N//--------------------------  defgroup ---------------------------------
N/**
N * @defgroup W5500 W5500
N *
N * @brief WHIZCHIP register defines and I/O functions of @b W5500.
N *
N * - @ref WIZCHIP_register : @ref Common_register_group and @ref Socket_register_group
N * - @ref WIZCHIP_IO_Functions : @ref Basic_IO_function, @ref Common_register_access_function and @ref Socket_register_access_function
N */
N 
N 
N/**
N * @defgroup WIZCHIP_register WIZCHIP register
N * @ingroup W5500
N *
N * @brief WHIZCHIP register defines register group of @b W5500.
N *
N * - @ref Common_register_group : Common register group
N * - @ref Socket_register_group : \c SOCKET n register group
N */
N
N
N/**
N * @defgroup WIZCHIP_IO_Functions WIZCHIP I/O functions
N * @ingroup W5500
N *
N * @brief This supports the basic I/O functions for @ref WIZCHIP_register.
N *
N * - <b> Basic I/O function </b> \n
N *   WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF() \n\n
N *
N * - @ref Common_register_group <b>access functions</b> \n
N * 	-# @b Mode \n
N *    getMR(), setMR()
N * 	-# @b Interrupt \n
N *    getIR(), setIR(), getIMR(), setIMR(), getSIR(), setSIR(), getSIMR(), setSIMR(), getINTLEVEL(), setINTLEVEL()
N * 	-# <b> Network Information </b> \n
N *    getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR()
N * 	-# @b Retransmission \n
N *    getRCR(), setRCR(), getRTR(), setRTR()
N * 	-# @b PPPoE \n
N *    getPTIMER(), setPTIMER(), getPMAGIC(), getPMAGIC(), getPSID(), setPSID(), getPHAR(), setPHAR(), getPMRU(), setPMRU()
N * 	-# <b> ICMP packet </b>\n
N *    getUIPR(), getUPORTR()
N * 	-# @b etc. \n
N *    getPHYCFGR(), setPHYCFGR(), getVERSIONR() \n\n
N *
N * - \ref Socket_register_group <b>access functions</b> \n
N *   -# <b> SOCKET control</b> \n
N *      getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IR()
N *   -# <b> SOCKET information</b> \n
N *      getSn_SR(), getSn_DHAR(), setSn_DHAR(), getSn_PORT(), setSn_PORT(), getSn_DIPR(), setSn_DIPR(), getSn_DPORT(), setSn_DPORT()
N *      getSn_MSSR(), setSn_MSSR()
N *   -# <b> SOCKET communication </b> \n
N *      getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE() \n
N *      getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
N *      getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
N *      getSn_TX_FSR(), getSn_RX_RSR(), getSn_KPALVTR(), setSn_KPALVTR()
N *   -# <b> IP header field </b> \n
N *      getSn_FRAG(), setSn_FRAG(),  getSn_TOS(), setSn_TOS() \n
N *      getSn_TTL(), setSn_TTL()
N */
N
N
N
N/**
N * @defgroup Common_register_group Common register
N * @ingroup WIZCHIP_register
N *
N * @brief Common register group\n
N * It set the basic for the networking\n
N * It set the configuration such as interrupt, network information, ICMP, etc.
N * @details
N * @sa MR : Mode register.
N * @sa GAR, SUBR, SHAR, SIPR
N * @sa INTLEVEL, IR, IMR, SIR, SIMR : Interrupt.
N * @sa RTR, RCR : Data retransmission.
N * @sa PTIMER, PMAGIC, PHAR, PSID, PMRU : PPPoE.
N * @sa UIPR, UPORTR : ICMP message.
N * @sa PHYCFGR, VERSIONR : etc.
N */
N 
N  
N 
N/**
N * @defgroup Socket_register_group Socket register
N * @ingroup WIZCHIP_register
N *
N * @brief Socket register group.\n
N * Socket register configures and control SOCKETn which is necessary to data communication.
N * @details
N * @sa Sn_MR, Sn_CR, Sn_IR, Sn_IMR : SOCKETn Control
N * @sa Sn_SR, Sn_PORT, Sn_DHAR, Sn_DIPR, Sn_DPORT : SOCKETn Information
N * @sa Sn_MSSR, Sn_TOS, Sn_TTL, Sn_KPALVTR, Sn_FRAG : Internet protocol.
N * @sa Sn_RXBUF_SIZE, Sn_TXBUF_SIZE, Sn_TX_FSR, Sn_TX_RD, Sn_TX_WR, Sn_RX_RSR, Sn_RX_RD, Sn_RX_WR : Data communication
N */
N 
N 
N 
N /**
N * @defgroup Basic_IO_function Basic I/O function
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are basic input/output functions to read values from register or write values to register.
N */
N
N/**
N * @defgroup Common_register_access_function Common register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>common registers</b>.
N */
N
N/**
N * @defgroup Socket_register_access_function Socket register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>socket registers</b>.
N */
N 
N//------------------------------- defgroup end --------------------------------------------
N//----------------------------- W5500 Common Registers IOMAP -----------------------------
N/**
N * @ingroup Common_register_group
N * @brief Mode Register address(R/W)\n
N * @ref MR is used for S/W reset, ping block mode, PPPoE mode and etc.
N * @details Each bit of @ref MR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>RST</td> <td>Reserved</td> <td>WOL</td> <td>PB</td> <td>PPPoE</td> <td>Reserved</td> <td>FARP</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref MR_RST		 	: Reset
N * - \ref MR_WOL       		: Wake on LAN
N * - \ref MR_PB         	: Ping block
N * - \ref MR_PPPOE      	: PPPoE mode
N * - \ref MR_FARP			: Force ARP mode
N */
N#define MR                 (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Gateway IP Register address(R/W)
N * @details @ref GAR configures the default gateway address.
N */
N#define GAR                (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Subnet mask Register address(R/W)
N * @details @ref SUBR configures the subnet mask address.
N */
N#define SUBR               (_W5500_IO_BASE_ + (0x0005 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source MAC Register address(R/W)
N * @details @ref SHAR configures the source hardware address.
N */
N#define SHAR               (_W5500_IO_BASE_ + (0x0009 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source IP Register address(R/W)
N * @details @ref SIPR configures the source IP address.
N */
N#define SIPR               (_W5500_IO_BASE_ + (0x000F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Set Interrupt low level timer register address(R/W)
N * @details @ref INTLEVEL configures the Interrupt Assert Time.
N */
N#define INTLEVEL           (_W5500_IO_BASE_ + (0x0013 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt Register(R/W)
N * @details @ref IR indicates the interrupt status. Each bit of @ref IR will be still until the bit will be written to by the host.
N * If @ref IR is not equal to x00 INTn PIN is asserted to low until it is x00\n\n
N * Each bit of @ref IR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>CONFLICT</td> <td>UNREACH</td> <td>PPPoE</td> <td>MP</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IR_CONFLICT : IP conflict
N * - \ref IR_UNREACH  : Destination unreachable
N * - \ref IR_PPPoE	  : PPPoE connection close
N * - \ref IR_MP		  : Magic packet
N */
N#define IR                 (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt mask register(R/W)
N * @details @ref IMR is used to mask interrupts. Each bit of @ref IMR corresponds to each bit of @ref IR.
N * When a bit of @ref IMR is and the corresponding bit of @ref IR is  an interrupt will be issued. In other words,
N * if a bit of @ref IMR is  an interrupt will not be issued even if the corresponding bit of @ref IR is \n\n
N * Each bit of @ref IMR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>IM_IR7</td> <td>IM_IR6</td> <td>IM_IR5</td> <td>IM_IR4</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IM_IR7 : IP Conflict Interrupt Mask
N * - \ref IM_IR6 : Destination unreachable Interrupt Mask
N * - \ref IM_IR5 : PPPoE Close Interrupt Mask
N * - \ref IM_IR4 : Magic Packet Interrupt Mask
N */
N#define IMR                (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Register(R/W)
N * @details @ref SIR indicates the interrupt status of Socket.\n
N * Each bit of @ref SIR be still until @ref Sn_IR is cleared by the host.\n
N * If @ref Sn_IR is not equal to x00 the n-th bit of @ref SIR is and INTn PIN is asserted until @ref SIR is x00 */
N#define SIR                (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Mask Register(R/W)
N * @details Each bit of @ref SIMR corresponds to each bit of @ref SIR.
N * When a bit of @ref SIMR is and the corresponding bit of @ref SIR is  Interrupt will be issued.
N * In other words, if a bit of @ref SIMR is  an interrupt will be not issued even if the corresponding bit of @ref SIR is 
N */
N#define SIMR               (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Timeout register address( 1 is 100us )(R/W)
N * @details @ref RTR configures the retransmission timeout period. The unit of timeout period is 100us and the default of @ref RTR is x07D0or 000
N * And so the default timeout period is 200ms(100us X 2000). During the time configured by @ref RTR, W5500 waits for the peer response
N * to the packet that is transmitted by \ref Sn_CR (CONNECT, DISCON, CLOSE, SEND, SEND_MAC, SEND_KEEP command).
N * If the peer does not respond within the @ref RTR time, W5500 retransmits the packet or issues timeout.
N */
N#define RTR                (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Retry count register(R/W)
N * @details @ref RCR configures the number of time of retransmission.
N * When retransmission occurs as many as ref RCR+1 Timeout interrupt is issued (@ref Sn_IR[TIMEOUT] = .
N */
N#define RCR                (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Request Timer register  in PPPoE mode(R/W)
N * @details @ref PTIMER configures the time for sending LCP echo request. The unit of time is 25ms.
N */
N#define PTIMER             (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Magic number register  in PPPoE mode(R/W)
N * @details @ref PMAGIC configures the 4bytes magic number to be used in LCP negotiation.
N */
N#define PMAGIC             (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Destination MAC Register address(R/W)
N * @details @ref PHAR configures the PPPoE server hardware address that is acquired during PPPoE connection process.
N */
N#define PHAR                (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Session Identification Register(R/W)
N * @details @ref PSID configures the PPPoE sever session ID acquired during PPPoE connection process.
N */
N#define PSID               (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Maximum Segment Size(MSS) register(R/W)
N * @details @ref PMRU configures the maximum receive unit of PPPoE.
N */
N#define PMRU               (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable IP register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR indicates
N * the destination IP address & port number respectively.
N */
N#define UIPR               (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable Port register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR
N * indicates the destination IP address & port number respectively.
N */
N#define UPORTR              (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PHY Status Register(R/W)
N * @details @ref PHYCFGR configures PHY operation mode and resets PHY. In addition, @ref PHYCFGR indicates the status of PHY such as duplex, Speed, Link.
N */
N#define PHYCFGR            (_W5500_IO_BASE_ + (0x002E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0031 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0032 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0033 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0034 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0035 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0036 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0037 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0038 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief chip version register address(R)
N * @details @ref VERSIONR always indicates the W5500 version as @b 0x04.
N */
N#define VERSIONR           (_W5500_IO_BASE_ + (0x0039 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N
N//----------------------------- W5500 Socket Registers IOMAP -----------------------------
N/**
N * @ingroup Socket_register_group
N * @brief socket Mode register(R/W)
N * @details @ref Sn_MR configures the option or protocol type of Socket n.\n\n
N * Each bit of @ref Sn_MR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>MULTI/MFEN</td> <td>BCASTB</td> <td>ND/MC/MMB</td> <td>UCASTB/MIP6B</td> <td>Protocol[3]</td> <td>Protocol[2]</td> <td>Protocol[1]</td> <td>Protocol[0]</td> </tr>
N * </table>
N * - @ref Sn_MR_MULTI	: Support UDP Multicasting
N * - @ref Sn_MR_BCASTB	: Broadcast block <b>in UDP Multicasting</b>
N * - @ref Sn_MR_ND		: No Delayed Ack(TCP) flag
N * - @ref Sn_MR_MC   	: IGMP version used <b>in UDP mulitcasting</b>
N * - @ref Sn_MR_MMB    	: Multicast Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - @ref Sn_MR_UCASTB	: Unicast Block <b>in UDP Multicating</b>
N * - @ref Sn_MR_MIP6B   : IPv6 packet Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - <b>Protocol</b>
N * <table>
N * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>Closed</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>TCP</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>UDP</td>   </tr>
N * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
N * </table>
N *	- @ref Sn_MR_MACRAW	: MAC LAYER RAW SOCK \n
N *  - @ref Sn_MR_UDP		: UDP
N *  - @ref Sn_MR_TCP		: TCP
N *  - @ref Sn_MR_CLOSE	: Unused socket
N *  @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR(N)           (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket command register(R/W)
N * @details This is used to set the command for Socket n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
N * After W5500 accepts the command, the @ref Sn_CR register is automatically cleared to 0x00.
N * Even though @ref Sn_CR is cleared to 0x00, the command is still being processed.\n
N * To check whether the command is completed or not, please check the @ref Sn_IR or @ref Sn_SR.
N * - @ref Sn_CR_OPEN 		: Initialize or open socket.
N * - @ref Sn_CR_LISTEN 		: Wait connection request in TCP mode(<b>Server mode</b>)
N * - @ref Sn_CR_CONNECT 	: Send connection request in TCP mode(<b>Client mode</b>)
N * - @ref Sn_CR_DISCON 		: Send closing request in TCP mode.
N * - @ref Sn_CR_CLOSE   	: Close socket.
N * - @ref Sn_CR_SEND    	: Update TX buffer pointer and send data.
N * - @ref Sn_CR_SEND_MAC	: Send data with MAC address, so without ARP process.
N * - @ref Sn_CR_SEND_KEEP 	: Send keep alive message.
N * - @ref Sn_CR_RECV		: Update RX buffer pointer and receive data.
N */
N#define Sn_CR(N)           (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket interrupt register(R)
N * @details @ref Sn_IR indicates the status of Socket Interrupt such as establishment, termination, receiving data, timeout).\n
N * When an interrupt occurs and the corresponding bit of @ref Sn_IMR is  the corresponding bit of @ref Sn_IR becomes \n
N * In order to clear the @ref Sn_IR bit, the host should write the bit to \n
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>SEND_OK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
N * </table>
N * - \ref Sn_IR_SENDOK : <b>SEND_OK Interrupt</b>
N * - \ref Sn_IR_TIMEOUT : <b>TIMEOUT Interrupt</b>
N * - \ref Sn_IR_RECV : <b>RECV Interrupt</b>
N * - \ref Sn_IR_DISCON : <b>DISCON Interrupt</b>
N * - \ref Sn_IR_CON : <b>CON Interrupt</b>
N */
N#define Sn_IR(N)           (_W5500_IO_BASE_ + (0x0002 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket status register(R)
N * @details @ref Sn_SR indicates the status of Socket n.\n
N * The status of Socket n is changed by @ref Sn_CR or some special control packet as SYN, FIN packet in TCP.
N * @par Normal status
N * - @ref SOCK_CLOSED 		: Closed
N * - @ref SOCK_INIT   		: Initiate state
N * - @ref SOCK_LISTEN    	: Listen state
N * - @ref SOCK_ESTABLISHED 	: Success to connect
N * - @ref SOCK_CLOSE_WAIT   : Closing state
N * - @ref SOCK_UDP   		: UDP socket
N * - @ref SOCK_MACRAW  		: MAC raw mode socket
N *@par Temporary status during changing the status of Socket n.
N * - @ref SOCK_SYNSENT   	: This indicates Socket n sent the connect-request packet (SYN packet) to a peer.
N * - @ref SOCK_SYNRECV    	: It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.
N * - @ref SOCK_FIN_WAIT		: Connection state
N * - @ref SOCK_CLOSING		: Closing state
N * - @ref SOCK_TIME_WAIT	: Closing state
N * - @ref SOCK_LAST_ACK 	: Closing state
N */
N#define Sn_SR(N)           (_W5500_IO_BASE_ + (0x0003 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief source port register(R/W)
N * @details @ref Sn_PORT configures the source port number of Socket n.
N * It is valid when Socket n is used in TCP/UPD mode. It should be set before OPEN command is ordered.
N */
N#define Sn_PORT(N)         (_W5500_IO_BASE_ + (0x0004 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer MAC register address(R/W)
N * @details @ref Sn_DHAR configures the destination hardware address of Socket n when using SEND_MAC command in UDP mode or
N * it indicates that it is acquired in ARP-process by CONNECT/SEND command.
N */
N#define Sn_DHAR(N)         (_W5500_IO_BASE_ + (0x0006 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer IP register address(R/W)
N * @details @ref Sn_DIPR configures or indicates the destination IP address of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In TCP client mode, it configures an IP address of TCP serverbefore CONNECT command.
N * In TCP server mode, it indicates an IP address of TCP clientafter successfully establishing connection.
N * In UDP mode, it configures an IP address of peer to be received the UDP packet by SEND or SEND_MAC command.
N */
N#define Sn_DIPR(N)         (_W5500_IO_BASE_ + (0x000C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer port register address(R/W)
N * @details @ref Sn_DPORT configures or indicates the destination port number of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In TCP clientmode, it configures the listen port number of TCP serverbefore CONNECT command.
N * In TCP Servermode, it indicates the port number of TCP client after successfully establishing connection.
N * In UDP mode, it configures the port number of peer to be transmitted the UDP packet by SEND/SEND_MAC command.
N */
N#define Sn_DPORT(N)        (_W5500_IO_BASE_ + (0x0010 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Maximum Segment Size(Sn_MSSR0) register address(R/W)
N * @details @ref Sn_MSSR configures or indicates the MTU(Maximum Transfer Unit) of Socket n.
N */
N#define Sn_MSSR(N)         (_W5500_IO_BASE_ + (0x0012 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x0014 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief IP Type of Service(TOS) Register(R/W)
N * @details @ref Sn_TOS configures the TOS(Type Of Service field in IP Header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TOS(N)          (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N/**
N * @ingroup Socket_register_group
N * @brief IP Time to live(TTL) Register(R/W)
N * @details @ref Sn_TTL configures the TTL(Time To Live field in IP header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TTL(N)          (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3)) 
N// Reserved			         (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Receive memory size register(R/W)
N * @details @ref Sn_RXBUF_SIZE configures the RX buffer block size of Socket n.
N * Socket n RX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data cannot be normally received from a peer.
N * Although Socket n RX Buffer Block size is initially configured to 2Kbytes,
N * user can re-configure its size using @ref Sn_RXBUF_SIZE. The total sum of @ref Sn_RXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data reception error is occurred.
N */
N#define Sn_RXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory size register(R/W)
N * @details @ref Sn_TXBUF_SIZE configures the TX buffer block size of Socket n. Socket n TX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data cant be normally transmitted to a peer.
N * Although Socket n TX Buffer Block size is initially configured to 2Kbytes,
N * user can be re-configure its size using @ref Sn_TXBUF_SIZE. The total sum of @ref Sn_TXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data transmission error is occurred.
N */
N#define Sn_TXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit free memory size register(R)
N * @details @ref Sn_TX_FSR indicates the free size of Socket n TX Buffer Block. It is initialized to the configured size by @ref Sn_TXBUF_SIZE.
N * Data bigger than @ref Sn_TX_FSR should not be saved in the Socket n TX Buffer because the bigger data overwrites the previous saved data not yet sent.
N * Therefore, check before saving the data to the Socket n TX Buffer, and if data is equal or smaller than its checked size,
N * transmit the data with SEND/SEND_MAC command after saving the data in Socket n TX buffer. But, if data is bigger than its checked size,
N * transmit the data after dividing into the checked size and saving in the Socket n TX buffer.
N */
N#define Sn_TX_FSR(N)       (_W5500_IO_BASE_ + (0x0020 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory read pointer register address(R)
N * @details @ref Sn_TX_RD is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.
N * After its initialization, it is auto-increased by SEND command.
N * SEND command transmits the saved data from the current @ref Sn_TX_RD to the @ref Sn_TX_WR in the Socket n TX Buffer.
N * After transmitting the saved data, the SEND command increases the @ref Sn_TX_RD as same as the @ref Sn_TX_WR.
N * If its increment value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_TX_RD(N)        (_W5500_IO_BASE_ + (0x0022 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory write pointer register address(R/W)
N * @details @ref Sn_TX_WR is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.\n
N * It should be read or be updated like as follows.\n
N * 1. Read the starting address for saving the transmitting data.\n
N * 2. Save the transmitting data from the starting address of Socket n TX buffer.\n
N * 3. After saving the transmitting data, update @ref Sn_TX_WR to the increased value as many as transmitting data size.
N * If the increment value exceeds the maximum value 0xFFFF(greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.\n
N * 4. Transmit the saved data in Socket n TX Buffer by using SEND/SEND command
N */
N#define Sn_TX_WR(N)        (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Received data size register(R)
N * @details @ref Sn_RX_RSR indicates the data size received and saved in Socket n RX Buffer.
N * @ref Sn_RX_RSR does not exceed the @ref Sn_RXBUF_SIZE and is calculated as the difference between
N * Socket n RX Write Pointer (@ref Sn_RX_WR)and Socket n RX Read Pointer (@ref Sn_RX_RD)
N */
N#define Sn_RX_RSR(N)       (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Read point of Receive memory(R/W)
N * @details @ref Sn_RX_RD is initialized by OPEN command. Make sure to be read or updated as follows.\n
N * 1. Read the starting save address of the received data.\n
N * 2. Read data from the starting address of Socket n RX Buffer.\n
N * 3. After reading the received data, Update @ref Sn_RX_RD to the increased value as many as the reading size.
N * If the increment value exceeds the maximum value 0xFFFF, that is, is greater than 0x10000 and the carry bit occurs,
N * update with the lower 16bits value ignored the carry bit.\n
N * 4. Order RECV command is for notifying the updated @ref Sn_RX_RD to W5500.
N */
N#define Sn_RX_RD(N)        (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Write point of Receive memory(R)
N * @details @ref Sn_RX_WR is initialized by OPEN command and it is auto-increased by the data reception.
N * If the increased value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_RX_WR(N)        (_W5500_IO_BASE_ + (0x002A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief socket interrupt mask register(R)
N * @details @ref Sn_IMR masks the interrupt of Socket n.
N * Each bit corresponds to each bit of @ref Sn_IR. When a Socket n Interrupt is occurred and the corresponding bit of @ref Sn_IMR is 
N * the corresponding bit of @ref Sn_IR becomes  When both the corresponding bit of @ref Sn_IMR and @ref Sn_IR are and the n-th bit of @ref IR is 
N * Host is interrupted by asserted INTn PIN to low.
N */
N#define Sn_IMR(N)          (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Fragment field value in IP header register(R/W)
N * @details @ref Sn_FRAG configures the FRAG(Fragment field in IP header).
N */
N#define Sn_FRAG(N)         (_W5500_IO_BASE_ + (0x002D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Keep Alive Timer register(R/W)
N * @details @ref Sn_KPALVTR configures the transmitting timer of KEEP ALIVE(KA)packet of SOCKETn. It is valid only in TCP mode,
N * and ignored in other modes. The time unit is 5s.
N * KA packet is transmittable after @ref Sn_SR is changed to SOCK_ESTABLISHED and after the data is transmitted or received to/from a peer at least once.
N * In case of '@ref Sn_KPALVTR > 0', W5500 automatically transmits KA packet after time-period for checking the TCP connection (Auto-keepalive-process).
N * In case of '@ref Sn_KPALVTR = 0', Auto-keep-alive-process will not operate,
N * and KA packet can be transmitted by SEND_KEEP command by the host (Manual-keep-alive-process).
N * Manual-keep-alive-process is ignored in case of '@ref Sn_KPALVTR > 0'.
N */
N#define Sn_KPALVTR(N)      (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N//#define Sn_TSR(N)          (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N
N//----------------------------- W5500 Register values  -----------------------------
N
N/* MODE register values */
N/**
N * @brief Reset
N * @details If this bit is  All internal registers will be initialized. It will be automatically cleared as after S/W reset.
N */
N#define MR_RST                       0x80
N
N/**
N * @brief Wake on LAN
N * @details 0 : Disable WOL mode\n
N * 1 : Enable WOL mode\n
N * If WOL mode is enabled and the received magic packet over UDP has been normally processed, the Interrupt PIN (INTn) asserts to low.
N * When using WOL mode, the UDP Socket should be opened with any source port number. (Refer to Socket n Mode Register (@ref Sn_MR) for opening Socket.)
N * @note The magic packet over UDP supported by W5500 consists of 6 bytes synchronization stream (xFFFFFFFFFFFF and
N * 16 times Target MAC address stream in UDP payload. The options such like password are ignored. You can use any UDP source port number for WOL mode.
N */
N#define MR_WOL                       0x20
N
N/**
N * @brief Ping block
N * @details 0 : Disable Ping block\n
N * 1 : Enable Ping block\n
N * If the bit is  it blocks the response to a ping request.
N */
N#define MR_PB                        0x10
N
N/**
N * @brief Enable PPPoE
N * @details 0 : DisablePPPoE mode\n
N * 1 : EnablePPPoE mode\n
N * If you use ADSL, this bit should be 
N */
N#define MR_PPPOE                     0x08
N
N/**
N * @brief Enable UDP_FORCE_ARP CHECHK
N * @details 0 : Disable Force ARP mode\n
N * 1 : Enable Force ARP mode\n
N * In Force ARP mode, It forces on sending ARP Request whenever data is sent.
N */
N#define MR_FARP                      0x02
N
N/* IR register values */
N/**
N * @brief Check IP conflict.
N * @details Bit is set as when own source IP address is same with the sender IP address in the received ARP request.
N */
N#define IR_CONFLICT                  0x80
N
N/**
N * @brief Get the destination unreachable message in UDP sending.
N * @details When receiving the ICMP (Destination port unreachable) packet, this bit is set as 
N * When this bit is  Destination Information such as IP address and Port number may be checked with the corresponding @ref UIPR & @ref UPORTR.
N */
N#define IR_UNREACH                   0x40
N
N/**
N * @brief Get the PPPoE close message.
N * @details When PPPoE is disconnected during PPPoE mode, this bit is set.
N */
N#define IR_PPPoE                     0x20
N
N/**
N * @brief Get the magic packet interrupt.
N * @details When WOL mode is enabled and receives the magic packet over UDP, this bit is set.
N */
N#define IR_MP                        0x10
N
N
N/* PHYCFGR register value */
N#define PHYCFGR_RST                  ~(1<<7)  //< For PHY reset, must operate AND mask.
N#define PHYCFGR_OPMD                 (1<<6)   // Configre PHY with OPMDC value
N#define PHYCFGR_OPMDC_ALLA           (7<<3)
N#define PHYCFGR_OPMDC_PDOWN          (6<<3)
N#define PHYCFGR_OPMDC_NA             (5<<3)
N#define PHYCFGR_OPMDC_100FA          (4<<3)
N#define PHYCFGR_OPMDC_100F           (3<<3)
N#define PHYCFGR_OPMDC_100H           (2<<3)
N#define PHYCFGR_OPMDC_10F            (1<<3)
N#define PHYCFGR_OPMDC_10H            (0<<3)           
N#define PHYCFGR_DPX_FULL             (1<<2)
N#define PHYCFGR_DPX_HALF             (0<<2)
N#define PHYCFGR_SPD_100              (1<<1)
N#define PHYCFGR_SPD_10               (0<<1)
N#define PHYCFGR_LNK_ON               (1<<0)
N#define PHYCFGR_LNK_OFF              (0<<0)
N
N/* IMR register values */
N/**
N * @brief IP Conflict Interrupt Mask.
N * @details 0: Disable IP Conflict Interrupt\n
N * 1: Enable IP Conflict Interrupt
N */
N#define IM_IR7                  	 0x80
N
N/**
N * @brief Destination unreachable Interrupt Mask.
N * @details 0: Disable Destination unreachable Interrupt\n
N * 1: Enable Destination unreachable Interrupt
N */
N#define IM_IR6                  	 0x40
N
N/**
N * @brief PPPoE Close Interrupt Mask.
N * @details 0: Disable PPPoE Close Interrupt\n
N * 1: Enable PPPoE Close Interrupt
N */
N#define IM_IR5                  	 0x20
N
N/**
N * @brief Magic Packet Interrupt Mask.
N * @details 0: Disable Magic Packet Interrupt\n
N * 1: Enable Magic Packet Interrupt
N */
N#define IM_IR4                  	 0x10
N
N/* Sn_MR Default values */
N/**
N * @brief Support UDP Multicasting
N * @details 0 : disable Multicasting\n
N * 1 : enable Multicasting\n
N * This bit is applied only during UDP mode(P[3:0] = 010.\n
N * To use multicasting, @ref Sn_DIPR & @ref Sn_DPORT should be respectively configured with the multicast group IP address & port number
N * before Socket n is opened by OPEN command of @ref Sn_CR.
N */
N#define Sn_MR_MULTI                  0x80
N
N/**
N * @brief Broadcast block in UDP Multicasting.
N * @details 0 : disable Broadcast Blocking\n
N * 1 : enable Broadcast Blocking\n
N * This bit blocks to receive broadcasting packet during UDP mode(P[3:0] = 010.\m
N * In addition, This bit does when MACRAW mode(P[3:0] = 100
N */
N#define Sn_MR_BCASTB                 0x40
N
N/**
N * @brief No Delayed Ack(TCP), Multicast flag
N * @details 0 : Disable No Delayed ACK option\n
N * 1 : Enable No Delayed ACK option\n
N * This bit is applied only during TCP mode (P[3:0] = 001.\n
N * When this bit is  It sends the ACK packet without delay as soon as a Data packet is received from a peer.\n
N * When this bit is  It sends the ACK packet after waiting for the timeout time configured by @ref RTR.
N */
N#define Sn_MR_ND                     0x20
N
N/**
N * @brief Unicast Block in UDP Multicasting
N * @details 0 : disable Unicast Blocking\n
N * 1 : enable Unicast Blocking\n
N * This bit blocks receiving the unicast packet during UDP mode(P[3:0] = 010 and MULTI = 
N */
N#define Sn_MR_UCASTB                 0x10
N
N/**
N * @brief MAC LAYER RAW SOCK
N * @details This configures the protocol mode of Socket n.
N * @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR_MACRAW                 0x04
N
N//#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
N
N/**
N * @brief UDP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_UDP                    0x02
N
N/**
N * @brief TCP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_TCP                    0x01
N
N/**
N * @brief Unused socket
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_CLOSE                  0x00
N
N/* Sn_MR values used with Sn_MR_MACRAW */
N/**
N * @brief MAC filter enable in @ref Sn_MR_MACRAW mode
N * @details 0 : disable MAC Filtering\n
N * 1 : enable MAC Filtering\n
N * This bit is applied only during MACRAW mode(P[3:0] = 100.\n
N * When set as  W5500 can only receive broadcasting packet or packet sent to itself.
N * When this bit is  W5500 can receive all packets on Ethernet.
N * If user wants to implement Hybrid TCP/IP stack,
N * it is recommended that this bit is set as for reducing host overhead to process the all received packets.
N */
N#define Sn_MR_MFEN                   Sn_MR_MULTI
N
N/**
N * @brief Multicast Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : using IGMP version 2\n
N * 1 : using IGMP version 1\n
N * This bit is applied only during UDP mode(P[3:0] = 010 and MULTI = 
N * It configures the version for IGMP messages (Join/Leave/Report).
N */
N#define Sn_MR_MMB                    Sn_MR_ND
N
N/**
N * @brief IPv6 packet Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : disable IPv6 Blocking\n
N * 1 : enable IPv6 Blocking\n
N * This bit is applied only during MACRAW mode (P[3:0] = 100. It blocks to receiving the IPv6 packet.
N */
N#define Sn_MR_MIP6B                  Sn_MR_UCASTB
N
N/* Sn_MR value used with Sn_MR_UDP & Sn_MR_MULTI */
N/**
N * @brief IGMP version used in UDP mulitcasting
N * @details 0 : disable Multicast Blocking\n
N * 1 : enable Multicast Blocking\n
N * This bit is applied only when MACRAW mode(P[3:0] = 100. It blocks to receive the packet with multicast MAC address.
N */
N#define Sn_MR_MC                     Sn_MR_ND
N
N/* Sn_MR alternate values */
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_STREAM                  Sn_MR_TCP
N
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_DGRAM                   Sn_MR_UDP
N
N
N/* Sn_CR values */
N/**
N * @brief Initialize or open socket
N * @details Socket n is initialized and opened according to the protocol selected in Sn_MR(P3:P0).
N * The table below shows the value of @ref Sn_SR corresponding to @ref Sn_MR.\n
N * <table>
N *   <tr>  <td>\b Sn_MR (P[3:0])</td> <td>\b Sn_SR</td>            		 </tr>
N *   <tr>  <td>Sn_MR_CLOSE  (000</td> <td></td>         	   		 </tr>
N *   <tr>  <td>Sn_MR_TCP  (001</td> <td>SOCK_INIT (0x13)</td>  		 </tr>
N *   <tr>  <td>Sn_MR_UDP  (010</td>  <td>SOCK_UDP (0x22)</td>  		 </tr>
N *   <tr>  <td>S0_MR_MACRAW  (100</td>  <td>SOCK_MACRAW (0x02)</td>  </tr>
N * </table>
N */
N#define Sn_CR_OPEN                   0x01
N
N/**
N * @brief Wait connection request in TCP mode(Server mode)
N * @details This is valid only in TCP mode (Sn_MR(P3:P0) = Sn_MR_TCP).
N * In this mode, Socket n operates as a TCP serverand waits for  connection-request (SYN packet) from any TCP client
N * The @ref Sn_SR changes the state from SOCK_INIT to SOCKET_LISTEN.
N * When a TCP clientconnection request is successfully established,
N * the @ref Sn_SR changes from SOCK_LISTEN to SOCK_ESTABLISHED and the Sn_IR(0) becomes 
N * But when a TCP clientconnection request is failed, Sn_IR(3) becomes and the status of @ref Sn_SR changes to SOCK_CLOSED.
N */
N#define Sn_CR_LISTEN                 0x02
N
N/**
N * @brief Send connection request in TCP mode(Client mode)
N * @details  To connect, a connect-request (SYN packet) is sent to b>TCP server</b>configured by @ref Sn_DIPR & Sn_DPORT(destination address & port).
N * If the connect-request is successful, the @ref Sn_SR is changed to @ref SOCK_ESTABLISHED and the Sn_IR(0) becomes \n\n
N * The connect-request fails in the following three cases.\n
N * 1. When a @b ARPTO occurs (@ref Sn_IR[3] =  ) because destination hardware address is not acquired through the ARP-process.\n
N * 2. When a @b SYN/ACK packet is not received and @b TCPTO (Sn_IR(3) =  )\n
N * 3. When a @b RST packet is received instead of a @b SYN/ACK packet. In these cases, @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note This is valid only in TCP mode and operates when Socket n acts as b>TCP client</b>
N */
N#define Sn_CR_CONNECT                0x04
N
N/**
N * @brief Send closing request in TCP mode
N * @details Regardless of b>TCP server</b>or b>TCP client</b> the DISCON command processes the disconnect-process (b>Active close</b>or b>Passive close</b>.\n
N * @par Active close
N * it transmits disconnect-request(FIN packet) to the connected peer\n
N * @par Passive close
N * When FIN packet is received from peer, a FIN packet is replied back to the peer.\n
N * @details When the disconnect-process is successful (that is, FIN/ACK packet is received successfully), @ref Sn_SR is changed to @ref SOCK_CLOSED.\n
N * Otherwise, TCPTO occurs (Sn_IR(3)=)= and then @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_DISCON                 0x08
N
N/**
N * @brief Close socket
N * @details Sn_SR is changed to @ref SOCK_CLOSED.
N */
N#define Sn_CR_CLOSE                  0x10
N
N/**
N * @brief Update TX buffer pointer and send data
N * @details SEND transmits all the data in the Socket n TX buffer.\n
N * For more details, please refer to Socket n TX Free Size Register (@ref Sn_TX_FSR), Socket n,
N * TX Write Pointer Register(@ref Sn_TX_WR), and Socket n TX Read Pointer Register(@ref Sn_TX_RD).
N */
N#define Sn_CR_SEND                   0x20
N
N/**
N * @brief Send data with MAC address, so without ARP process
N * @details The basic operation is same as SEND.\n
N * Normally SEND transmits data after destination hardware address is acquired by the automatic ARP-process(Address Resolution Protocol).\n
N * But SEND_MAC transmits data without the automatic ARP-process.\n
N * In this case, the destination hardware address is acquired from @ref Sn_DHAR configured by host, instead of APR-process.
N * @note Valid only in UDP mode.
N */
N#define Sn_CR_SEND_MAC               0x21
N
N/**
N * @brief Send keep alive message
N * @details It checks the connection status by sending 1byte keep-alive packet.\n
N * If the peer can not respond to the keep-alive packet during timeout time, the connection is terminated and the timeout interrupt will occur.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_SEND_KEEP              0x22
N
N/**
N * @brief Update RX buffer pointer and receive data
N * @details RECV completes the processing of the received data in Socket n RX Buffer by using a RX read pointer register (@ref Sn_RX_RD).\n
N * For more details, refer to Socket n RX Received Size Register (@ref Sn_RX_RSR), Socket n RX Write Pointer Register (@ref Sn_RX_WR),
N * and Socket n RX Read Pointer Register (@ref Sn_RX_RD).
N */
N#define Sn_CR_RECV                   0x40
N
N/* Sn_IR values */
N/**
N * @brief SEND_OK Interrupt
N * @details This is issued when SEND command is completed.
N */
N#define Sn_IR_SENDOK                 0x10
N
N/**
N * @brief TIMEOUT Interrupt
N * @details This is issued when ARPTO or TCPTO occurs.
N */
N#define Sn_IR_TIMEOUT                0x08
N
N/**
N * @brief RECV Interrupt
N * @details This is issued whenever data is received from a peer.
N */
N#define Sn_IR_RECV                   0x04
N
N/**
N * @brief DISCON Interrupt
N * @details This is issued when FIN or FIN/ACK packet is received from a peer.
N */
N#define Sn_IR_DISCON                 0x02
N
N/**
N * @brief CON Interrupt
N * @details This is issued one time when the connection with peer is successful and then @ref Sn_SR is changed to @ref SOCK_ESTABLISHED.
N */
N#define Sn_IR_CON                    0x01
N
N/* Sn_SR values */
N/**
N * @brief Closed
N * @details This indicates that Socket n is released.\N
N * When DICON, CLOSE command is ordered, or when a timeout occurs, it is changed to @ref SOCK_CLOSED regardless of previous status.
N */
N#define SOCK_CLOSED                  0x00
N
N/**
N * @brief Initiate state
N * @details This indicates Socket n is opened with TCP mode.\N
N * It is changed to @ref SOCK_INIT when Sn_MR(P[3:0]) = 001and OPEN command is ordered.\N
N * After @ref SOCK_INIT, user can use LISTEN /CONNECT command.
N */
N#define SOCK_INIT                    0x13
N
N/**
N * @brief Listen state
N * @details This indicates Socket n is operating as b>TCP server</b>mode and waiting for connection-request (SYN packet) from a peer (b>TCP client</b>.\n
N * It will change to @ref SOCK_ESTALBLISHED when the connection-request is successfully accepted.\n
N * Otherwise it will change to @ref SOCK_CLOSED after TCPTO occurred (Sn_IR(TIMEOUT) = .
N */
N#define SOCK_LISTEN                  0x14
N
N/**
N * @brief Connection state
N * @details This indicates Socket n sent the connect-request packet (SYN packet) to a peer.\n
N * It is temporarily shown when @ref Sn_SR is changed from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by CONNECT command.\n
N * If connect-accept(SYN/ACK packet) is received from the peer at SOCK_SYNSENT, it changes to @ref SOCK_ESTABLISHED.\n
N * Otherwise, it changes to @ref SOCK_CLOSED after TCPTO (@ref Sn_IR[TIMEOUT] =  is occurred.
N */
N#define SOCK_SYNSENT                 0x15
N
N/**
N * @brief Connection state
N * @details It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.\n
N * If socket n sends the response (SYN/ACK  packet) to the peer successfully,  it changes to @ref SOCK_ESTABLISHED. \n
N * If not, it changes to @ref SOCK_CLOSED after timeout occurs (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_SYNRECV                 0x16
N
N/**
N * @brief Success to connect
N * @details This indicates the status of the connection of Socket n.\n
N * It changes to @ref SOCK_ESTABLISHED when the b>TCP SERVER</b>processed the SYN packet from the b>TCP CLIENT</b>during @ref SOCK_LISTEN, or
N * when the CONNECT command is successful.\n
N * During @ref SOCK_ESTABLISHED, DATA packet can be transferred using SEND or RECV command.
N */
N#define SOCK_ESTABLISHED             0x17
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_FIN_WAIT                0x18
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_CLOSING                 0x1A
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_TIME_WAIT               0x1B
N
N/**
N * @brief Closing state
N * @details This indicates Socket n received the disconnect-request (FIN packet) from the connected peer.\n
N * This is half-closing status, and data can be transferred.\n
N * For full-closing, DISCON command is used. But For just-closing, CLOSE command is used.
N */
N#define SOCK_CLOSE_WAIT              0x1C
N
N/**
N * @brief Closing state
N * @details This indicates Socket n is waiting for the response (FIN/ACK packet) to the disconnect-request (FIN packet) by passive-close.\n
N * It changes to @ref SOCK_CLOSED when Socket n received the response successfully, or when timeout occurs  (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_LAST_ACK                0x1D
N
N/**
N * @brief UDP socket
N * @details This indicates Socket n is opened in UDP mode(Sn_MR(P[3:0]) = 010.\n
N * It changes to SOCK_UPD when Sn_MR(P[3:0]) = 010 and OPEN command is ordered.\n
N * Unlike TCP mode, data can be transfered without the connection-process.
N */
N#define SOCK_UDP                     0x22
N
N//#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
N
N/**
N * @brief MAC raw mode socket
N * @details This indicates Socket 0 is opened in MACRAW mode (S0_MR(P[3:0]) = 100and is valid only in Socket 0.\n
N * It changes to SOCK_MACRAW when S0_MR(P[3:0] = 100and OPEN command is ordered.\n
N * Like UDP mode socket, MACRAW mode Socket 0 can transfer a MAC packet (Ethernet frame) without the connection-process.
N */
N#define SOCK_MACRAW                  0x42
N
N//#define SOCK_PPPOE                   0x5F
N
N/* IP PROTOCOL */
N#define IPPROTO_IP                   0        //< Dummy for IP 
N#define IPPROTO_ICMP                 1        //< Control message protocol
N#define IPPROTO_IGMP                 2        //< Internet group management protocol
N#define IPPROTO_GGP                  3        //< Gateway^2 (deprecated)
N#define IPPROTO_TCP                  6        //< TCP
N#define IPPROTO_PUP                  12       //< PUP
N#define IPPROTO_UDP                  17       //< UDP
N#define IPPROTO_IDP                  22       //< XNS idp
N#define IPPROTO_ND                   77       //< UNOFFICIAL net disk protocol
N#define IPPROTO_RAW                  255      //< Raw IP packet
N
N
N/**
N * @brief Enter a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n \n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt.\n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * \sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * \sa WIZCHIP_CRITICAL_EXIT()
N */
N#define WIZCHIP_CRITICAL_ENTER()    WIZCHIP.CRIS._enter()
N
N/**
N * @brief Exit a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n\n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt. \n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_ENTER()
N */
N#define WIZCHIP_CRITICAL_EXIT()     WIZCHIP.CRIS._exit()
N
N
N
N////////////////////////
N// Basic I/O Function //
N////////////////////////
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads 1 byte value from a register.
N * @param AddrSel Register address
N * @return The value of register
N */
Nuint8_t  WIZCHIP_READ (uint32_t AddrSel);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes 1 byte value to a register.
N * @param AddrSel Register address
N * @param wb Write data
N * @return void
N */
Nvoid     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads sequence data from registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to read data
N * @param len Data length
N */
Nvoid     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes sequence data to registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to write data
N * @param len Data length
N */
Nvoid     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/////////////////////////////////
N// Common Register I/O function //
N/////////////////////////////////
N/**
N * @ingroup Common_register_access_function
N * @brief Set Mode Register
N * @param (uint8_t)mr The value to be set.
N * @sa getMR()
N */
N#define setMR(mr) \
N	WIZCHIP_WRITE(MR,mr)
X#define setMR(mr) 	WIZCHIP_WRITE(MR,mr)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get Mode Register
N * @return uint8_t. The value of Mode register.
N * @sa setMR()
N */
N#define getMR() \
N		WIZCHIP_READ(MR)
X#define getMR() 		WIZCHIP_READ(MR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set gateway IP address
N * @param (uint8_t*)gar Pointer variable to set gateway IP address. It should be allocated 4 bytes.
N * @sa getGAR()
N */
N#define setGAR(gar) \
N		WIZCHIP_WRITE_BUF(GAR,gar,4)
X#define setGAR(gar) 		WIZCHIP_WRITE_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get gateway IP address
N * @param (uint8_t*)gar Pointer variable to get gateway IP address. It should be allocated 4 bytes.
N * @sa setGAR()
N */
N#define getGAR(gar) \
N		WIZCHIP_READ_BUF(GAR,gar,4)
X#define getGAR(gar) 		WIZCHIP_READ_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set subnet mask address
N * @param (uint8_t*)subr Pointer variable to set subnet mask address. It should be allocated 4 bytes.
N * @sa getSUBR()
N */
N#define setSUBR(subr) \
N		WIZCHIP_WRITE_BUF(SUBR, subr,4)
X#define setSUBR(subr) 		WIZCHIP_WRITE_BUF(SUBR, subr,4)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get subnet mask address
N * @param (uint8_t*)subr Pointer variable to get subnet mask address. It should be allocated 4 bytes.
N * @sa setSUBR()
N */
N#define getSUBR(subr) \
N		WIZCHIP_READ_BUF(SUBR, subr, 4)
X#define getSUBR(subr) 		WIZCHIP_READ_BUF(SUBR, subr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local MAC address
N * @param (uint8_t*)shar Pointer variable to set local MAC address. It should be allocated 6 bytes.
N * @sa getSHAR()
N */
N#define setSHAR(shar) \
N		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
X#define setSHAR(shar) 		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local MAC address
N * @param (uint8_t*)shar Pointer variable to get local MAC address. It should be allocated 6 bytes.
N * @sa setSHAR()
N */
N#define getSHAR(shar) \
N		WIZCHIP_READ_BUF(SHAR, shar, 6)
X#define getSHAR(shar) 		WIZCHIP_READ_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local IP address
N * @param (uint8_t*)sipr Pointer variable to set local IP address. It should be allocated 4 bytes.
N * @sa getSIPR()
N */
N#define setSIPR(sipr) \
N		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
X#define setSIPR(sipr) 		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)sipr Pointer variable to get local IP address. It should be allocated 4 bytes.
N * @sa setSIPR()
N */
N#define getSIPR(sipr) \
N		WIZCHIP_READ_BUF(SIPR, sipr, 4)
X#define getSIPR(sipr) 		WIZCHIP_READ_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set INTLEVEL register
N * @param (uint16_t)intlevel Value to set @ref INTLEVEL register.
N * @sa getINTLEVEL()
N */
N#define setINTLEVEL(intlevel)  {\
N		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); \
N	}
X#define setINTLEVEL(intlevel)  {		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); 	}
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get INTLEVEL register
N * @return uint16_t. Value of @ref INTLEVEL register.
N * @sa setINTLEVEL()
N */
N#define getINTLEVEL() \
N		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
X#define getINTLEVEL() 		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IR register
N * @param (uint8_t)ir Value to set @ref IR register.
N * @sa getIR()
N */
N#define setIR(ir) \
N		WIZCHIP_WRITE(IR, (ir & 0xF0))
X#define setIR(ir) 		WIZCHIP_WRITE(IR, (ir & 0xF0))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IR register
N * @return uint8_t. Value of @ref IR register.
N * @sa setIR()
N */
N#define getIR() \
N		(WIZCHIP_READ(IR) & 0xF0)
X#define getIR() 		(WIZCHIP_READ(IR) & 0xF0)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IMR register
N * @param (uint8_t)imr Value to set @ref IMR register.
N * @sa getIMR()
N */
N#define setIMR(imr) \
N		WIZCHIP_WRITE(IMR, imr)
X#define setIMR(imr) 		WIZCHIP_WRITE(IMR, imr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IMR register
N * @return uint8_t. Value of @ref IMR register.
N * @sa setIMR()
N */
N#define getIMR() \
N		WIZCHIP_READ(IMR)
X#define getIMR() 		WIZCHIP_READ(IMR)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIR register
N * @param (uint8_t)sir Value to set @ref SIR register.
N * @sa getSIR()
N */
N#define setSIR(sir) \
N		WIZCHIP_WRITE(SIR, sir)
X#define setSIR(sir) 		WIZCHIP_WRITE(SIR, sir)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIR register
N * @return uint8_t. Value of @ref SIR register.
N * @sa setSIR()
N */
N#define getSIR() \
N		WIZCHIP_READ(SIR)
X#define getSIR() 		WIZCHIP_READ(SIR)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIMR register
N * @param (uint8_t)simr Value to set @ref SIMR register.
N * @sa getSIMR()
N */
N#define setSIMR(simr) \
N		WIZCHIP_WRITE(SIMR, simr)
X#define setSIMR(simr) 		WIZCHIP_WRITE(SIMR, simr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIMR register
N * @return uint8_t. Value of @ref SIMR register.
N * @sa setSIMR()
N */
N#define getSIMR() \
N		WIZCHIP_READ(SIMR)
X#define getSIMR() 		WIZCHIP_READ(SIMR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RTR register
N * @param (uint16_t)rtr Value to set @ref RTR register.
N * @sa getRTR()
N */
N#define setRTR(rtr)   {\
N		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); \
N	}
X#define setRTR(rtr)   {		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RTR register
N * @return uint16_t. Value of @ref RTR register.
N * @sa setRTR()
N */
N#define getRTR() \
N		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
X#define getRTR() 		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RCR register
N * @param (uint8_t)rcr Value to set @ref RCR register.
N * @sa getRCR()
N */
N#define setRCR(rcr) \
N		WIZCHIP_WRITE(RCR, rcr)
X#define setRCR(rcr) 		WIZCHIP_WRITE(RCR, rcr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RCR register
N * @return uint8_t. Value of @ref RCR register.
N * @sa setRCR()
N */
N#define getRCR() \
N		WIZCHIP_READ(RCR)
X#define getRCR() 		WIZCHIP_READ(RCR)
N
N//================================================== test done ===========================================================
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PTIMER register
N * @param (uint8_t)ptimer Value to set @ref PTIMER register.
N * @sa getPTIMER()
N */
N#define setPTIMER(ptimer) \
N		WIZCHIP_WRITE(PTIMER, ptimer)
X#define setPTIMER(ptimer) 		WIZCHIP_WRITE(PTIMER, ptimer)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PTIMER register
N * @return uint8_t. Value of @ref PTIMER register.
N * @sa setPTIMER()
N */
N#define getPTIMER() \
N		WIZCHIP_READ(PTIMER)
X#define getPTIMER() 		WIZCHIP_READ(PTIMER)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMAGIC register
N * @param (uint8_t)pmagic Value to set @ref PMAGIC register.
N * @sa getPMAGIC()
N */
N#define setPMAGIC(pmagic) \
N		WIZCHIP_WRITE(PMAGIC, pmagic)
X#define setPMAGIC(pmagic) 		WIZCHIP_WRITE(PMAGIC, pmagic)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMAGIC register
N * @return uint8_t. Value of @ref PMAGIC register.
N * @sa setPMAGIC()
N */
N#define getPMAGIC() \
N		WIZCHIP_READ(PMAGIC)
X#define getPMAGIC() 		WIZCHIP_READ(PMAGIC)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set PHAR address
N * @param (uint8_t*)phar Pointer variable to set PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa getPHAR()
N */
N#define setPHAR(phar) \
N		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
X#define setPHAR(phar) 		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)phar Pointer variable to PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa setPHAR()
N */
N#define getPHAR(phar) \
N		WIZCHIP_READ_BUF(PHAR, phar, 6)
X#define getPHAR(phar) 		WIZCHIP_READ_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PSID register
N * @param (uint16_t)psid Value to set @ref PSID register.
N * @sa getPSID()
N */
N#define setPSID(psid)  {\
N		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); \
N	}
X#define setPSID(psid)  {		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PSID register
N * @return uint16_t. Value of @ref PSID register.
N * @sa setPSID()
N */
N//uint16_t getPSID(void);
N#define getPSID() \
N		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
X#define getPSID() 		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMRU register
N * @param (uint16_t)pmru Value to set @ref PMRU register.
N * @sa getPMRU()
N */
N#define setPMRU(pmru) { \
N		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); \
N	}
X#define setPMRU(pmru) { 		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMRU register
N * @return uint16_t. Value of @ref PMRU register.
N * @sa setPMRU()
N */
N#define getPMRU() \
N		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
X#define getPMRU() 		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get unreachable IP address
N * @param (uint8_t*)uipr Pointer variable to get unreachable IP address. It should be allocated 4 bytes.
N */
N#define getUIPR(uipr) \
N		WIZCHIP_READ_BUF(UIPR,uipr,6)
X#define getUIPR(uipr) 		WIZCHIP_READ_BUF(UIPR,uipr,6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref UPORTR register
N * @return uint16_t. Value of @ref UPORTR register.
N */
N#define getUPORTR() \
N	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
X#define getUPORTR() 	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PHYCFGR register
N * @param (uint8_t)phycfgr Value to set @ref PHYCFGR register.
N * @sa getPHYCFGR()
N */
N#define setPHYCFGR(phycfgr) \
N		WIZCHIP_WRITE(PHYCFGR, phycfgr)
X#define setPHYCFGR(phycfgr) 		WIZCHIP_WRITE(PHYCFGR, phycfgr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PHYCFGR register
N * @return uint8_t. Value of @ref PHYCFGR register.
N * @sa setPHYCFGR()
N */
N#define getPHYCFGR() \
N		WIZCHIP_READ(PHYCFGR)
X#define getPHYCFGR() 		WIZCHIP_READ(PHYCFGR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref VERSIONR register
N * @return uint8_t. Value of @ref VERSIONR register.
N */
N#define getVERSIONR() \
N		WIZCHIP_READ(VERSIONR)
X#define getVERSIONR() 		WIZCHIP_READ(VERSIONR)
N
N/////////////////////////////////////
N
N///////////////////////////////////
N// Socket N register I/O function //
N///////////////////////////////////
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)mr Value to set @ref Sn_MR
N * @sa getSn_MR()
N */
N#define setSn_MR(sn, mr) \
N		WIZCHIP_WRITE(Sn_MR(sn),mr)
X#define setSn_MR(sn, mr) 		WIZCHIP_WRITE(Sn_MR(sn),mr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_MR.
N * @sa setSn_MR()
N */
N#define getSn_MR(sn) \
N	WIZCHIP_READ(Sn_MR(sn))
X#define getSn_MR(sn) 	WIZCHIP_READ(Sn_MR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)cr Value to set @ref Sn_CR
N * @sa getSn_CR()
N */
N#define setSn_CR(sn, cr) \
N		WIZCHIP_WRITE(Sn_CR(sn), cr)
X#define setSn_CR(sn, cr) 		WIZCHIP_WRITE(Sn_CR(sn), cr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_CR.
N * @sa setSn_CR()
N */
N#define getSn_CR(sn) \
N		WIZCHIP_READ(Sn_CR(sn))
X#define getSn_CR(sn) 		WIZCHIP_READ(Sn_CR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ir Value to set @ref Sn_IR
N * @sa getSn_IR()
N */
N#define setSn_IR(sn, ir) \
N		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
X#define setSn_IR(sn, ir) 		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IR.
N * @sa setSn_IR()
N */
N#define getSn_IR(sn) \
N		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
X#define getSn_IR(sn) 		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)imr Value to set @ref Sn_IMR
N * @sa getSn_IMR()
N */
N#define setSn_IMR(sn, imr) \
N		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
X#define setSn_IMR(sn, imr) 		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IMR.
N * @sa setSn_IMR()
N */
N#define getSn_IMR(sn) \
N		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
X#define getSn_IMR(sn) 		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_SR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_SR.
N */
N#define getSn_SR(sn) \
N		WIZCHIP_READ(Sn_SR(sn))
X#define getSn_SR(sn) 		WIZCHIP_READ(Sn_SR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)port Value to set @ref Sn_PORT.
N * @sa getSn_PORT()
N */
N#define setSn_PORT(sn, port)  { \
N		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); \
N	}
X#define setSn_PORT(sn, port)  { 		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_PORT.
N * @sa setSn_PORT()
N */
N#define getSn_PORT(sn) \
N		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
X#define getSn_PORT(sn) 		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DHAR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to set socket n destination hardware address. It should be allocated 6 bytes.
N * @sa getSn_DHAR()
N */
N#define setSn_DHAR(sn, dhar) \
N		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
X#define setSn_DHAR(sn, dhar) 		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to get socket n destination hardware address. It should be allocated 6 bytes.
N * @sa setSn_DHAR()
N */
N#define getSn_DHAR(sn, dhar) \
N		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
X#define getSn_DHAR(sn, dhar) 		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to set socket n destination IP address. It should be allocated 4 bytes.
N * @sa getSn_DIPR()
N */
N#define setSn_DIPR(sn, dipr) \
N		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
X#define setSn_DIPR(sn, dipr) 		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to get socket n destination IP address. It should be allocated 4 bytes.
N * @sa SetSn_DIPR()
N */
N#define getSn_DIPR(sn, dipr) \
N		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
X#define getSn_DIPR(sn, dipr) 		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)dport Value to set @ref Sn_DPORT
N * @sa getSn_DPORT()
N */
N#define setSn_DPORT(sn, dport) { \
N		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); \
N	}
X#define setSn_DPORT(sn, dport) { 		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_DPORT.
N * @sa setSn_DPORT()
N */
N#define getSn_DPORT(sn) \
N		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
X#define getSn_DPORT(sn) 		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)mss Value to set @ref Sn_MSSR
N * @sa setSn_MSSR()
N */
N#define setSn_MSSR(sn, mss) { \
N		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); \
N	}
X#define setSn_MSSR(sn, mss) { 		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_MSSR.
N * @sa setSn_MSSR()
N */
N#define getSn_MSSR(sn) \
N		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
X#define getSn_MSSR(sn) 		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)tos Value to set @ref Sn_TOS
N * @sa getSn_TOS()
N */
N#define setSn_TOS(sn, tos) \
N		WIZCHIP_WRITE(Sn_TOS(sn), tos)
X#define setSn_TOS(sn, tos) 		WIZCHIP_WRITE(Sn_TOS(sn), tos)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of Sn_TOS.
N * @sa setSn_TOS()
N */
N#define getSn_TOS(sn) \
N		WIZCHIP_READ(Sn_TOS(sn))
X#define getSn_TOS(sn) 		WIZCHIP_READ(Sn_TOS(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ttl Value to set @ref Sn_TTL
N * @sa getSn_TTL()
N */
N#define setSn_TTL(sn, ttl) \
N		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
X#define setSn_TTL(sn, ttl) 		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TTL.
N * @sa setSn_TTL()
N */
N#define getSn_TTL(sn) \
N		WIZCHIP_READ(Sn_TTL(sn))
X#define getSn_TTL(sn) 		WIZCHIP_READ(Sn_TTL(sn))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)rxbufsize Value to set @ref Sn_RXBUF_SIZE
N * @sa getSn_RXBUF_SIZE()
N */
N#define setSn_RXBUF_SIZE(sn, rxbufsize) \
N		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
X#define setSn_RXBUF_SIZE(sn, rxbufsize) 		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_RXBUF_SIZE.
N * @sa setSn_RXBUF_SIZE()
N */
N#define getSn_RXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
X#define getSn_RXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)txbufsize Value to set @ref Sn_TXBUF_SIZE
N * @sa getSn_TXBUF_SIZE()
N */
N#define setSn_TXBUF_SIZE(sn, txbufsize) \
N		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
X#define setSn_TXBUF_SIZE(sn, txbufsize) 		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TXBUF_SIZE.
N * @sa setSn_TXBUF_SIZE()
N */
N#define getSn_TXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
X#define getSn_TXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_FSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_FSR.
N */
Nuint16_t getSn_TX_FSR(uint8_t sn);
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_RD.
N */
N#define getSn_TX_RD(sn) \
N		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
X#define getSn_TX_RD(sn) 		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)txwr Value to set @ref Sn_TX_WR
N * @sa GetSn_TX_WR()
N */
N#define setSn_TX_WR(sn, txwr) { \
N		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); \
N		}
X#define setSn_TX_WR(sn, txwr) { 		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); 		}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_WR.
N * @sa setSn_TX_WR()
N */
N#define getSn_TX_WR(sn) \
N		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
X#define getSn_TX_WR(sn) 		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_RSR.
N */
Nuint16_t getSn_RX_RSR(uint8_t sn);
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)rxrd Value to set @ref Sn_RX_RD
N * @sa getSn_RX_RD()
N */
N#define setSn_RX_RD(sn, rxrd) { \
N		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); \
N	}
X#define setSn_RX_RD(sn, rxrd) { 		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @regurn uint16_t. Value of @ref Sn_RX_RD.
N * @sa setSn_RX_RD()
N */
N#define getSn_RX_RD(sn) \
N		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
X#define getSn_RX_RD(sn) 		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_WR.
N */
N#define getSn_RX_WR(sn) \
N		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
X#define getSn_RX_WR(sn) 		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)frag Value to set @ref Sn_FRAG
N * @sa getSn_FRAD()
N */
N#define setSn_FRAG(sn, frag) { \
N		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); \
N	}
X#define setSn_FRAG(sn, frag) { 		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_FRAG.
N * @sa setSn_FRAG()
N */
N#define getSn_FRAG(sn) \
N		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
X#define getSn_FRAG(sn) 		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)kpalvt Value to set @ref Sn_KPALVTR
N * @sa getSn_KPALVTR()
N */
N#define setSn_KPALVTR(sn, kpalvt) \
N		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
X#define setSn_KPALVTR(sn, kpalvt) 		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_KPALVTR.
N * @sa setSn_KPALVTR()
N */
N#define getSn_KPALVTR(sn) \
N		WIZCHIP_READ(Sn_KPALVTR(sn))
X#define getSn_KPALVTR(sn) 		WIZCHIP_READ(Sn_KPALVTR(sn))
N
N//////////////////////////////////////
N
N/////////////////////////////////////
N// Sn_TXBUF & Sn_RXBUF IO function //
N/////////////////////////////////////
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameter.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n RX max buffer size.
N */
N#define getSn_RxMAX(sn) \
N		(getSn_RXBUF_SIZE(sn) << 10)
X#define getSn_RxMAX(sn) 		(getSn_RXBUF_SIZE(sn) << 10)
N
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameters.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n TX max buffer size.
N */
N//uint16_t getSn_TxMAX(uint8_t sn);
N#define getSn_TxMAX(sn) \
N		(getSn_TXBUF_SIZE(sn) << 10)
X#define getSn_TxMAX(sn) 		(getSn_TXBUF_SIZE(sn) << 10)
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to internal TX memory
N *
N * @details This function reads the Tx write pointer register and after that,
N * it copies the <i>wizdata(pointer buffer)</i> of the length of <i>len(variable)</i> bytes to internal TX memory
N * and updates the Tx write pointer register.
N * This function is being called by send() and sendto() function also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to write data
N * @param len Data length
N * @sa wiz_recv_data()
N */
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to your buffer from internal RX memory
N *
N * @details This function read the Rx read pointer register and after that,
N * it copies the received data from internal RX memory
N * to <i>wizdata(pointer variable)</i> of the length of <i>len(variable)</i> bytes.
N * This function is being called by recv() also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to read data
N * @param len Data length
N * @sa wiz_send_data()
N */
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It discard the received data in RX memory.
N * @details It discards the data of the length of <i>len(variable)</i> bytes in internal RX memory.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param len Data length
N */
Nvoid wiz_recv_ignore(uint8_t sn, uint16_t len);
N
N#endif   // _W5500_H_
L 115 "..\..\Ethernet\wizchip_conf.h" 2
N#else 
S   #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
N#endif
N
N#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
N#endif
N
N/**
N * @brief Define I/O base address when BUS IF mode.
N * @todo Should re-define it to fit your system when BUS IF Mode (@ref \_WIZCHIP_IO_MODE_BUS_,
N *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
N *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
N */
N#define _WIZCHIP_IO_BASE_              0x00000000  // 
N
N#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
X#if (0x0200 + 1) & _WIZCHIP_IO_MODE_BUS
S   #ifndef _WIZCHIP_IO_BASE_
S      #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
S   #endif
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   #define _WIZCHIP_SOCK_NUM_   8   ///< The count of independant socket of @b WIZCHIP
N#else
S   #define _WIZCHIP_SOCK_NUM_   4   ///< The count of independant socket of @b WIZCHIP
N#endif      
N
N
N/********************************************************
N* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
N*********************************************************/
N/**
N * @ingroup DATA_TYPE
N * @brief The set of callback functions for W5500:@ref WIZCHIP_IO_Functions W5200:@ref WIZCHIP_IO_Functions_W5200
N */
Ntypedef struct __WIZCHIP
N{
N   uint16_t  if_mode;               ///< host interface mode
N   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
N   /**
N    * The set of critical section callback func.
N    */
N   struct _CRIS
N   {
N      void (*_enter)  (void);       ///< crtical section enter 
N      void (*_exit) (void);         ///< critial section exit  
N   }CRIS;  
N   /**
N    *  The set of @ref\_WIZCHIP_ select control callback func.
N    */
N   struct _CS
N   {
N      void (*_select)  (void);      ///< @ref \_WIZCHIP_ selected
N      void (*_deselect)(void);      ///< @ref \_WIZCHIP_ deselected
N   }CS;  
N   /**
N    * The set of interface IO callback func.
N    */
N   union _IF
N   {	 
N      /**
N       * For BUS interface IO
N       */  
N      struct
N      {
N         uint8_t  (*_read_byte)  (uint32_t AddrSel);
N         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
N      }BUS;      
N      /**
N       * For SPI interface IO
N       */
N      struct
N      {
N         uint8_t (*_read_byte)   (void);
N         void    (*_write_byte)  (uint8_t wb);
N      }SPI;
N      // To be added
N      //
N   }IF;
N}_WIZCHIP;
N
Nextern _WIZCHIP  WIZCHIP;
N
N/**
N * @ingroup DATA_TYPE
N *  WIZCHIP control type enumration used in @ref ctlwizchip().
N */
Ntypedef enum
N{
N   CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
N   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
N   CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
N   CW_CLR_INTERRUPT,   ///< Clears interrupt
N   CW_SET_INTRMASK,    ///< Masks interrupt
N   CW_GET_INTRMASK,    ///< Get interrupt mask
N   CW_SET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_ID,          ///< Gets WIZCHIP name.
N
N#if _WIZCHIP_ ==  5500
X#if 5500 ==  5500
N   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
N   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
N   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
N   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
N   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
N#endif
N   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
N   CW_GET_PHYLINK      ///< Get PHY Link status
N}ctlwizchip_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Network control type enumration used in @ref ctlnetwork().
N */
Ntypedef enum
N{
N   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
N   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
N   CN_SET_NETMODE,  ///< Set network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_GET_NETMODE,  ///< Get network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_SET_TIMEOUT,  ///< Set network timeout as retry count and time.
N   CN_GET_TIMEOUT,  ///< Get network timeout as retry count and time.
N}ctlnetwork_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Interrupt kind when CW_SET_INTRRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK
N *  and CW_GET_INTRMASK is used in @ref ctlnetwork().
N *  It can be used with OR operation.
N */
Ntypedef enum
N{
N#if _WIZCHIP_ > 5200
X#if 5500 > 5200
N   IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
N#endif   
N
N   IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
N
N#if _WIZCHIP_ != 5200
X#if 5500 != 5200
N   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
N#endif   
N
N   IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
N
N   IK_SOCK_0            = (1 << 8),   ///< Socket 0 interrupt
N   IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
N   IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
N   IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
N#if _WIZCHIP_ > 5100   
X#if 5500 > 5100   
N   IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
N   IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
N   IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
N   IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
N#else
S   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
N#endif      
N}intr_kind;
N
N#define PHY_CONFBY_HW            0     ///< Configured PHY operation mode by HW pin
N#define PHY_CONFBY_SW            1     ///< Configured PHY operation mode by SW register   
N#define PHY_MODE_MANUAL          0     ///< Configured PHY operation mode with user setting.
N#define PHY_MODE_AUTONEGO        1     ///< Configured PHY operation mode with auto-negotiation
N#define PHY_SPEED_10             0     ///< Link Speed 10
N#define PHY_SPEED_100            1     ///< Link Speed 100
N#define PHY_DUPLEX_HALF          0     ///< Link Half-Duplex
N#define PHY_DUPLEX_FULL          1     ///< Link Full-Duplex
N#define PHY_LINK_OFF             0     ///< Link Off
N#define PHY_LINK_ON              1     ///< Link On
N#define PHY_POWER_NORM           0     ///< PHY power normal mode
N#define PHY_POWER_DOWN           1     ///< PHY power down mode 
N
N
N#if _WIZCHIP_ == 5500 
X#if 5500 == 5500 
N/**
N * @ingroup DATA_TYPE
N *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
N *  and it indicates the real PHY status configured by HW or SW in all WIZCHIP. \n
N *  Valid only in W5500.
N */
Ntypedef struct wiz_PhyConf_t
N{
N      uint8_t by;       ///< set by @ref PHY_CONFBY_HW or @ref PHY_CONFBY_SW
N      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL or @ref PHY_MODE_AUTONEGO
N      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
N      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
N      //uint8_t power;  ///< set by @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N      //uint8_t link;   ///< Valid only in CW_GET_PHYSTATUS. set by @ref PHY_LINK_ON or PHY_DUPLEX_OFF 
N   }wiz_PhyConf;
N#endif   
N
N/**
N * @ingroup DATA_TYPE
N *  It used in setting dhcp_mode of @ref wiz_NetInfo.
N */
Ntypedef enum
N{
N   NETINFO_STATIC = 1,    ///< Static IP configuration by manually.
N   NETINFO_DHCP           ///< Dynamic IP configruation from a DHCP sever
N}dhcp_mode;
N
N/**
N * @ingroup DATA_TYPE
N *  Network Information for WIZCHIP
N */
Ntypedef struct wiz_NetInfo_t
N{
N   uint8_t mac[6];  ///< Source Mac Address
N   uint8_t ip[4];   ///< Source IP Address
N   uint8_t sn[4];   ///< Subnet Mask 
N   uint8_t gw[4];   ///< Gateway IP Address
N   uint8_t dns[4];  ///< DNS server IP Address
N   dhcp_mode dhcp;  ///< 1 - Static, 2 - DHCP
N}wiz_NetInfo;
N
N/**
N * @ingroup DATA_TYPE
N *  Network mode
N */
Ntypedef enum
N{
N#if _WIZCHIP_ == 5500   
X#if 5500 == 5500   
N   NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
N#endif   
N   NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
N   NM_PINGBLOCK   = (1<<4),  ///< Block ping-request
N   NM_PPPOE       = (1<<3),  ///< PPPoE mode
N}netmode_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Used in CN_SET_TIMEOUT or CN_GET_TIMEOUT of @ref ctlwizchip() for timeout configruation.
N */
Ntypedef struct wiz_NetTimeout_t
N{
N   uint8_t  retry_cnt;     ///< retry count 
N   uint16_t time_100us;    ///< time unit 100us
N}wiz_NetTimeout;
N
N/**
N *@brief Registers call back function for critical section of I/O functions such as
N *\ref WIZCHIP_READ, @ref WIZCHIP_WRITE, @ref WIZCHIP_READ_BUF and @ref WIZCHIP_WRITE_BUF.
N *@param cris_en : callback function for critical section enter.
N *@param cris_ex : callback function for critical section exit.
N *@todo Describe @ref WIZCHIP_CRITICAL_ENTER and @ref WIZCHIP_CRITICAL_EXIT marco or register your functions.
N *@note If you do not describe or register, default functions(@ref wizchip_cris_enter & @ref wizchip_cris_exit) is called.
N */
Nvoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
N
N
N/**
N *@brief Registers call back function for WIZCHIP select & deselect.
N *@param cs_sel : callback function for WIZCHIP select
N *@param cs_desel : callback fucntion for WIZCHIP deselect
N *@todo Describe @ref wizchip_cs_select and @ref wizchip_cs_deselect function or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
N
N/**
N *@brief Registers call back function for bus interface.
N *@param bus_rb   : callback function to read byte data using system bus
N *@param bus_wb   : callback function to write byte data using system bus
N *@todo Describe @ref wizchip_bus_readbyte and @ref wizchip_bus_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
N
N/**
N *@brief Registers call back function for SPI interface.
N *@param spi_rb : callback function to read byte usig SPI 
N *@param spi_wb : callback function to write byte usig SPI 
N *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb));
N
N/**
N * @ingroup extra_functions
N * @brief Controls to the WIZCHIP.
N * @details Resets WIZCHIP & internal PHY, Configures PHY mode, Monitor PHY(Link,Speed,Half/Full/Auto),
N * controls interrupt & mask and so on.
N * @param cwtype : Decides to the control type
N * @param arg : arg type is dependent on cwtype.
N * @return  0 : Success \n
N *         -1 : Fail because of invalid \ref ctlwizchip_type or unsupported \ref ctlwizchip_type in WIZCHIP 
N */          
Nint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network.
N * @details Controls to network environment, mode, timeout and so on.
N * @param cntype : Input. Decides to the control type
N * @param arg : Inout. arg type is dependent on cntype.
N * @return -1 : Fail because of invalid \ref ctlnetwork_type or unsupported \ref ctlnetwork_type in WIZCHIP \n
N *          0 : Success      
N */          
Nint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
N
N
N/* 
N * The following functions are implemented for internal use. 
N * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
N */
N 
N/**
N * @ingroup extra_functions
N * @brief Reset WIZCHIP by softly.
N */ 
Nvoid   wizchip_sw_reset(void);
N
N/**
N * @ingroup extra_functions
N * @brief Initializes WIZCHIP with socket buffer size
N * @param txsize Socket tx buffer sizes. If null, initialized the default size 2KB.
N * @param rxsize Socket rx buffer sizes. If null, initialized the default size 2KB.
N * @return 0 : succcess \n
N *        -1 : fail. Invalid buffer size
N */
Nint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
N
N/** 
N * @ingroup extra_functions
N * @brief Clear Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_clrinterrupt(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt of WIZCHIP.
N * @return @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterrupt(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Mask or Unmask Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_setinterruptmask(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt mask of WIZCHIP.
N * @return : The operated OR vaule of @ref intr_kind. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterruptmask(void);
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
N   int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
N#endif
N
N#if _WIZCHIP_ == 5500
X#if 5500 == 5500
N   void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
N/**
N * @ingroup extra_functions
N * @brief Set the phy information for WIZCHIP without power mode
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_setphyconf(wiz_PhyConf* phyconf);  
N /**
N * @ingroup extra_functions
N * @brief Get phy configuration information.
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_getphyconf(wiz_PhyConf* phyconf); 
N /**
N * @ingroup extra_functions
N * @brief Get phy status.
N * @param phyconf : @ref wiz_PhyConf
N */ 
N   void   wizphy_getphystat(wiz_PhyConf* phyconf);
N /**
N * @ingroup extra_functions
N * @brief set the power mode of phy inside WIZCHIP. Refer to @ref PHYCFGR in W5500, @ref PHYSTATUS in W5200
N * @param pmode Settig value of power down mode.
N */   
N   int8_t wizphy_setphypmode(uint8_t pmode);    
N#endif
N
N/**
N* @ingroup extra_functions
N * @brief Set the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @param pnetinfo Value of network mode. Refer to @ref netmode_type.
N */
Nint8_t wizchip_setnetmode(netmode_type netmode);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @return Value of network mode. Refer to @ref netmode_type.
N */
Nnetmode_type wizchip_getnetmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_settimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_gettimeout(wiz_NetTimeout* nettime);
N
N#endif   // _WIZCHIP_CONF_H_
L 85 "..\..\Ethernet\socket.h" 2
N
N#define SOCKET                uint8_t  ///< SOCKET type define for legacy driver
N
N#define SOCK_OK               1        ///< Result is OK about socket process.
N#define SOCK_BUSY             0        ///< Socket is busy on processing the operation. Valid only Non-block IO Mode.
N#define SOCK_FATAL            -1000    ///< Result is fatal error about socket process.
N
N#define SOCK_ERROR            0        
N#define SOCKERR_SOCKNUM       (SOCK_ERROR - 1)     ///< Invalid socket number
N#define SOCKERR_SOCKOPT       (SOCK_ERROR - 2)     ///< Invalid socket option
N#define SOCKERR_SOCKINIT      (SOCK_ERROR - 3)     ///< Socket is not initialized
N#define SOCKERR_SOCKCLOSED    (SOCK_ERROR - 4)     ///< Socket unexpectedly closed.
N#define SOCKERR_SOCKMODE      (SOCK_ERROR - 5)     ///< Invalid socket mode for socket operation.
N#define SOCKERR_SOCKFLAG      (SOCK_ERROR - 6)     ///< Invalid socket flag
N#define SOCKERR_SOCKSTATUS    (SOCK_ERROR - 7)     ///< Invalid socket status for socket operation.
N#define SOCKERR_ARG           (SOCK_ERROR - 10)    ///< Invalid argrument.
N#define SOCKERR_PORTZERO      (SOCK_ERROR - 11)    ///< Port number is zero
N#define SOCKERR_IPINVALID     (SOCK_ERROR - 12)    ///< Invalid IP address
N#define SOCKERR_TIMEOUT       (SOCK_ERROR - 13)    ///< Timeout occurred
N#define SOCKERR_DATALEN       (SOCK_ERROR - 14)    ///< Data length is zero or greater than buffer max size.
N#define SOCKERR_BUFFER        (SOCK_ERROR - 15)    ///< Socket buffer is not enough for data communication.
N
N#define SOCKFATAL_PACKLEN     (SOCK_FATAL - 1)     ///< Invalid packet length. Fatal Error.
N
N/*
N * SOCKET FLAG
N */
N#define SF_ETHER_OWN           (Sn_MR_MFEN)        ///< In \ref Sn_MR_MACRAW, Receive only the packet as broadcast, multicast and own packet
N#define SF_IGMP_VER2           (Sn_MR_MC)          ///< In \ref Sn_MR_UDP with \ref SF_MULTI_ENABLE, Select IGMP version 2.   
N#define SF_TCP_NODELAY         (Sn_MR_ND)          ///< In \ref Sn_MR_TCP, Use to nodelayed ack.
N#define SF_MULTI_ENABLE        (Sn_MR_MULTI)       ///< In \ref Sn_MR_UDP, Enable multicast mode.
N
N#if _WIZCHIP_ == 5500
X#if 5500 == 5500
N   #define SF_BROAD_BLOCK         (Sn_MR_BCASTB)   ///< In \ref Sn_MR_UDP or \ref Sn_MR_MACRAW, Block broadcast packet. Valid only in W5500
N   #define SF_MULTI_BLOCK         (Sn_MR_MMB)      ///< In \ref Sn_MR_MACRAW, Block multicast packet. Valid only in W5500
N   #define SF_IPv6_BLOCK          (Sn_MR_MIP6B)    ///< In \ref Sn_MR_MACRAW, Block IPv6 packet. Valid only in W5500
N   #define SF_UNI_BLOCK           (Sn_MR_UCASTB)   ///< In \ref Sn_MR_UDP with \ref SF_MULTI_ENABLE. Valid only in W5500
N#endif
N
N#define SF_IO_NONBLOCK           0x01              ///< Socket nonblock io mode. It used parameter in \ref socket().
N
N/*
N * UDP & MACRAW Packet Infomation
N */
N#define PACK_FIRST               0x80              ///< In Non-TCP packet, It indicates to start receiving a packet.
N#define PACK_REMAINED            0x01              ///< In Non-TCP packet, It indicates to remain a packet to be received.
N#define PACK_COMPLETED           0x00              ///< In Non-TCP packet, It indicates to complete to receive a packet.
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Open a socket.
N * @details Initializes the socket with 'sn' passed as parameter and open.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param protocol Protocol type to operate such as TCP, UDP and MACRAW.
N * @param port Port number to be bined.
N * @param flag Socket flags as \ref SF_ETHER_OWN, \ref SF_IGMP_VER2, \ref SF_TCP_NODELAY, \ref SF_MULTI_ENABLE, \ref SF_IO_NONBLOCK and so on.\n
N *             Valid flags only in W5500 : @ref SF_BROAD_BLOCK, @ref SF_MULTI_BLOCK, @ref SF_IPv6_BLOCK, and @ref SF_UNI_BLOCK.
N * @sa Sn_MR
N *
N * @return @b Success : The socket number @b 'sn' passed as parameter\n
N *         @b Fail    :\n @ref SOCKERR_SOCKNUM     - Invalid socket number\n
N *                        @ref SOCKERR_SOCKMODE    - Not support socket mode as TCP, UDP, and so on. \n
N *                        @ref SOCKERR_SOCKFLAG    - Invaild socket flag.
N */
Nint8_t  socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Close a socket.
N * @details It closes the socket  with @b'sn' passed as parameter.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N *
N * @return @b Success : @ref SOCK_OK \n
N *         @b Fail    : @ref SOCKERR_SOCKNUM - Invalid socket number
N */
Nint8_t  close(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Listen to a connection request from a client.
N * @details It is listening to a connection request from a client.
N * If connection request is accepted successfully, the connection is established. Socket sn is used in passive(server) mode.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @return @b Success : @ref SOCK_OK \n
N *         @b Fail    :\n @ref SOCKERR_SOCKINIT   - Socket is not initialized \n
N *                        @ref SOCKERR_SOCKCLOSED - Socket closed unexpectedly.
N */
Nint8_t  listen(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Try to connect a server.
N * @details It requests connection to the server with destination IP address and port number passed as parameter.\n
N * @note It is valid only in TCP client mode. 
N *       In block io mode, it does not return until connection is completed.
N *       In Non-block io mode, it return @ref SOCK_BUSY immediatly.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param addr Pointer variable of destination IP address. It should be allocated 4 bytes.
N * @param port Destination port number.
N *
N * @return @b Success : @ref SOCK_OK \n
N * @b Fail    :\n @ref SOCKERR_SOCKNUM   - Invalid socket number\n
N *                @ref SOCKERR_SOCKMODE  - Invalid socket mode\n
N *                @ref SOCKERR_SOCKINIT  - Socket is not initialized\n
N *                @ref SOCKERR_IPINVALID - Wrong server IP address\n
N *                @ref SOCKERR_PORTZERO  - Server port zero\n
N *                @ref SOCKERR_TIMEOUT   - Timeout occurred during request connection\n
N *                @ref SOCK_BUSY         - In non-block io mode, it returned immediatly\n 
N */
Nint8_t  connect(uint8_t sn, uint8_t * addr, uint16_t port);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Try to disconnect a connection socket.
N * @details It sends request message to disconnect the TCP socket 'sn' passed as parameter to the server or client.
N * @note It is valid only in TCP server or client mode. \n
N *       In block io mode, it does not return until disconnection is completed. \n
N *       In Non-block io mode, it return @ref SOCK_BUSY immediatly. \n
N
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @return @b Success :   @ref SOCK_OK \n
N *         @b Fail    :\n @ref SOCKERR_SOCKNUM  - Invalid socket number \n
N *                        @ref SOCKERR_SOCKMODE - Invalid operation in the socket \n
N *                        @ref SOCKERR_TIMEOUT  - Timeout occurred \n
N *                        @ref SOCK_BUSY        - Socket is busy.
N */
Nint8_t  disconnect(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief	Send data to the connected peer in TCP socket.
N * @details It is used to send outgoing data to the connected socket.
N * @note    It is valid only in TCP server or client mode. It can't send data greater than socket buffer size. \n
N *          In block io mode, It doesn't return until data send is completed - socket buffer size is greater than data. \n
N *          In non-block io mode, It return @ref SOCK_BUSY immediatly when socket buffer is not enough. \n
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf Pointer buffer containing data to be sent.
N * @param len The byte length of data in buf.
N * @return	@b Success : The sent data size \n
N *          @b Fail    : \n @ref SOCKERR_SOCKSTATUS - Invalid socket status for socket operation \n
N *                          @ref SOCKERR_TIMEOUT    - Timeout occurred \n
N *                          @ref SOCKERR_SOCKMODE 	- Invalid operation in the socket \n
N *                          @ref SOCKERR_SOCKNUM    - Invalid socket number \n
N *                          @ref SOCKERR_DATALEN    - zero data length \n
N *                          @ref SOCK_BUSY          - Socket is busy.
N */
Nint32_t send(uint8_t sn, uint8_t * buf, uint16_t len);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief	Receive data from the connected peer.
N * @details It is used to read incoming data from the connected socket.\n
N *          It waits for data as much as the application wants to receive.
N * @note    It is valid only in TCP server or client mode. It can't receive data greater than socket buffer size. \n
N *          In block io mode, it doesn't return until data reception is completed - data is filled as <I>len</I> in socket buffer. \n
N *          In non-block io mode, it return @ref SOCK_BUSY immediatly when <I>len</I> is greater than data size in socket buffer. \n
N *
N * @param sn  Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf Pointer buffer to read incoming data.
N * @param len The max data length of data in buf.
N * @return	@b Success : The real received data size \n
N *          @b Fail    :\n
N *                     @ref SOCKERR_SOCKSTATUS - Invalid socket status for socket operation \n
N *                     @ref SOCKERR_SOCKMODE   - Invalid operation in the socket \n
N *                     @ref SOCKERR_SOCKNUM    - Invalid socket number \n
N *                     @ref SOCKERR_DATALEN    - zero data length \n
N *                     @ref SOCK_BUSY          - Socket is busy.
N */
Nint32_t recv(uint8_t sn, uint8_t * buf, uint16_t len);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief	Sends datagram to the peer with destination IP address and port number passed as parameter.
N * @details It sends datagram of UDP or MACRAW to the peer with destination IP address and port number passed as parameter.\n
N *          Even if the connectionless socket has been previously connected to a specific address,
N *          the address and port number parameters override the destination address for that particular datagram only.
N * @note    In block io mode, It doesn't return until data send is completed - socket buffer size is greater than <I>len</I>.
N *          In non-block io mode, It return @ref SOCK_BUSY immediatly when socket buffer is not enough.
N *
N * @param sn    Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf   Pointer buffer to send outgoing data.
N * @param len   The byte length of data in buf.
N * @param addr  Pointer variable of destination IP address. It should be allocated 4 bytes.
N * @param port  Destination port number.
N *
N * @return @b Success : The sent data size \n
N *         @b Fail    :\n @ref SOCKERR_SOCKNUM     - Invalid socket number \n
N *                        @ref SOCKERR_SOCKMODE    - Invalid operation in the socket \n
N *                        @ref SOCKERR_SOCKSTATUS  - Invalid socket status for socket operation \n
N *                        @ref SOCKERR_DATALEN     - zero data length \n
N *                        @ref SOCKERR_IPINVALID   - Wrong server IP address\n
N *                        @ref SOCKERR_PORTZERO    - Server port zero\n
N *                        @ref SOCKERR_SOCKCLOSED  - Socket unexpectedly closed \n
N *                        @ref SOCKERR_TIMEOUT     - Timeout occurred \n
N *                        @ref SOCK_BUSY           - Socket is busy. 
N */
Nint32_t sendto(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Receive datagram of UDP or MACRAW
N * @details This function is an application I/F function which is used to receive the data in other then TCP mode. \n
N *          This function is used to receive UDP and MAC_RAW mode, and handle the header as well. 
N *          This function can divide to received the packet data.
N *          On the MACRAW SOCKET, the addr and port parameters are ignored.
N * @note    In block io mode, it doesn't return until data reception is completed - data is filled as <I>len</I> in socket buffer
N *          In non-block io mode, it return @ref SOCK_BUSY immediatly when <I>len</I> is greater than data size in socket buffer.
N *
N * @param sn   Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf  Pointer buffer to read incoming data.
N * @param len  The max data length of data in buf. 
N *             When the received packet size <= len, receives data as packet sized.
N *             When others, receives data as len.
N * @param addr Pointer variable of destination IP address. It should be allocated 4 bytes.
N *             It is valid only when the first call recvfrom for receiving the packet.
N *             When it is valid, @ref  packinfo[7] should be set as '1' after call @ref getsockopt(sn, SO_PACKINFO, &packinfo).
N * @param port Pointer variable of destination port number.
N *             It is valid only when the first call recvform for receiving the packet.
N*             When it is valid, @ref  packinfo[7] should be set as '1' after call @ref getsockopt(sn, SO_PACKINFO, &packinfo).
N *
N * @return	@b Success : This function return real received data size for success.\n
N *          @b Fail    : @ref SOCKERR_DATALEN    - zero data length \n
N *                       @ref SOCKERR_SOCKMODE   - Invalid operation in the socket \n
N *                       @ref SOCKERR_SOCKNUM    - Invalid socket number \n
N *                       @ref SOCKBUSY           - Socket is busy.
N */
Nint32_t recvfrom(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port);
N
N
N/////////////////////////////
N// SOCKET CONTROL & OPTION //
N/////////////////////////////
N#define SOCK_IO_BLOCK         0  ///< Socket Block IO Mode in @ref setsockopt().
N#define SOCK_IO_NONBLOCK      1  ///< Socket Non-block IO Mode in @ref setsockopt().
N
N/**
N * @defgroup DATA_TYPE DATA TYPE
N */
N
N/**
N * @ingroup DATA_TYPE
N * @brief The kind of Socket Interrupt.
N * @sa Sn_IR, Sn_IMR, setSn_IR(), getSn_IR(), setSn_IMR(), getSn_IMR()
N */
Ntypedef enum
N{
N   SIK_CONNECTED     = (1 << 0),    ///< conntected
N   SIK_DISCONNECTED  = (1 << 1),    ///< disconnected
N   SIK_RECEIVED      = (1 << 2),    ///< data received
N   SIK_TIMEOUT       = (1 << 3),    ///< timeout occured
N   SIK_SENT          = (1 << 4),    ///< send ok
N   SIK_ALL           = 0x1F,        ///< all interrupt
N}sockint_kind;
N
N/**
N * @ingroup DATA_TYPE
N * @brief The type of @ref ctlsocket().
N */
Ntypedef enum
N{
N   CS_SET_IOMODE,          ///< set socket IO mode with @ref SOCK_IO_BLOCK or @ref SOCK_IO_NONBLOCK
N   CS_GET_IOMODE,          ///< get socket IO mode
N   CS_GET_MAXTXBUF,        ///< get the size of socket buffer allocated in TX memory
N   CS_GET_MAXRXBUF,        ///< get the size of socket buffer allocated in RX memory
N   CS_CLR_INTERRUPT,       ///< clear the interrupt of socket with @ref sockint_kind
N   CS_GET_INTERRUPT,       ///< get the socket interrupt. refer to @ref sockint_kind
N   CS_SET_INTMASK,         ///< set the interrupt mask of socket with @ref sockint_kind
N   CS_GET_INTMASK          ///< get the masked interrupt of socket. refer to @ref sockint_kind
N}ctlsock_type;
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief The type of socket option in @ref setsockopt() or @ref getsockopt()
N */ 
Ntypedef enum
N{
N   SO_FLAG,           ///< Valid only in getsockopt(), For set flag of socket refer to <I>flag</I> in @ref socket().
N   SO_TTL,              ///< Set/Get TTL. @ref Sn_TTL  ( @ref setSn_TTL(), @ref getSn_TTL() )
N   SO_TOS,              ///< Set/Get TOS. @ref Sn_TOS  ( @ref setSn_TOS(), @ref getSn_TOS() )
N   SO_MSS,              ///< Set/Get MSS. @ref Sn_MSSR ( @ref setSn_MSSR(), @ref getSn_MSSR() )
N   SO_DESTIP,           ///< Set/Get the destination IP address. @ref Sn_DIPR ( @ref setSn_DIPR(), @ref getSn_DIPR() )
N   SO_DESTPORT,         ///< Set/Get the destionation Port number. @ref Sn_DPORT ( @ref setSn_DPORT(), @ref getSn_DPORT() )
N#if _WIZCHIP_ != 5100   
X#if 5500 != 5100   
N   SO_KEEPALIVESEND,    ///< Valid only in setsockopt. Manually send keep-alive packet in TCP mode
N   #if _WIZCHIP_ > 5200   
X   #if 5500 > 5200   
N      SO_KEEPALIVEAUTO, ///< Set/Get keep-alive auto transmittion timer in TCP mode
N   #endif      
N#endif
N   SO_SENDBUF,          ///< Valid only in getsockopt. Get the free data size of Socekt TX buffer. @ref Sn_TX_FSR, @ref getSn_TX_FSR()
N   SO_RECVBUF,          ///< Valid only in getsockopt. Get the received data size in socket RX buffer. @ref Sn_RX_RSR, @ref getSn_RX_RSR()
N   SO_STATUS,           ///< Valid only in getsockopt. Get the socket status. @ref Sn_SR, @ref getSn_SR()
N   SO_REMAINSIZE,       ///< Valid only in getsockopt. Get the remained packet size in other then TCP mode.
N   SO_PACKINFO          ///< Valid only in getsockopt. Get the packet information as @ref PACK_FIRST, @ref PACK_REMAINED, and @ref PACK_COMPLETED in other then TCP mode.
N}sockopt_type;
N
N/**
N * @ingroup WIZnet_socket_APIs
N *  @brief Control socket.
N *  @details Control IO mode, Interrupt & Mask of socket and get the socket buffer information.
N *           Refer to @ref ctlsock_type.
N *  @param sn socket number
N *  @param cstype type of control socket. refer to @ref ctlsock_type.
N *  @param arg Data type and value is determined according to @ref ctlsock_type. \n
N *             <table>
N *                  <tr> <td> @b cstype </td> <td> @b data type</td><td>@b value</td></tr>
N *                  <tr> <td> @ref CS_SET_IOMODE \n @ref CS_GET_IOMODE </td> <td> uint8_t </td><td>@ref SOCK_IO_BLOCK @ref SOCK_IO_NONBLOCK</td></tr>
N *                  <tr> <td> @ref CS_GET_MAXTXBUF \n @ref CS_GET_MAXRXBUF </td> <td> uint16_t </td><td> 0 ~ 16K </td></tr>
N *                  <tr> <td> @ref CS_CLR_INTERRUPT \n @ref CS_GET_INTERRUPT \n @ref CS_SET_INTMASK \n @ref CS_GET_INTMASK </td> <td> @ref sockint_kind </td><td> @ref SIK_CONNECTED, etc.  </td></tr> 
N *             </table>
N *  @return @b Success @ref SOCK_OK \n
N *          @b fail    @ref SOCKERR_ARG         - Invalid argument\n
N */
Nint8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg);
N
N/** 
N * @ingroup WIZnet_socket_APIs
N *  @brief set socket options
N *  @details Set socket option like as TTL, MSS, TOS, and so on. Refer to @ref sockopt_type.
N *               
N *  @param sn socket number
N *  @param sotype socket option type. refer to @ref sockopt_type
N *  @param arg Data type and value is determined according to <I>sotype</I>. \n
N *             <table>
N *                  <tr> <td> @b sotype </td> <td> @b data type</td><td>@b value</td></tr> 
N *                  <tr> <td> @ref SO_TTL </td> <td> uint8_t </td><td> 0 ~ 255 </td> </tr>
N *                  <tr> <td> @ref SO_TOS </td> <td> uint8_t </td><td> 0 ~ 255 </td> </tr>
N *                  <tr> <td> @ref SO_MSS </td> <td> uint16_t </td><td> 0 ~ 65535 </td> </tr>
N *                  <tr> <td> @ref SO_DESTIP </td> <td> uint8_t[4] </td><td>  </td></tr> 
N *                  <tr> <td> @ref SO_DESTPORT </td> <td> uint16_t </td><td> 0 ~ 65535 </td></tr> 
N *                  <tr> <td> @ref SO_KEEPALIVESEND </td> <td> null </td><td> null </td></tr> 
N *                  <tr> <td> @ref SO_KEEPALIVEAUTO </td> <td> uint8_t </td><td> 0 ~ 255 </td></tr> 
N *             </table>
N * @return 
N * - @b Success : @ref SOCK_OK \n
N * - @b Fail 
N *  - @ref SOCKERR_SOCKNUM     - Invalid Socket number \n
N *  - @ref SOCKERR_SOCKMODE    - Invalid socket mode \n
N *  - @ref SOCKERR_SOCKOPT     - Invalid socket option or its value \n
N *  - @ref SOCKERR_TIMEOUT     - Timeout occurred when sending keep-alive packet \n
N */
Nint8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg);
N
N/** 
N * @ingroup WIZnet_socket_APIs
N *  @brief get socket options
N *  @details Get socket option like as FLAG, TTL, MSS, and so on. Refer to @ref sockopt_type
N *  @param sn socket number
N *  @param sotype socket option type. refer to @ref sockopt_type
N *  @param arg Data type and value is determined according to <I>sotype</I>. \n
N *             <table>
N *                  <tr> <td> @b sotype </td> <td>@b data type</td><td>@b value</td></tr>
N *                  <tr> <td> @ref SO_FLAG </td> <td> uint8_t </td><td> @ref SF_ETHER_OWN, etc... </td> </tr>
N *                  <tr> <td> @ref SO_TOS </td> <td> uint8_t </td><td> 0 ~ 255 </td> </tr>
N *                  <tr> <td> @ref SO_MSS </td> <td> uint16_t </td><td> 0 ~ 65535 </td> </tr>
N *                  <tr> <td> @ref SO_DESTIP </td> <td> uint8_t[4] </td><td>  </td></tr> 
N *                  <tr> <td> @ref SO_DESTPORT </td> <td> uint16_t </td><td>  </td></tr> 
N *                  <tr> <td> @ref SO_KEEPALIVEAUTO </td> <td> uint8_t </td><td> 0 ~ 255 </td></tr> 
N *                  <tr> <td> @ref SO_SENDBUF </td> <td> uint16_t </td><td> 0 ~ 65535 </td></tr>  
N *                  <tr> <td> @ref SO_RECVBUF </td> <td> uint16_t </td><td> 0 ~ 65535 </td></tr>  
N *                  <tr> <td> @ref SO_STATUS </td> <td> uint8_t </td><td> @ref SOCK_ESTABLISHED, etc.. </td></tr>  
N *                  <tr> <td> @ref SO_REMAINSIZE </td> <td> uint16_t </td><td> 0~ 65535 </td></tr>
N *                  <tr> <td> @ref SO_PACKINFO </td> <td> uint8_t </td><td> @ref PACK_FIRST, etc... </td></tr>
N *             </table>
N * @return 
N * - @b Success : @ref SOCK_OK \n
N * - @b Fail 
N *  - @ref SOCKERR_SOCKNUM     - Invalid Socket number \n
N *  - @ref SOCKERR_SOCKOPT     - Invalid socket option or its value \n
N *  - @ref SOCKERR_SOCKMODE    - Invalid socket mode \n
N * @note
N *   The option as PACK_REMAINED and SO_PACKINFO is valid only in NON-TCP mode and after call @ref recvfrom(). \n
N *   When SO_PACKINFO value is PACK_FIRST and the return value of recvfrom() is zero, 
N *   This means the zero byte UDP data(UDP Header only) received.
N  */
Nint8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg);
N
N#endif   // _SOCKET_H_
L 53 "..\..\Internet\DHCP\dhcp.c" 2
N#include "dhcp.h"
L 1 "..\..\Internet\DHCP\dhcp.h" 1
N//*****************************************************************************
N//
N//! \file dhcp.h
N//! \brief DHCP APIs Header file.
N//! \details Processig DHCP protocol as DISCOVER, OFFER, REQUEST, ACK, NACK and DECLINE.
N//! \version 1.1.0
N//! \date 2013/11/18
N//! \par  Revision history
N//!       <2013/11/18> 1st Release
N//!       <2012/12/20> V1.1.0
N//!         1. Move unreferenced DEFINE to dhcp.c
N//!       <2012/12/26> V1.1.1
N//! \author Eric Jung & MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N#ifndef _DHCP_H_
N#define _DHCP_H_
N
N/*
N * @brief 
N * @details If you want to display debug & procssing message, Define _DHCP_DEBUG_ 
N * @note    If defined, it dependens on <stdio.h>
N */
N#define _DHCP_DEBUG_
N
N
N/* Retry to processing DHCP */
N#define	MAX_DHCP_RETRY          20        ///< Maxium retry count
N#define	DHCP_WAIT_TIME          10       ///< Wait Time 10s
N
N
N/* UDP port numbers for DHCP */
N#define DHCP_SERVER_PORT      	67	      ///< DHCP server port number
N#define DHCP_CLIENT_PORT         68	      ///< DHCP client port number
N
N
N#define MAGIC_COOKIE             0x63825363  ///< Any number. You can be modifyed it any number
N
N#define DCHP_HOST_NAME           "WIZnet\0"
N
N/* 
N * @brief return value of @ref DHCP_run()
N */
Nenum
N{
N   DHCP_FAILED = 0,  ///< Procssing Fail
N   DHCP_RUNNING,     ///< Procssing DHCP proctocol
N   DHCP_IP_ASSIGN,   ///< First Occupy IP from DHPC server      (if cbfunc == null, act as default default_ip_assign)
N   DHCP_IP_CHANGED,  ///< Change IP address by new ip from DHCP (if cbfunc == null, act as default default_ip_update)
N   DHCP_IP_LEASED,   ///< Stand by 
N   DHCP_STOPPED      ///< Stop procssing DHCP protocol
N};
N
N/*
N * @brief DHCP client initialization (outside of the main loop)
N * @param s   - socket number
N * @param buf - buffer for procssing DHCP message
N */
Nvoid DHCP_init(uint8_t s, uint8_t * buf);
N
N/*
N * @brief DHCP 1s Tick Timer handler
N * @note SHOULD BE register to your system 1s Tick timer handler 
N */
Nvoid DHCP_time_handler(void);
N
N/* 
N * @brief Register call back function 
N * @param ip_assign   - callback func when IP is assigned from DHCP server first
N * @param ip_update   - callback func when IP is changed
N * @prarm ip_conflict - callback func when the assigned IP is conflict with others.
N */
Nvoid reg_dhcp_cbfunc(void(*ip_assign)(void), void(*ip_update)(void), void(*ip_conflict)(void));
N
N/*
N * @brief DHCP client in the main loop
N * @return    The value is as the follow \n
N *            @ref DHCP_FAILED     \n
N *            @ref DHCP_RUNNING    \n
N *            @ref DHCP_IP_ASSIGN  \n
N *            @ref DHCP_IP_CHANGED \n
N * 			  @ref DHCP_IP_LEASED  \n
N *            @ref DHCP_STOPPED    \n
N *
N * @note This function is always called by you main task.
N */ 
Nuint8_t DHCP_run(void);
N
N/*
N * @brief Stop DHCP procssing
N * @note If you want to restart. call DHCP_init() and DHCP_run()
N */ 
Nvoid    DHCP_stop(void);
N
N/* Get Network information assigned from DHCP server */
N/*
N * @brief Get IP address
N * @param ip  - IP address to be returned
N */
Nvoid getIPfromDHCP(uint8_t* ip);
N/*
N * @brief Get Gateway address
N * @param ip  - Gateway address to be returned
N */
Nvoid getGWfromDHCP(uint8_t* ip);
N/*
N * @brief Get Subnet mask value
N * @param ip  - Subnet mask to be returned
N */
Nvoid getSNfromDHCP(uint8_t* ip);
N/*
N * @brief Get DNS address
N * @param ip  - DNS address to be returned
N */
Nvoid getDNSfromDHCP(uint8_t* ip);
N
N/*
N * @brief Get the leased time by DHCP sever
N * @retrun unit 1s
N */
Nuint32_t getDHCPLeasetime(void);
N
N#endif	/* _DHCP_H_ */
L 54 "..\..\Internet\DHCP\dhcp.c" 2
N
N/* If you want to display debug & procssing message, Define _DHCP_DEBUG_ in dhcp.h */
N
N#ifdef _DHCP_DEBUG_
N   #include <stdio.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 59 "..\..\Internet\DHCP\dhcp.c" 2
N#endif   
N
N/* DHCP state machine. */
N#define STATE_DHCP_INIT          0        ///< Initialize
N#define STATE_DHCP_DISCOVER      1        ///< send DISCOVER and wait OFFER
N#define STATE_DHCP_REQUEST       2        ///< send REQEUST and wait ACK or NACK
N#define STATE_DHCP_LEASED        3        ///< ReceiveD ACK and IP leased
N#define STATE_DHCP_REREQUEST     4        ///< send REQUEST for maintaining leased IP
N#define STATE_DHCP_RELEASE       5        ///< No use
N#define STATE_DHCP_STOP          6        ///< Stop procssing DHCP
N
N#define DHCP_FLAGSBROADCAST      0x8000   ///< The broadcast value of flags in @ref RIP_MSG 
N#define DHCP_FLAGSUNICAST        0x0000   ///< The unicast   value of flags in @ref RIP_MSG
N
N/* DHCP message OP code */
N#define DHCP_BOOTREQUEST         1        ///< Request Message used in op of @ref RIP_MSG
N#define DHCP_BOOTREPLY           2        ///< Reply Message used i op of @ref RIP_MSG
N
N/* DHCP message type */
N#define DHCP_DISCOVER            1        ///< DISCOVER message in OPT of @ref RIP_MSG
N#define DHCP_OFFER               2        ///< OFFER message in OPT of @ref RIP_MSG
N#define DHCP_REQUEST             3        ///< REQUEST message in OPT of @ref RIP_MSG
N#define DHCP_DECLINE             4        ///< DECLINE message in OPT of @ref RIP_MSG
N#define DHCP_ACK                 5        ///< ACK message in OPT of @ref RIP_MSG
N#define DHCP_NAK                 6        ///< NACK message in OPT of @ref RIP_MSG
N#define DHCP_RELEASE             7        ///< RELEASE message in OPT of @ref RIP_MSG. No use
N#define DHCP_INFORM              8        ///< INFORM message in OPT of @ref RIP_MSG. No use
N
N#define DHCP_HTYPE10MB           1        ///< Used in type of @ref RIP_MSG
N#define DHCP_HTYPE100MB          2        ///< Used in type of @ref RIP_MSG
N
N#define DHCP_HLENETHERNET        6        ///< Used in hlen of @ref RIP_MSG
N#define DHCP_HOPS                0        ///< Used in hops of @ref RIP_MSG
N#define DHCP_SECS                0        ///< Used in secs of @ref RIP_MSG
N
N#define INFINITE_LEASETIME       0xffffffff	///< Infinite lease time
N
N#define OPT_SIZE                 312               /// Max OPT size of @ref RIP_MSG
N#define RIP_MSG_SIZE             (236+OPT_SIZE)    /// Max size of @ref RIP_MSG
N
N/* 
N * @brief DHCP option and value (cf. RFC1533)
N */
Nenum
N{
N   padOption               = 0,
N   subnetMask              = 1,
N   timerOffset             = 2,
N   routersOnSubnet         = 3,
N   timeServer              = 4,
N   nameServer              = 5,
N   dns                     = 6,
N   logServer               = 7,
N   cookieServer            = 8,
N   lprServer               = 9,
N   impressServer           = 10,
N   resourceLocationServer	= 11,
N   hostName                = 12,
N   bootFileSize            = 13,
N   meritDumpFile           = 14,
N   domainName              = 15,
N   swapServer              = 16,
N   rootPath                = 17,
N   extentionsPath          = 18,
N   IPforwarding            = 19,
N   nonLocalSourceRouting   = 20,
N   policyFilter            = 21,
N   maxDgramReasmSize       = 22,
N   defaultIPTTL            = 23,
N   pathMTUagingTimeout     = 24,
N   pathMTUplateauTable     = 25,
N   ifMTU                   = 26,
N   allSubnetsLocal         = 27,
N   broadcastAddr           = 28,
N   performMaskDiscovery    = 29,
N   maskSupplier            = 30,
N   performRouterDiscovery  = 31,
N   routerSolicitationAddr  = 32,
N   staticRoute             = 33,
N   trailerEncapsulation    = 34,
N   arpCacheTimeout         = 35,
N   ethernetEncapsulation   = 36,
N   tcpDefaultTTL           = 37,
N   tcpKeepaliveInterval    = 38,
N   tcpKeepaliveGarbage     = 39,
N   nisDomainName           = 40,
N   nisServers              = 41,
N   ntpServers              = 42,
N   vendorSpecificInfo      = 43,
N   netBIOSnameServer       = 44,
N   netBIOSdgramDistServer	= 45,
N   netBIOSnodeType         = 46,
N   netBIOSscope            = 47,
N   xFontServer             = 48,
N   xDisplayManager         = 49,
N   dhcpRequestedIPaddr     = 50,
N   dhcpIPaddrLeaseTime     = 51,
N   dhcpOptionOverload      = 52,
N   dhcpMessageType         = 53,
N   dhcpServerIdentifier    = 54,
N   dhcpParamRequest        = 55,
N   dhcpMsg                 = 56,
N   dhcpMaxMsgSize          = 57,
N   dhcpT1value             = 58,
N   dhcpT2value             = 59,
N   dhcpClassIdentifier     = 60,
N   dhcpClientIdentifier    = 61,
N   endOption               = 255
N};
N
N/*
N * @brief DHCP message format
N */ 
Ntypedef struct {
N	uint8_t  op;            ///< @ref DHCP_BOOTREQUEST or @ref DHCP_BOOTREPLY
N	uint8_t  htype;         ///< @ref DHCP_HTYPE10MB or @ref DHCP_HTYPE100MB
N	uint8_t  hlen;          ///< @ref DHCP_HLENETHERNET
N	uint8_t  hops;          ///< @ref DHCP_HOPS
N	uint32_t xid;           ///< @ref DHCP_XID  This increase one every DHCP transaction.
N	uint16_t secs;          ///< @ref DHCP_SECS
N	uint16_t flags;         ///< @ref DHCP_FLAGSBROADCAST or @ref DHCP_FLAGSUNICAST
N	uint8_t  ciaddr[4];     ///< @ref Request IP to DHCP sever
N	uint8_t  yiaddr[4];     ///< @ref Offered IP from DHCP server
N	uint8_t  siaddr[4];     ///< No use 
N	uint8_t  giaddr[4];     ///< No use
N	uint8_t  chaddr[16];    ///< DHCP client 6bytes MAC address. Others is filled to zero
N	uint8_t  sname[64];     ///< No use
N	uint8_t  file[128];     ///< No use
N	uint8_t  OPT[OPT_SIZE]; ///< Option
X	uint8_t  OPT[312]; 
N} RIP_MSG;
N
N
N
Nuint8_t DHCP_SOCKET;                      // Socket number for DHCP
N
Nuint8_t DHCP_SIP[4];                      // DHCP Server IP address
N
N// Network information from DHCP Server
Nuint8_t OLD_allocated_ip[4]   = {0, };    // Previous IP address
Nuint8_t DHCP_allocated_ip[4]  = {0, };    // IP address from DHCP
Nuint8_t DHCP_allocated_gw[4]  = {0, };    // Gateway address from DHCP
Nuint8_t DHCP_allocated_sn[4]  = {0, };    // Subnet mask from DHCP
Nuint8_t DHCP_allocated_dns[4] = {0, };    // DNS address from DHCP
N
N
Nint8_t   dhcp_state        = STATE_DHCP_INIT;   // DHCP state
Xint8_t   dhcp_state        = 0;   
Nint8_t   dhcp_retry_count  = 0;                 
N
Nuint32_t dhcp_lease_time   			= INFINITE_LEASETIME;
Xuint32_t dhcp_lease_time   			= 0xffffffff;
Nvolatile uint32_t dhcp_tick_1s      = 0;                 // unit 1 second
Nuint32_t dhcp_tick_next    			= DHCP_WAIT_TIME ;
Xuint32_t dhcp_tick_next    			= 10 ;
N
Nuint32_t DHCP_XID;      // Any number
N
NRIP_MSG* pDHCPMSG;      // Buffer pointer for DHCP processing
N
Nuint8_t HOST_NAME[] = DCHP_HOST_NAME;  
Xuint8_t HOST_NAME[] = "WIZnet\0";  
N
Nuint8_t DHCP_CHADDR[6]; // DHCP Client MAC address.
N
N/* The default callback function */
Nvoid default_ip_assign(void);
Nvoid default_ip_update(void);
Nvoid default_ip_conflict(void);
N
N/* Callback handler */
Nvoid (*dhcp_ip_assign)(void)   = default_ip_assign;     /* handler to be called when the IP address from DHCP server is first assigned */
Nvoid (*dhcp_ip_update)(void)   = default_ip_update;     /* handler to be called when the IP address from DHCP server is updated */
Nvoid (*dhcp_ip_conflict)(void) = default_ip_conflict;   /* handler to be called when the IP address from DHCP server is conflict */
N
Nvoid reg_dhcp_cbfunc(void(*ip_assign)(void), void(*ip_update)(void), void(*ip_conflict)(void));
N
N
N/* send DISCOVER message to DHCP server */
Nvoid     send_DHCP_DISCOVER(void);
N
N/* send REQEUST message to DHCP server */
Nvoid     send_DHCP_REQUEST(void);
N
N/* send DECLINE message to DHCP server */
Nvoid     send_DHCP_DECLINE(void);
N
N/* IP conflict check by sending ARP-request to leased IP and wait ARP-response. */
Nint8_t   check_DHCP_leasedIP(void);
N
N/* check the timeout in DHCP process */
Nuint8_t  check_DHCP_timeout(void);
N
N/* Intialize to timeout process.  */
Nvoid     reset_DHCP_timeout(void);
N
N/* Parse message as OFFER and ACK and NACK from DHCP server.*/
Nint8_t   parseDHCPCMSG(void);
N
N/* The default handler of ip assign first */
Nvoid default_ip_assign(void)
N{
N   setSIPR(DHCP_allocated_ip);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x000F << 8) + (0x00 << 3)), DHCP_allocated_ip, 4);
N   setSUBR(DHCP_allocated_sn);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0005 << 8) + (0x00 << 3)), DHCP_allocated_sn,4);
N   setGAR (DHCP_allocated_gw);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0001 << 8) + (0x00 << 3)),DHCP_allocated_gw,4);
N}
N
N/* The default handler of ip chaged */
Nvoid default_ip_update(void)
N{
N	/* WIZchip Software Reset */
N   setMR(MR_RST);
X   WIZCHIP_WRITE((0x00000000 + (0x0000 << 8) + (0x00 << 3)),0x80);
N   getMR(); // for delay
X   WIZCHIP_READ((0x00000000 + (0x0000 << 8) + (0x00 << 3))); 
N   default_ip_assign();
N   setSHAR(DHCP_CHADDR);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), DHCP_CHADDR, 6);
N}
N
N/* The default handler of ip chaged */
Nvoid default_ip_conflict(void)
N{
N	// WIZchip Software Reset
N	setMR(MR_RST);
X	WIZCHIP_WRITE((0x00000000 + (0x0000 << 8) + (0x00 << 3)),0x80);
N	getMR(); // for delay
X	WIZCHIP_READ((0x00000000 + (0x0000 << 8) + (0x00 << 3))); 
N	setSHAR(DHCP_CHADDR);
X	WIZCHIP_WRITE_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), DHCP_CHADDR, 6);
N}
N
N/* register the call back func. */
Nvoid reg_dhcp_cbfunc(void(*ip_assign)(void), void(*ip_update)(void), void(*ip_conflict)(void))
N{
N   dhcp_ip_assign   = default_ip_assign;
N   dhcp_ip_update   = default_ip_update;
N   dhcp_ip_conflict = default_ip_conflict;
N   if(ip_assign)   dhcp_ip_assign = ip_assign;
N   if(ip_update)   dhcp_ip_update = ip_update;
N   if(ip_conflict) dhcp_ip_conflict = ip_conflict;
N}
N
N/* make the common DHCP message */
Nvoid makeDHCPMSG(void)
N{
N   uint8_t  bk_mac[6];
N   uint8_t* ptmp;
N   uint8_t  i;
N   getSHAR(bk_mac);
X   WIZCHIP_READ_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), bk_mac, 6);
N	pDHCPMSG->op      = DHCP_BOOTREQUEST;
X	pDHCPMSG->op      = 1;
N	pDHCPMSG->htype   = DHCP_HTYPE10MB;
X	pDHCPMSG->htype   = 1;
N	pDHCPMSG->hlen    = DHCP_HLENETHERNET;
X	pDHCPMSG->hlen    = 6;
N	pDHCPMSG->hops    = DHCP_HOPS;
X	pDHCPMSG->hops    = 0;
N	ptmp              = (uint8_t*)(&pDHCPMSG->xid);
N	*(ptmp+0)         = (uint8_t)((DHCP_XID & 0xFF000000) >> 24);
N	*(ptmp+1)         = (uint8_t)((DHCP_XID & 0x00FF0000) >> 16);
N   *(ptmp+2)         = (uint8_t)((DHCP_XID & 0x0000FF00) >>  8);
N	*(ptmp+3)         = (uint8_t)((DHCP_XID & 0x000000FF) >>  0);   
N	pDHCPMSG->secs    = DHCP_SECS;
X	pDHCPMSG->secs    = 0;
N	ptmp              = (uint8_t*)(&pDHCPMSG->flags);	
N	*(ptmp+0)         = (uint8_t)((DHCP_FLAGSBROADCAST & 0xFF00) >> 8);
X	*(ptmp+0)         = (uint8_t)((0x8000 & 0xFF00) >> 8);
N	*(ptmp+1)         = (uint8_t)((DHCP_FLAGSBROADCAST & 0x00FF) >> 0);
X	*(ptmp+1)         = (uint8_t)((0x8000 & 0x00FF) >> 0);
N
N	pDHCPMSG->ciaddr[0] = 0;
N	pDHCPMSG->ciaddr[1] = 0;
N	pDHCPMSG->ciaddr[2] = 0;
N	pDHCPMSG->ciaddr[3] = 0;
N
N	pDHCPMSG->yiaddr[0] = 0;
N	pDHCPMSG->yiaddr[1] = 0;
N	pDHCPMSG->yiaddr[2] = 0;
N	pDHCPMSG->yiaddr[3] = 0;
N
N	pDHCPMSG->siaddr[0] = 0;
N	pDHCPMSG->siaddr[1] = 0;
N	pDHCPMSG->siaddr[2] = 0;
N	pDHCPMSG->siaddr[3] = 0;
N
N	pDHCPMSG->giaddr[0] = 0;
N	pDHCPMSG->giaddr[1] = 0;
N	pDHCPMSG->giaddr[2] = 0;
N	pDHCPMSG->giaddr[3] = 0;
N
N	pDHCPMSG->chaddr[0] = DHCP_CHADDR[0];
N	pDHCPMSG->chaddr[1] = DHCP_CHADDR[1];
N	pDHCPMSG->chaddr[2] = DHCP_CHADDR[2];
N	pDHCPMSG->chaddr[3] = DHCP_CHADDR[3];
N	pDHCPMSG->chaddr[4] = DHCP_CHADDR[4];
N	pDHCPMSG->chaddr[5] = DHCP_CHADDR[5];
N
N	for (i = 6; i < 16; i++)  pDHCPMSG->chaddr[i] = 0;
N	for (i = 0; i < 64; i++)  pDHCPMSG->sname[i]  = 0;
N	for (i = 0; i < 128; i++) pDHCPMSG->file[i]   = 0;
N
N	// MAGIC_COOKIE
N	pDHCPMSG->OPT[0] = (uint8_t)((MAGIC_COOKIE & 0xFF000000) >> 24);
X	pDHCPMSG->OPT[0] = (uint8_t)((0x63825363 & 0xFF000000) >> 24);
N	pDHCPMSG->OPT[1] = (uint8_t)((MAGIC_COOKIE & 0x00FF0000) >> 16);
X	pDHCPMSG->OPT[1] = (uint8_t)((0x63825363 & 0x00FF0000) >> 16);
N	pDHCPMSG->OPT[2] = (uint8_t)((MAGIC_COOKIE & 0x0000FF00) >>  8);
X	pDHCPMSG->OPT[2] = (uint8_t)((0x63825363 & 0x0000FF00) >>  8);
N	pDHCPMSG->OPT[3] = (uint8_t) (MAGIC_COOKIE & 0x000000FF) >>  0;
X	pDHCPMSG->OPT[3] = (uint8_t) (0x63825363 & 0x000000FF) >>  0;
N}
N
N/* SEND DHCP DISCOVER */
Nvoid send_DHCP_DISCOVER(void)
N{
N	uint16_t i;
N	uint8_t ip[4];
N	uint16_t k = 0;
N   
N   makeDHCPMSG();
N
N   k = 4;     // beacaue MAGIC_COOKIE already made by makeDHCPMSG()
N   
N	// Option Request Param
N	pDHCPMSG->OPT[k++] = dhcpMessageType;
N	pDHCPMSG->OPT[k++] = 0x01;
N	pDHCPMSG->OPT[k++] = DHCP_DISCOVER;
X	pDHCPMSG->OPT[k++] = 1;
N	
N	// Client identifier
N	pDHCPMSG->OPT[k++] = dhcpClientIdentifier;
N	pDHCPMSG->OPT[k++] = 0x07;
N	pDHCPMSG->OPT[k++] = 0x01;
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[0];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[1];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[2];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[3];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[4];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[5];
N	
N	// host name
N	pDHCPMSG->OPT[k++] = hostName;
N	pDHCPMSG->OPT[k++] = 0;          // fill zero length of hostname 
N	for(i = 0 ; HOST_NAME[i] != 0; i++)
N   	pDHCPMSG->OPT[k++] = HOST_NAME[i];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[3];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[4];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[5];
N	pDHCPMSG->OPT[k - (i+3+1)] = i+3; // length of hostname
N
N	pDHCPMSG->OPT[k++] = dhcpParamRequest;
N	pDHCPMSG->OPT[k++] = 0x06;	// length of request
N	pDHCPMSG->OPT[k++] = subnetMask;
N	pDHCPMSG->OPT[k++] = routersOnSubnet;
N	pDHCPMSG->OPT[k++] = dns;
N	pDHCPMSG->OPT[k++] = domainName;
N	pDHCPMSG->OPT[k++] = dhcpT1value;
N	pDHCPMSG->OPT[k++] = dhcpT2value;
N	pDHCPMSG->OPT[k++] = endOption;
N
N	for (i = k; i < OPT_SIZE; i++) pDHCPMSG->OPT[i] = 0;
X	for (i = k; i < 312; i++) pDHCPMSG->OPT[i] = 0;
N
N	// send broadcasting packet
N	ip[0] = 255;
N	ip[1] = 255;
N	ip[2] = 255;
N	ip[3] = 255;
N
N#ifdef _DHCP_DEBUG_
N	printf("> Send DHCP_DISCOVER\r\n");
N#endif
N
N	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
X	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, (236+312), ip, 67);
N}
N
N/* SEND DHCP REQUEST */
Nvoid send_DHCP_REQUEST(void)
N{
N	int i;
N	uint8_t ip[4];
N	uint16_t k = 0;
N
N   makeDHCPMSG();
N
N   if(dhcp_state == STATE_DHCP_LEASED || dhcp_state == STATE_DHCP_REREQUEST)
X   if(dhcp_state == 3 || dhcp_state == 4)
N   {
N   	*((uint8_t*)(&pDHCPMSG->flags))   = ((DHCP_FLAGSUNICAST & 0xFF00)>> 8);
X   	*((uint8_t*)(&pDHCPMSG->flags))   = ((0x0000 & 0xFF00)>> 8);
N   	*((uint8_t*)(&pDHCPMSG->flags)+1) = (DHCP_FLAGSUNICAST & 0x00FF);
X   	*((uint8_t*)(&pDHCPMSG->flags)+1) = (0x0000 & 0x00FF);
N   	pDHCPMSG->ciaddr[0] = DHCP_allocated_ip[0];
N   	pDHCPMSG->ciaddr[1] = DHCP_allocated_ip[1];
N   	pDHCPMSG->ciaddr[2] = DHCP_allocated_ip[2];
N   	pDHCPMSG->ciaddr[3] = DHCP_allocated_ip[3];
N   	ip[0] = DHCP_SIP[0];
N   	ip[1] = DHCP_SIP[1];
N   	ip[2] = DHCP_SIP[2];
N   	ip[3] = DHCP_SIP[3];   	   	   	
N   }
N   else
N   {
N   	ip[0] = 255;
N   	ip[1] = 255;
N   	ip[2] = 255;
N   	ip[3] = 255;   	   	   	
N   }
N   
N   k = 4;      // beacaue MAGIC_COOKIE already made by makeDHCPMSG()
N	
N	// Option Request Param.
N	pDHCPMSG->OPT[k++] = dhcpMessageType;
N	pDHCPMSG->OPT[k++] = 0x01;
N	pDHCPMSG->OPT[k++] = DHCP_REQUEST;
X	pDHCPMSG->OPT[k++] = 3;
N
N	pDHCPMSG->OPT[k++] = dhcpClientIdentifier;
N	pDHCPMSG->OPT[k++] = 0x07;
N	pDHCPMSG->OPT[k++] = 0x01;
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[0];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[1];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[2];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[3];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[4];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[5];
N
N   if(ip[3] == 255)  // if(dchp_state == STATE_DHCP_LEASED || dchp_state == DHCP_REREQUEST_STATE)
N   {
N		pDHCPMSG->OPT[k++] = dhcpRequestedIPaddr;
N		pDHCPMSG->OPT[k++] = 0x04;
N		pDHCPMSG->OPT[k++] = DHCP_allocated_ip[0];
N		pDHCPMSG->OPT[k++] = DHCP_allocated_ip[1];
N		pDHCPMSG->OPT[k++] = DHCP_allocated_ip[2];
N		pDHCPMSG->OPT[k++] = DHCP_allocated_ip[3];
N	
N		pDHCPMSG->OPT[k++] = dhcpServerIdentifier;
N		pDHCPMSG->OPT[k++] = 0x04;
N		pDHCPMSG->OPT[k++] = DHCP_SIP[0];
N		pDHCPMSG->OPT[k++] = DHCP_SIP[1];
N		pDHCPMSG->OPT[k++] = DHCP_SIP[2];
N		pDHCPMSG->OPT[k++] = DHCP_SIP[3];
N	}
N
N	// host name
N	pDHCPMSG->OPT[k++] = hostName;
N	pDHCPMSG->OPT[k++] = 0; // length of hostname
N	for(i = 0 ; HOST_NAME[i] != 0; i++)
N   	pDHCPMSG->OPT[k++] = HOST_NAME[i];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[3];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[4];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[5];
N	pDHCPMSG->OPT[k - (i+3+1)] = i+3; // length of hostname
N	
N	pDHCPMSG->OPT[k++] = dhcpParamRequest;
N	pDHCPMSG->OPT[k++] = 0x08;
N	pDHCPMSG->OPT[k++] = subnetMask;
N	pDHCPMSG->OPT[k++] = routersOnSubnet;
N	pDHCPMSG->OPT[k++] = dns;
N	pDHCPMSG->OPT[k++] = domainName;
N	pDHCPMSG->OPT[k++] = dhcpT1value;
N	pDHCPMSG->OPT[k++] = dhcpT2value;
N	pDHCPMSG->OPT[k++] = performRouterDiscovery;
N	pDHCPMSG->OPT[k++] = staticRoute;
N	pDHCPMSG->OPT[k++] = endOption;
N
N	for (i = k; i < OPT_SIZE; i++) pDHCPMSG->OPT[i] = 0;
X	for (i = k; i < 312; i++) pDHCPMSG->OPT[i] = 0;
N
N#ifdef _DHCP_DEBUG_
N	printf("> Send DHCP_REQUEST\r\n");
N#endif
N	
N	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
X	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, (236+312), ip, 67);
N
N}
N
N/* SEND DHCP DHCPDECLINE */
Nvoid send_DHCP_DECLINE(void)
N{
N	int i;
N	uint8_t ip[4];
N	uint16_t k = 0;
N	
N	makeDHCPMSG();
N
N   k = 4;      // beacaue MAGIC_COOKIE already made by makeDHCPMSG()
N   
N	*((uint8_t*)(&pDHCPMSG->flags))   = ((DHCP_FLAGSUNICAST & 0xFF00)>> 8);
X	*((uint8_t*)(&pDHCPMSG->flags))   = ((0x0000 & 0xFF00)>> 8);
N	*((uint8_t*)(&pDHCPMSG->flags)+1) = (DHCP_FLAGSUNICAST & 0x00FF);
X	*((uint8_t*)(&pDHCPMSG->flags)+1) = (0x0000 & 0x00FF);
N
N	// Option Request Param.
N	pDHCPMSG->OPT[k++] = dhcpMessageType;
N	pDHCPMSG->OPT[k++] = 0x01;
N	pDHCPMSG->OPT[k++] = DHCP_DECLINE;
X	pDHCPMSG->OPT[k++] = 4;
N
N	pDHCPMSG->OPT[k++] = dhcpClientIdentifier;
N	pDHCPMSG->OPT[k++] = 0x07;
N	pDHCPMSG->OPT[k++] = 0x01;
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[0];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[1];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[2];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[3];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[4];
N	pDHCPMSG->OPT[k++] = DHCP_CHADDR[5];
N
N	pDHCPMSG->OPT[k++] = dhcpRequestedIPaddr;
N	pDHCPMSG->OPT[k++] = 0x04;
N	pDHCPMSG->OPT[k++] = DHCP_allocated_ip[0];
N	pDHCPMSG->OPT[k++] = DHCP_allocated_ip[1];
N	pDHCPMSG->OPT[k++] = DHCP_allocated_ip[2];
N	pDHCPMSG->OPT[k++] = DHCP_allocated_ip[3];
N
N	pDHCPMSG->OPT[k++] = dhcpServerIdentifier;
N	pDHCPMSG->OPT[k++] = 0x04;
N	pDHCPMSG->OPT[k++] = DHCP_SIP[0];
N	pDHCPMSG->OPT[k++] = DHCP_SIP[1];
N	pDHCPMSG->OPT[k++] = DHCP_SIP[2];
N	pDHCPMSG->OPT[k++] = DHCP_SIP[3];
N
N	pDHCPMSG->OPT[k++] = endOption;
N
N	for (i = k; i < OPT_SIZE; i++) pDHCPMSG->OPT[i] = 0;
X	for (i = k; i < 312; i++) pDHCPMSG->OPT[i] = 0;
N
N	//send broadcasting packet
N	ip[0] = 0xFF;
N	ip[1] = 0xFF;
N	ip[2] = 0xFF;
N	ip[3] = 0xFF;
N
N#ifdef _DHCP_DEBUG_
N	printf("\r\n> Send DHCP_DECLINE\r\n");
N#endif
N
N	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
X	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, (236+312), ip, 67);
N}
N
N/* PARSE REPLY pDHCPMSG */
Nint8_t parseDHCPMSG(void)
N{
N	uint8_t svr_addr[6];
N	uint16_t  svr_port;
N	uint16_t len;
N
N	uint8_t * p;
N	uint8_t * e;
N	uint8_t type;
N	uint8_t opt_len;
N   
N   if((len = getSn_RX_RSR(DHCP_SOCKET)) > 0)
N   {
N   	len = recvfrom(DHCP_SOCKET, (uint8_t *)pDHCPMSG, len, svr_addr, &svr_port);
N   #ifdef _DHCP_DEBUG_   
N      printf("DHCP message : %d.%d.%d.%d(%d) %d received. \r\n",svr_addr[0],svr_addr[1],svr_addr[2], svr_addr[3],svr_port, len);
N   #endif   
N   }
N   else return 0;
N	if (svr_port == DHCP_SERVER_PORT) {
X	if (svr_port == 67) {
N      // compare mac address
N		if ( (pDHCPMSG->chaddr[0] != DHCP_CHADDR[0]) || (pDHCPMSG->chaddr[1] != DHCP_CHADDR[1]) ||
N		     (pDHCPMSG->chaddr[2] != DHCP_CHADDR[2]) || (pDHCPMSG->chaddr[3] != DHCP_CHADDR[3]) ||
N		     (pDHCPMSG->chaddr[4] != DHCP_CHADDR[4]) || (pDHCPMSG->chaddr[5] != DHCP_CHADDR[5])   )
N         return 0;
N      type = 0;
N		p = (uint8_t *)(&pDHCPMSG->op);
N		p = p + 240;      // 240 = sizeof(RIP_MSG) + MAGIC_COOKIE size in RIP_MSG.opt - sizeof(RIP_MSG.opt)
N		e = p + (len - 240);
N
N		while ( p < e ) {
N
N			switch ( *p ) {
N
N   			case endOption :
N   			   p = e;   // for break while(p < e)
N   				break;
N            case padOption :
N   				p++;
N   				break;
N   			case dhcpMessageType :
N   				p++;
N   				p++;
N   				type = *p++;
N   				break;
N   			case subnetMask :
N   				p++;
N   				p++;
N   				DHCP_allocated_sn[0] = *p++;
N   				DHCP_allocated_sn[1] = *p++;
N   				DHCP_allocated_sn[2] = *p++;
N   				DHCP_allocated_sn[3] = *p++;
N   				break;
N   			case routersOnSubnet :
N   				p++;
N   				opt_len = *p++;       
N   				DHCP_allocated_gw[0] = *p++;
N   				DHCP_allocated_gw[1] = *p++;
N   				DHCP_allocated_gw[2] = *p++;
N   				DHCP_allocated_gw[3] = *p++;
N   				p = p + (opt_len - 4);
N   				break;
N   			case dns :
N   				p++;                  
N   				opt_len = *p++;       
N   				DHCP_allocated_dns[0] = *p++;
N   				DHCP_allocated_dns[1] = *p++;
N   				DHCP_allocated_dns[2] = *p++;
N   				DHCP_allocated_dns[3] = *p++;
N   				p = p + (opt_len - 4);
N   				break;
N   			case dhcpIPaddrLeaseTime :
N   				p++;
N   				opt_len = *p++;
N   				dhcp_lease_time  = *p++;
N   				dhcp_lease_time  = (dhcp_lease_time << 8) + *p++;
N   				dhcp_lease_time  = (dhcp_lease_time << 8) + *p++;
N   				dhcp_lease_time  = (dhcp_lease_time << 8) + *p++;
N            #ifdef _DHCP_DEBUG_  
N               //dhcp_lease_time = 10;
N 				#endif
N   				break;
N   			case dhcpServerIdentifier :
N   				p++;
N   				opt_len = *p++;
N   				DHCP_SIP[0] = *p++;
N   				DHCP_SIP[1] = *p++;
N   				DHCP_SIP[2] = *p++;
N   				DHCP_SIP[3] = *p++;
N   				break;
N   			default :
N   				p++;
N   				opt_len = *p++;
N   				p += opt_len;
N   				break;
N			} // switch
N		} // while
N	} // if
N	return	type;
N}
N
Nuint8_t DHCP_run(void)
N{
N	uint8_t  type;
N	uint8_t  ret;
N
N	if(dhcp_state == STATE_DHCP_STOP) return DHCP_STOPPED;
X	if(dhcp_state == 6) return DHCP_STOPPED;
N
N	if(getSn_SR(DHCP_SOCKET) != SOCK_UDP)
X	if(WIZCHIP_READ((0x00000000 + (0x0003 << 8) + ((1+4*DHCP_SOCKET) << 3))) != 0x22)
N	   socket(DHCP_SOCKET, Sn_MR_UDP, DHCP_CLIENT_PORT, 0x00);
X	   socket(DHCP_SOCKET, 0x02, 68, 0x00);
N
N	ret = DHCP_RUNNING;
N	type = parseDHCPMSG();
N
N	switch ( dhcp_state ) {
N	   case STATE_DHCP_INIT     :
X	   case 0     :
N         DHCP_allocated_ip[0] = 0;
N         DHCP_allocated_ip[1] = 0;
N         DHCP_allocated_ip[2] = 0;
N         DHCP_allocated_ip[3] = 0;
N   		send_DHCP_DISCOVER();
N   		dhcp_state = STATE_DHCP_DISCOVER;
X   		dhcp_state = 1;
N   		break;
N		case STATE_DHCP_DISCOVER :
X		case 1 :
N			if (type == DHCP_OFFER){
X			if (type == 2){
N#ifdef _DHCP_DEBUG_
N				printf("> Receive DHCP_OFFER\r\n");
N#endif
N            DHCP_allocated_ip[0] = pDHCPMSG->yiaddr[0];
N            DHCP_allocated_ip[1] = pDHCPMSG->yiaddr[1];
N            DHCP_allocated_ip[2] = pDHCPMSG->yiaddr[2];
N            DHCP_allocated_ip[3] = pDHCPMSG->yiaddr[3];
N
N				send_DHCP_REQUEST();
N				dhcp_state = STATE_DHCP_REQUEST;
X				dhcp_state = 2;
N			} else ret = check_DHCP_timeout();
N         break;
N
N		case STATE_DHCP_REQUEST :
X		case 2 :
N			if (type == DHCP_ACK) {
X			if (type == 5) {
N
N#ifdef _DHCP_DEBUG_
N				printf("> Receive DHCP_ACK\r\n");
N#endif
N				if (check_DHCP_leasedIP()) {
N					// Network info assignment from DHCP
N					dhcp_ip_assign();
N					reset_DHCP_timeout();
N
N					dhcp_state = STATE_DHCP_LEASED;
X					dhcp_state = 3;
N				} else {
N					// IP address conflict occurred
N					reset_DHCP_timeout();
N					dhcp_ip_conflict();
N				    dhcp_state = STATE_DHCP_INIT;
X				    dhcp_state = 0;
N				}
N			} else if (type == DHCP_NAK) {
X			} else if (type == 6) {
N
N#ifdef _DHCP_DEBUG_
N				printf("> Receive DHCP_NACK\r\n");
N#endif
N
N				reset_DHCP_timeout();
N
N				dhcp_state = STATE_DHCP_DISCOVER;
X				dhcp_state = 1;
N			} else ret = check_DHCP_timeout();
N		break;
N
N		case STATE_DHCP_LEASED :
X		case 3 :
N		   ret = DHCP_IP_LEASED;
N			if ((dhcp_lease_time != INFINITE_LEASETIME) && ((dhcp_lease_time/2) < dhcp_tick_1s)) {
X			if ((dhcp_lease_time != 0xffffffff) && ((dhcp_lease_time/2) < dhcp_tick_1s)) {
N				
N#ifdef _DHCP_DEBUG_
N 				printf("> Maintains the IP address \r\n");
N#endif
N
N				type = 0;
N				OLD_allocated_ip[0] = DHCP_allocated_ip[0];
N				OLD_allocated_ip[1] = DHCP_allocated_ip[1];
N				OLD_allocated_ip[2] = DHCP_allocated_ip[2];
N				OLD_allocated_ip[3] = DHCP_allocated_ip[3];
N				
N				DHCP_XID++;
N
N				send_DHCP_REQUEST();
N
N				reset_DHCP_timeout();
N
N				dhcp_state = STATE_DHCP_REREQUEST;
X				dhcp_state = 4;
N			}
N		break;
N
N		case STATE_DHCP_REREQUEST :
X		case 4 :
N		   ret = DHCP_IP_LEASED;
N			if (type == DHCP_ACK) {
X			if (type == 5) {
N				dhcp_retry_count = 0;
N				if (OLD_allocated_ip[0] != DHCP_allocated_ip[0] || 
N				    OLD_allocated_ip[1] != DHCP_allocated_ip[1] ||
N				    OLD_allocated_ip[2] != DHCP_allocated_ip[2] ||
N				    OLD_allocated_ip[3] != DHCP_allocated_ip[3]) 
N				{
N					ret = DHCP_IP_CHANGED;
N					dhcp_ip_update();
N               #ifdef _DHCP_DEBUG_
N                  printf(">IP changed.\r\n");
N               #endif
N					
N				}
N         #ifdef _DHCP_DEBUG_
N            else printf(">IP is continued.\r\n");
N         #endif            				
N				reset_DHCP_timeout();
N				dhcp_state = STATE_DHCP_LEASED;
X				dhcp_state = 3;
N			} else if (type == DHCP_NAK) {
X			} else if (type == 6) {
N
N#ifdef _DHCP_DEBUG_
N				printf("> Receive DHCP_NACK, Failed to maintain ip\r\n");
N#endif
N
N				reset_DHCP_timeout();
N
N				dhcp_state = STATE_DHCP_DISCOVER;
X				dhcp_state = 1;
N			} else ret = check_DHCP_timeout();
N	   	break;
N		default :
N   		break;
N	}
N
N	return ret;
N}
N
Nvoid    DHCP_stop(void)
N{
N   close(DHCP_SOCKET);
N   dhcp_state = STATE_DHCP_STOP;
X   dhcp_state = 6;
N}
N
Nuint8_t check_DHCP_timeout(void)
N{
N	uint8_t ret = DHCP_RUNNING;
N	
N	if (dhcp_retry_count < MAX_DHCP_RETRY) {
X	if (dhcp_retry_count < 20) {
N		//if (dhcp_tick_next < dhcp_tick_1s) {
N
N			switch ( dhcp_state ) {
N				case STATE_DHCP_DISCOVER :
X				case 1 :
N//					printf("<<timeout>> state : STATE_DHCP_DISCOVER\r\n");
N					send_DHCP_DISCOVER();
N				break;
N		
N				case STATE_DHCP_REQUEST :
X				case 2 :
N//					printf("<<timeout>> state : STATE_DHCP_REQUEST\r\n");
N
N					send_DHCP_REQUEST();
N				break;
N
N				case STATE_DHCP_REREQUEST :
X				case 4 :
N//					printf("<<timeout>> state : STATE_DHCP_REREQUEST\r\n");
N					
N					send_DHCP_REQUEST();
N				break;
N		
N				default :
N				break;
N	//		}
N
W "..\..\Internet\DHCP\dhcp.c" 835 4 statement is unreachable
N			dhcp_tick_1s = 0;
N			dhcp_tick_next = dhcp_tick_1s + DHCP_WAIT_TIME;
X			dhcp_tick_next = dhcp_tick_1s + 10;
N			dhcp_retry_count++;
N		}
N	} else { // timeout occurred
N
N		switch(dhcp_state) {
N			case STATE_DHCP_DISCOVER:
X			case 1:
N				dhcp_state = STATE_DHCP_INIT;
X				dhcp_state = 0;
N				ret = DHCP_FAILED;
N				break;
N			case STATE_DHCP_REQUEST:
X			case 2:
N			case STATE_DHCP_REREQUEST:
X			case 4:
N				send_DHCP_DISCOVER();
N				dhcp_state = STATE_DHCP_DISCOVER;
X				dhcp_state = 1;
N				break;
N			default :
N				break;
N		}
N		reset_DHCP_timeout();
N	}
N	return ret;
N}
N
Nint8_t check_DHCP_leasedIP(void)
N{
N	uint8_t tmp;
N	int32_t ret;
N
N	//WIZchip RCR value changed for ARP Timeout count control
N	tmp = getRCR();
X	tmp = WIZCHIP_READ((0x00000000 + (0x001B << 8) + (0x00 << 3)));
N	setRCR(0x03);
X	WIZCHIP_WRITE((0x00000000 + (0x001B << 8) + (0x00 << 3)), 0x03);
N
N	// IP conflict detection : ARP request - ARP reply
N	// Broadcasting ARP Request for check the IP conflict using UDP sendto() function
N	ret = sendto(DHCP_SOCKET, (uint8_t *)"CHECK_IP_CONFLICT", 17, DHCP_allocated_ip, 5000);
N
N	// RCR value restore
N	setRCR(tmp);
X	WIZCHIP_WRITE((0x00000000 + (0x001B << 8) + (0x00 << 3)), tmp);
N
N	if(ret == SOCKERR_TIMEOUT) {
X	if(ret == (0 - 13)) {
N		// UDP send Timeout occurred : allocated IP address is unique, DHCP Success
N
N#ifdef _DHCP_DEBUG_
N		printf("\r\n> Check leased IP - OK\r\n");
N#endif
N
N		return 1;
N	} else {
N		// Received ARP reply or etc : IP address conflict occur, DHCP Failed
N		send_DHCP_DECLINE();
N
N		ret = dhcp_tick_1s;
N		while((dhcp_tick_1s - ret) < 2) ;   // wait for 1s over; wait to complete to send DECLINE message;
N
N		return 0;
N	}
N}	
N
Nvoid DHCP_init(uint8_t s, uint8_t * buf)
N{
N   uint8_t zeroip[4] = {0,0,0,0};
N   getSHAR(DHCP_CHADDR);
X   WIZCHIP_READ_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), DHCP_CHADDR, 6);
N   if((DHCP_CHADDR[0] | DHCP_CHADDR[1]  | DHCP_CHADDR[2] | DHCP_CHADDR[3] | DHCP_CHADDR[4] | DHCP_CHADDR[5]) == 0x00)
N   {
N      // assing temporary mac address, you should be set SHAR before call this function. 
N      DHCP_CHADDR[0] = 0x00;
N      DHCP_CHADDR[1] = 0x08;
N      DHCP_CHADDR[2] = 0xdc;      
N      DHCP_CHADDR[3] = 0x00;
N      DHCP_CHADDR[4] = 0x00;
N      DHCP_CHADDR[5] = 0x00; 
N      setSHAR(DHCP_CHADDR);     
X      WIZCHIP_WRITE_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), DHCP_CHADDR, 6);     
N   }
N
N	DHCP_SOCKET = s; // SOCK_DHCP
N	pDHCPMSG = (RIP_MSG*)buf;
N	DHCP_XID = 0x12345678;
N
N	// WIZchip Netinfo Clear
N	setSIPR(zeroip);
X	WIZCHIP_WRITE_BUF((0x00000000 + (0x000F << 8) + (0x00 << 3)), zeroip, 4);
N	setSIPR(zeroip);
X	WIZCHIP_WRITE_BUF((0x00000000 + (0x000F << 8) + (0x00 << 3)), zeroip, 4);
N	setGAR(zeroip);
X	WIZCHIP_WRITE_BUF((0x00000000 + (0x0001 << 8) + (0x00 << 3)),zeroip,4);
N
N	reset_DHCP_timeout();
N	dhcp_state = STATE_DHCP_INIT;
X	dhcp_state = 0;
N}
N
N
N/* Rset the DHCP timeout count and retry count. */
Nvoid reset_DHCP_timeout(void)
N{
N	dhcp_tick_1s = 0;
N	dhcp_tick_next = DHCP_WAIT_TIME;
X	dhcp_tick_next = 10;
N	dhcp_retry_count = 0;
N}
N
Nvoid DHCP_time_handler(void)
N{
N	dhcp_tick_1s++;
N}
N
Nvoid getIPfromDHCP(uint8_t* ip)
N{
N	ip[0] = DHCP_allocated_ip[0];
N	ip[1] = DHCP_allocated_ip[1];
N	ip[2] = DHCP_allocated_ip[2];	
N	ip[3] = DHCP_allocated_ip[3];
N}
N
Nvoid getGWfromDHCP(uint8_t* ip)
N{
N	ip[0] =DHCP_allocated_gw[0];
N	ip[1] =DHCP_allocated_gw[1];
N	ip[2] =DHCP_allocated_gw[2];
N	ip[3] =DHCP_allocated_gw[3];			
N}
N
Nvoid getSNfromDHCP(uint8_t* ip)
N{
N   ip[0] = DHCP_allocated_sn[0];
N   ip[1] = DHCP_allocated_sn[1];
N   ip[2] = DHCP_allocated_sn[2];
N   ip[3] = DHCP_allocated_sn[3];         
N}
N
Nvoid getDNSfromDHCP(uint8_t* ip)
N{
N   ip[0] = DHCP_allocated_dns[0];
N   ip[1] = DHCP_allocated_dns[1];
N   ip[2] = DHCP_allocated_dns[2];
N   ip[3] = DHCP_allocated_dns[3];         
N}
N
Nuint32_t getDHCPLeasetime(void)
N{
N	return dhcp_lease_time;
N}
N
N
N
N
