L 1 "..\..\Internet\DNS\dns.c"
N//*****************************************************************************
N//
N//! \file dns.c
N//! \brief DNS APIs Implement file.
N//! \details Send DNS query & Receive DNS reponse.  \n
N//!          It depends on stdlib.h & string.h in ansi-c library
N//! \version 1.1.0
N//! \date 2013/11/18
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//!       <2013/12/20> V1.1.0
N//!         1. Remove secondary DNS server in DNS_run
N//!            If 1st DNS_run failed, call DNS_run with 2nd DNS again
N//!         2. DNS_timerHandler -> DNS_time_handler
N//!         3. Remove the unused define
N//!         4. Integrated dns.h dns.c & dns_parse.h dns_parse.c into dns.h & dns.c
N//!       <2013/12/20> V1.1.0
N//!
N//! \author Eric Jung & MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#include <string.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 53 "..\..\Internet\DNS\dns.c" 2
N#include <stdlib.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 54 "..\..\Internet\DNS\dns.c" 2
N
N#include "socket.h"
L 1 "..\..\Ethernet\socket.h" 1
N//*****************************************************************************
N//
N//! \file socket.h
N//! \brief SOCKET APIs Header file.
N//! \details SOCKET APIs like as berkeley socket api. 
N//! \version 1.0.2
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2014/05/01> V1.0.2. Refer to M20140501
N//!         1. Modify the comment : SO_REMAINED -> PACK_REMAINED
N//!         2. Add the comment as zero byte udp data reception in getsockopt(). 
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N/**
N * @defgroup WIZnet_socket_APIs 1. WIZnet socket APIs
N * @brief WIZnet socket APIs are based on Berkeley socket APIs,  thus it has much similar name and interface.
N *        But there is a little bit of difference.
N * @details
N * <b> Comparison between WIZnet and Berkeley SOCKET APIs </b>
N * <table>
N *    <tr>   <td><b>API</b></td> <td><b>WIZnet</b></td> <td><b>Berkeley</b></td>   </tr>
N *    <tr>   <td>socket()</td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>bind()</b></td> <td>X</td> <td>O</td>   </tr>
N *    <tr>   <td><b>listen()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>connect()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>accept()</b></td> <td>X</td> <td>O</td>   </tr>
N *    <tr>   <td><b>recv()</b></td> <td>O</td> <td>O</td>    </tr>
N *    <tr>   <td><b>send()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>recvfrom()</b></td> <td>O</td> <td>O</td>   </tr>
N *    <tr>   <td><b>sendto()</b></td> <td>O</td> <td>O</td>    </tr>
N *    <tr>   <td><b>closesocket()</b></td> <td>O<br>close() & disconnect()</td> <td>O</td>   </tr>
N * </table>
N * There are @b bind() and @b accept() functions in @b Berkeley SOCKET API but,
N * not in @b WIZnet SOCKET API. Because socket() of WIZnet is not only creating a SOCKET but also binding a local port number,
N * and listen() of WIZnet is not only listening to connection request from client but also accepting the connection request. \n
N * When you program "TCP SERVER" with Berkeley SOCKET API, you can use only one listen port.
N * When the listen SOCKET accepts a connection request from a client, it keeps listening.
N * After accepting the connection request, a new SOCKET is created and the new SOCKET is used in communication with the client. \n
N * Following figure shows network flow diagram by Berkeley SOCKET API.
N * @image html Berkeley_SOCKET.jpg "<Berkeley SOCKET API>"
N * But, When you program "TCP SERVER" with WIZnet SOCKET API, you can use as many as 8 listen SOCKET with same port number. \n
N * Because there's no accept() in WIZnet SOCKET APIs, when the listen SOCKET accepts a connection request from a client,
N * it is changed in order to communicate with the client.
N * And the changed SOCKET is not listening any more and is dedicated for communicating with the client. \n
N * If there're many listen SOCKET with same listen port number and a client requests a connection,
N * the SOCKET which has the smallest SOCKET number accepts the request and is changed as communication SOCKET. \n
N * Following figure shows network flow diagram by WIZnet SOCKET API.
N * @image html WIZnet_SOCKET.jpg "<WIZnet SOCKET API>"
N */
N#ifndef _SOCKET_H_
N#define _SOCKET_H_
N
N#include "wizchip_conf.h"
L 1 "..\..\Ethernet\wizchip_conf.h" 1
N//*****************************************************************************
N//
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. It could be replaced at WIZCHIP I/O function because they were made by WIZCHIP I/O functions.  
N * @details There are functions of configuring WIZCHIP, network, interrupt, phy, network information and timer. \n
N * 
N */
N
N#ifndef  _WIZCHIP_CONF_H_
N#define  _WIZCHIP_CONF_H_
N
N#include <stdint.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 54 "..\..\Ethernet\wizchip_conf.h" 2
N/**
N * @brief Select WIZCHIP.
N * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
N *       ex> <code> #define \_WIZCHIP_      5500 </code>
N */
N#define _WIZCHIP_                      5500   // 5100, 5200, 5500
N
N#define _WIZCHIP_IO_MODE_NONE_         0x0000
N#define _WIZCHIP_IO_MODE_BUS_          0x0100 /**< Bus interface mode */
N#define _WIZCHIP_IO_MODE_SPI_          0x0200 /**< SPI interface mode */
N//#define _WIZCHIP_IO_MODE_IIC_          0x0400
N//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
N// Add to
N//
N
N#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) /**< BUS interface mode for direct  */
N#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) /**< BUS interface mode for indirect */
N
N#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
N#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
N
N
N#if   (_WIZCHIP_ == 5100)
X#if   (5500 == 5100)
S   #define _WIZCHIP_ID_                "W5100\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S
S#elif (_WIZCHIP_ == 5200)
X#elif (5500 == 5200)
S   #define _WIZCHIP_ID_                "W5200\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S   #include "W5200/w5200.h"
N#elif (_WIZCHIP_ == 5500)
X#elif (5500 == 5500)
N  #define _WIZCHIP_ID_                 "W5500\0"
N  
N/**
N * @brief Define interface mode. \n
N * @todo Should select interface mode as chip. 
N *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
N *        - Others will be defined in future. \n\n
N *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
N *       
N */
N   //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
N   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
N   #include "W5500/w5500.h"
L 1 "..\..\Ethernet\W5500/w5500.h" 1
N//*****************************************************************************
N//
N//! \file w5500.h
N//! \brief W5500 HAL Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#ifndef  _W5500_H_
N#define  _W5500_H_
N
N#include <stdint.h>
N#include "wizchip_conf.h"
L 1 "..\..\Ethernet\wizchip_conf.h" 1
N//*****************************************************************************
N//
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. It could be replaced at WIZCHIP I/O function because they were made by WIZCHIP I/O functions.  
N * @details There are functions of configuring WIZCHIP, network, interrupt, phy, network information and timer. \n
N * 
N */
N
N#ifndef  _WIZCHIP_CONF_H_
S#define  _WIZCHIP_CONF_H_
S
S#include <stdint.h>
S/**
S * @brief Select WIZCHIP.
S * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
S *       ex> <code> #define \_WIZCHIP_      5500 </code>
S */
S#define _WIZCHIP_                      5500   // 5100, 5200, 5500
S
S#define _WIZCHIP_IO_MODE_NONE_         0x0000
S#define _WIZCHIP_IO_MODE_BUS_          0x0100 /**< Bus interface mode */
S#define _WIZCHIP_IO_MODE_SPI_          0x0200 /**< SPI interface mode */
S//#define _WIZCHIP_IO_MODE_IIC_          0x0400
S//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
S// Add to
S//
S
S#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) /**< BUS interface mode for direct  */
S#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) /**< BUS interface mode for indirect */
S
S#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
S#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
S
S
S#if   (_WIZCHIP_ == 5100)
S   #define _WIZCHIP_ID_                "W5100\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S
S#elif (_WIZCHIP_ == 5200)
S   #define _WIZCHIP_ID_                "W5200\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S   #include "W5200/w5200.h"
S#elif (_WIZCHIP_ == 5500)
S  #define _WIZCHIP_ID_                 "W5500\0"
S  
S/**
S * @brief Define interface mode. \n
S * @todo Should select interface mode as chip. 
S *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
S *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
S *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
S *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
S *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
S *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
S *        - Others will be defined in future. \n\n
S *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
S *       
S */
S   //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
S   #include "W5500/w5500.h"
S#else 
S   #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
S#endif
S
S#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
S#endif
S
S/**
S * @brief Define I/O base address when BUS IF mode.
S * @todo Should re-define it to fit your system when BUS IF Mode (@ref \_WIZCHIP_IO_MODE_BUS_,
S *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
S *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
S */
S#define _WIZCHIP_IO_BASE_              0x00000000  // 
S
S#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
S   #ifndef _WIZCHIP_IO_BASE_
S      #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
S   #endif
S#endif   
S
S#if _WIZCHIP_ > 5100
S   #define _WIZCHIP_SOCK_NUM_   8   ///< The count of independant socket of @b WIZCHIP
S#else
S   #define _WIZCHIP_SOCK_NUM_   4   ///< The count of independant socket of @b WIZCHIP
S#endif      
S
S
S/********************************************************
S* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
S*********************************************************/
S/**
S * @ingroup DATA_TYPE
S * @brief The set of callback functions for W5500:@ref WIZCHIP_IO_Functions W5200:@ref WIZCHIP_IO_Functions_W5200
S */
Stypedef struct __WIZCHIP
S{
S   uint16_t  if_mode;               ///< host interface mode
S   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
S   /**
S    * The set of critical section callback func.
S    */
S   struct _CRIS
S   {
S      void (*_enter)  (void);       ///< crtical section enter 
S      void (*_exit) (void);         ///< critial section exit  
S   }CRIS;  
S   /**
S    *  The set of @ref\_WIZCHIP_ select control callback func.
S    */
S   struct _CS
S   {
S      void (*_select)  (void);      ///< @ref \_WIZCHIP_ selected
S      void (*_deselect)(void);      ///< @ref \_WIZCHIP_ deselected
S   }CS;  
S   /**
S    * The set of interface IO callback func.
S    */
S   union _IF
S   {	 
S      /**
S       * For BUS interface IO
S       */  
S      struct
S      {
S         uint8_t  (*_read_byte)  (uint32_t AddrSel);
S         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
S      }BUS;      
S      /**
S       * For SPI interface IO
S       */
S      struct
S      {
S         uint8_t (*_read_byte)   (void);
S         void    (*_write_byte)  (uint8_t wb);
S      }SPI;
S      // To be added
S      //
S   }IF;
S}_WIZCHIP;
S
Sextern _WIZCHIP  WIZCHIP;
S
S/**
S * @ingroup DATA_TYPE
S *  WIZCHIP control type enumration used in @ref ctlwizchip().
S */
Stypedef enum
S{
S   CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
S   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
S   CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
S   CW_CLR_INTERRUPT,   ///< Clears interrupt
S   CW_SET_INTRMASK,    ///< Masks interrupt
S   CW_GET_INTRMASK,    ///< Get interrupt mask
S   CW_SET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
S   CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
S   CW_GET_ID,          ///< Gets WIZCHIP name.
S
S#if _WIZCHIP_ ==  5500
S   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
S   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
S   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
S   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
S   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
S#endif
S   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
S   CW_GET_PHYLINK      ///< Get PHY Link status
S}ctlwizchip_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Network control type enumration used in @ref ctlnetwork().
S */
Stypedef enum
S{
S   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
S   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
S   CN_SET_NETMODE,  ///< Set network mode as WOL, PPPoE, Ping Block, and Force ARP mode
S   CN_GET_NETMODE,  ///< Get network mode as WOL, PPPoE, Ping Block, and Force ARP mode
S   CN_SET_TIMEOUT,  ///< Set network timeout as retry count and time.
S   CN_GET_TIMEOUT,  ///< Get network timeout as retry count and time.
S}ctlnetwork_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Interrupt kind when CW_SET_INTRRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK
S *  and CW_GET_INTRMASK is used in @ref ctlnetwork().
S *  It can be used with OR operation.
S */
Stypedef enum
S{
S#if _WIZCHIP_ > 5200
S   IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
S#endif   
S
S   IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
S
S#if _WIZCHIP_ != 5200
S   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
S#endif   
S
S   IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
S
S   IK_SOCK_0            = (1 << 8),   ///< Socket 0 interrupt
S   IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
S   IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
S   IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
S#if _WIZCHIP_ > 5100   
S   IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
S   IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
S   IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
S   IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
S#endif   
S
S#if _WIZCHIP_ > 5100
S   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
S#else
S   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
S#endif      
S}intr_kind;
S
S#define PHY_CONFBY_HW            0     ///< Configured PHY operation mode by HW pin
S#define PHY_CONFBY_SW            1     ///< Configured PHY operation mode by SW register   
S#define PHY_MODE_MANUAL          0     ///< Configured PHY operation mode with user setting.
S#define PHY_MODE_AUTONEGO        1     ///< Configured PHY operation mode with auto-negotiation
S#define PHY_SPEED_10             0     ///< Link Speed 10
S#define PHY_SPEED_100            1     ///< Link Speed 100
S#define PHY_DUPLEX_HALF          0     ///< Link Half-Duplex
S#define PHY_DUPLEX_FULL          1     ///< Link Full-Duplex
S#define PHY_LINK_OFF             0     ///< Link Off
S#define PHY_LINK_ON              1     ///< Link On
S#define PHY_POWER_NORM           0     ///< PHY power normal mode
S#define PHY_POWER_DOWN           1     ///< PHY power down mode 
S
S
S#if _WIZCHIP_ == 5500 
S/**
S * @ingroup DATA_TYPE
S *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
S *  and it indicates the real PHY status configured by HW or SW in all WIZCHIP. \n
S *  Valid only in W5500.
S */
Stypedef struct wiz_PhyConf_t
S{
S      uint8_t by;       ///< set by @ref PHY_CONFBY_HW or @ref PHY_CONFBY_SW
S      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL or @ref PHY_MODE_AUTONEGO
S      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
S      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
S      //uint8_t power;  ///< set by @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
S      //uint8_t link;   ///< Valid only in CW_GET_PHYSTATUS. set by @ref PHY_LINK_ON or PHY_DUPLEX_OFF 
S   }wiz_PhyConf;
S#endif   
S
S/**
S * @ingroup DATA_TYPE
S *  It used in setting dhcp_mode of @ref wiz_NetInfo.
S */
Stypedef enum
S{
S   NETINFO_STATIC = 1,    ///< Static IP configuration by manually.
S   NETINFO_DHCP           ///< Dynamic IP configruation from a DHCP sever
S}dhcp_mode;
S
S/**
S * @ingroup DATA_TYPE
S *  Network Information for WIZCHIP
S */
Stypedef struct wiz_NetInfo_t
S{
S   uint8_t mac[6];  ///< Source Mac Address
S   uint8_t ip[4];   ///< Source IP Address
S   uint8_t sn[4];   ///< Subnet Mask 
S   uint8_t gw[4];   ///< Gateway IP Address
S   uint8_t dns[4];  ///< DNS server IP Address
S   dhcp_mode dhcp;  ///< 1 - Static, 2 - DHCP
S}wiz_NetInfo;
S
S/**
S * @ingroup DATA_TYPE
S *  Network mode
S */
Stypedef enum
S{
S#if _WIZCHIP_ == 5500   
S   NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
S#endif   
S   NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
S   NM_PINGBLOCK   = (1<<4),  ///< Block ping-request
S   NM_PPPOE       = (1<<3),  ///< PPPoE mode
S}netmode_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Used in CN_SET_TIMEOUT or CN_GET_TIMEOUT of @ref ctlwizchip() for timeout configruation.
S */
Stypedef struct wiz_NetTimeout_t
S{
S   uint8_t  retry_cnt;     ///< retry count 
S   uint16_t time_100us;    ///< time unit 100us
S}wiz_NetTimeout;
S
S/**
S *@brief Registers call back function for critical section of I/O functions such as
S *\ref WIZCHIP_READ, @ref WIZCHIP_WRITE, @ref WIZCHIP_READ_BUF and @ref WIZCHIP_WRITE_BUF.
S *@param cris_en : callback function for critical section enter.
S *@param cris_ex : callback function for critical section exit.
S *@todo Describe @ref WIZCHIP_CRITICAL_ENTER and @ref WIZCHIP_CRITICAL_EXIT marco or register your functions.
S *@note If you do not describe or register, default functions(@ref wizchip_cris_enter & @ref wizchip_cris_exit) is called.
S */
Svoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
S
S
S/**
S *@brief Registers call back function for WIZCHIP select & deselect.
S *@param cs_sel : callback function for WIZCHIP select
S *@param cs_desel : callback fucntion for WIZCHIP deselect
S *@todo Describe @ref wizchip_cs_select and @ref wizchip_cs_deselect function or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
S
S/**
S *@brief Registers call back function for bus interface.
S *@param bus_rb   : callback function to read byte data using system bus
S *@param bus_wb   : callback function to write byte data using system bus
S *@todo Describe @ref wizchip_bus_readbyte and @ref wizchip_bus_writebyte function
S *or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
S
S/**
S *@brief Registers call back function for SPI interface.
S *@param spi_rb : callback function to read byte usig SPI 
S *@param spi_wb : callback function to write byte usig SPI 
S *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
S *or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb));
S
S/**
S * @ingroup extra_functions
S * @brief Controls to the WIZCHIP.
S * @details Resets WIZCHIP & internal PHY, Configures PHY mode, Monitor PHY(Link,Speed,Half/Full/Auto),
S * controls interrupt & mask and so on.
S * @param cwtype : Decides to the control type
S * @param arg : arg type is dependent on cwtype.
S * @return  0 : Success \n
S *         -1 : Fail because of invalid \ref ctlwizchip_type or unsupported \ref ctlwizchip_type in WIZCHIP 
S */          
Sint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
S
S/**
S * @ingroup extra_functions
S * @brief Controls to network.
S * @details Controls to network environment, mode, timeout and so on.
S * @param cntype : Input. Decides to the control type
S * @param arg : Inout. arg type is dependent on cntype.
S * @return -1 : Fail because of invalid \ref ctlnetwork_type or unsupported \ref ctlnetwork_type in WIZCHIP \n
S *          0 : Success      
S */          
Sint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
S
S
S/* 
S * The following functions are implemented for internal use. 
S * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
S */
S 
S/**
S * @ingroup extra_functions
S * @brief Reset WIZCHIP by softly.
S */ 
Svoid   wizchip_sw_reset(void);
S
S/**
S * @ingroup extra_functions
S * @brief Initializes WIZCHIP with socket buffer size
S * @param txsize Socket tx buffer sizes. If null, initialized the default size 2KB.
S * @param rxsize Socket rx buffer sizes. If null, initialized the default size 2KB.
S * @return 0 : succcess \n
S *        -1 : fail. Invalid buffer size
S */
Sint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
S
S/** 
S * @ingroup extra_functions
S * @brief Clear Interrupt of WIZCHIP.
S * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Svoid wizchip_clrinterrupt(intr_kind intr);
S
S/** 
S * @ingroup extra_functions
S * @brief Get Interrupt of WIZCHIP.
S * @return @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Sintr_kind wizchip_getinterrupt(void);
S
S/** 
S * @ingroup extra_functions
S * @brief Mask or Unmask Interrupt of WIZCHIP.
S * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Svoid wizchip_setinterruptmask(intr_kind intr);
S
S/** 
S * @ingroup extra_functions
S * @brief Get Interrupt mask of WIZCHIP.
S * @return : The operated OR vaule of @ref intr_kind. It can type-cast to uint16_t.
S */
Sintr_kind wizchip_getinterruptmask(void);
S
S#if _WIZCHIP_ > 5100
S   int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
S   int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
S#endif
S
S#if _WIZCHIP_ == 5500
S   void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
S/**
S * @ingroup extra_functions
S * @brief Set the phy information for WIZCHIP without power mode
S * @param phyconf : @ref wiz_PhyConf
S */
S   void   wizphy_setphyconf(wiz_PhyConf* phyconf);  
S /**
S * @ingroup extra_functions
S * @brief Get phy configuration information.
S * @param phyconf : @ref wiz_PhyConf
S */
S   void   wizphy_getphyconf(wiz_PhyConf* phyconf); 
S /**
S * @ingroup extra_functions
S * @brief Get phy status.
S * @param phyconf : @ref wiz_PhyConf
S */ 
S   void   wizphy_getphystat(wiz_PhyConf* phyconf);
S /**
S * @ingroup extra_functions
S * @brief set the power mode of phy inside WIZCHIP. Refer to @ref PHYCFGR in W5500, @ref PHYSTATUS in W5200
S * @param pmode Settig value of power down mode.
S */   
S   int8_t wizphy_setphypmode(uint8_t pmode);    
S#endif
S
S/**
S* @ingroup extra_functions
S * @brief Set the network information for WIZCHIP
S * @param pnetinfo : @ref wizNetInfo
S */
Svoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
S
S/**
S * @ingroup extra_functions
S * @brief Get the network information for WIZCHIP
S * @param pnetinfo : @ref wizNetInfo
S */
Svoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
S
S/**
S * @ingroup extra_functions
S * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
S * @param pnetinfo Value of network mode. Refer to @ref netmode_type.
S */
Sint8_t wizchip_setnetmode(netmode_type netmode);
S
S/**
S * @ingroup extra_functions
S * @brief Get the network mode such WOL, PPPoE, Ping Block, and etc. 
S * @return Value of network mode. Refer to @ref netmode_type.
S */
Snetmode_type wizchip_getnetmode(void);
S
S/**
S * @ingroup extra_functions
S * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
S * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
S * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
S */
Svoid wizchip_settimeout(wiz_NetTimeout* nettime);
S
S/**
S * @ingroup extra_functions
S * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
S * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
S * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
S */
Svoid wizchip_gettimeout(wiz_NetTimeout* nettime);
S
N#endif   // _WIZCHIP_CONF_H_
L 47 "..\..\Ethernet\W5500/w5500.h" 2
N
N#define _W5500_IO_BASE_              0x00000000
N
N#define _W5500_SPI_READ_			   (0x00 << 2) //< SPI interface Read operation in Control Phase
N#define _W5500_SPI_WRITE_			   (0x01 << 2) //< SPI interface Write operation in Control Phase
N
N#define WIZCHIP_CREG_BLOCK          0x00 	//< Common register block
N#define WIZCHIP_SREG_BLOCK(N)       (1+4*N) //< Socket N register block
N#define WIZCHIP_TXBUF_BLOCK(N)      (2+4*N) //< Socket N Tx buffer address block
N#define WIZCHIP_RXBUF_BLOCK(N)      (3+4*N) //< Socket N Rx buffer address block
N
N#define WIZCHIP_OFFSET_INC(ADDR, N)    (ADDR + (N<<8)) //< Increase offset address
N
N
N///////////////////////////////////////
N// Definition For Legacy Chip Driver //
N///////////////////////////////////////
N#define IINCHIP_READ(ADDR)                WIZCHIP_READ(ADDR)               ///< The defined for legacy chip driver
N#define IINCHIP_WRITE(ADDR,VAL)           WIZCHIP_WRITE(ADDR,VAL)          ///< The defined for legacy chip driver
N#define IINCHIP_READ_BUF(ADDR,BUF,LEN)    WIZCHIP_READ_BUF(ADDR,BUF,LEN)   ///< The defined for legacy chip driver
N#define IINCHIP_WRITE_BUF(ADDR,BUF,LEN)   WIZCHIP_WRITE(ADDR,BUF,LEN)      ///< The defined for legacy chip driver
N
N//////////////////////////////
N//--------------------------  defgroup ---------------------------------
N/**
N * @defgroup W5500 W5500
N *
N * @brief WHIZCHIP register defines and I/O functions of @b W5500.
N *
N * - @ref WIZCHIP_register : @ref Common_register_group and @ref Socket_register_group
N * - @ref WIZCHIP_IO_Functions : @ref Basic_IO_function, @ref Common_register_access_function and @ref Socket_register_access_function
N */
N 
N 
N/**
N * @defgroup WIZCHIP_register WIZCHIP register
N * @ingroup W5500
N *
N * @brief WHIZCHIP register defines register group of @b W5500.
N *
N * - @ref Common_register_group : Common register group
N * - @ref Socket_register_group : \c SOCKET n register group
N */
N
N
N/**
N * @defgroup WIZCHIP_IO_Functions WIZCHIP I/O functions
N * @ingroup W5500
N *
N * @brief This supports the basic I/O functions for @ref WIZCHIP_register.
N *
N * - <b> Basic I/O function </b> \n
N *   WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF() \n\n
N *
N * - @ref Common_register_group <b>access functions</b> \n
N * 	-# @b Mode \n
N *    getMR(), setMR()
N * 	-# @b Interrupt \n
N *    getIR(), setIR(), getIMR(), setIMR(), getSIR(), setSIR(), getSIMR(), setSIMR(), getINTLEVEL(), setINTLEVEL()
N * 	-# <b> Network Information </b> \n
N *    getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR()
N * 	-# @b Retransmission \n
N *    getRCR(), setRCR(), getRTR(), setRTR()
N * 	-# @b PPPoE \n
N *    getPTIMER(), setPTIMER(), getPMAGIC(), getPMAGIC(), getPSID(), setPSID(), getPHAR(), setPHAR(), getPMRU(), setPMRU()
N * 	-# <b> ICMP packet </b>\n
N *    getUIPR(), getUPORTR()
N * 	-# @b etc. \n
N *    getPHYCFGR(), setPHYCFGR(), getVERSIONR() \n\n
N *
N * - \ref Socket_register_group <b>access functions</b> \n
N *   -# <b> SOCKET control</b> \n
N *      getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IR()
N *   -# <b> SOCKET information</b> \n
N *      getSn_SR(), getSn_DHAR(), setSn_DHAR(), getSn_PORT(), setSn_PORT(), getSn_DIPR(), setSn_DIPR(), getSn_DPORT(), setSn_DPORT()
N *      getSn_MSSR(), setSn_MSSR()
N *   -# <b> SOCKET communication </b> \n
N *      getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE() \n
N *      getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
N *      getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
N *      getSn_TX_FSR(), getSn_RX_RSR(), getSn_KPALVTR(), setSn_KPALVTR()
N *   -# <b> IP header field </b> \n
N *      getSn_FRAG(), setSn_FRAG(),  getSn_TOS(), setSn_TOS() \n
N *      getSn_TTL(), setSn_TTL()
N */
N
N
N
N/**
N * @defgroup Common_register_group Common register
N * @ingroup WIZCHIP_register
N *
N * @brief Common register group\n
N * It set the basic for the networking\n
N * It set the configuration such as interrupt, network information, ICMP, etc.
N * @details
N * @sa MR : Mode register.
N * @sa GAR, SUBR, SHAR, SIPR
N * @sa INTLEVEL, IR, IMR, SIR, SIMR : Interrupt.
N * @sa RTR, RCR : Data retransmission.
N * @sa PTIMER, PMAGIC, PHAR, PSID, PMRU : PPPoE.
N * @sa UIPR, UPORTR : ICMP message.
N * @sa PHYCFGR, VERSIONR : etc.
N */
N 
N  
N 
N/**
N * @defgroup Socket_register_group Socket register
N * @ingroup WIZCHIP_register
N *
N * @brief Socket register group.\n
N * Socket register configures and control SOCKETn which is necessary to data communication.
N * @details
N * @sa Sn_MR, Sn_CR, Sn_IR, Sn_IMR : SOCKETn Control
N * @sa Sn_SR, Sn_PORT, Sn_DHAR, Sn_DIPR, Sn_DPORT : SOCKETn Information
N * @sa Sn_MSSR, Sn_TOS, Sn_TTL, Sn_KPALVTR, Sn_FRAG : Internet protocol.
N * @sa Sn_RXBUF_SIZE, Sn_TXBUF_SIZE, Sn_TX_FSR, Sn_TX_RD, Sn_TX_WR, Sn_RX_RSR, Sn_RX_RD, Sn_RX_WR : Data communication
N */
N 
N 
N 
N /**
N * @defgroup Basic_IO_function Basic I/O function
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are basic input/output functions to read values from register or write values to register.
N */
N
N/**
N * @defgroup Common_register_access_function Common register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>common registers</b>.
N */
N
N/**
N * @defgroup Socket_register_access_function Socket register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>socket registers</b>.
N */
N 
N//------------------------------- defgroup end --------------------------------------------
N//----------------------------- W5500 Common Registers IOMAP -----------------------------
N/**
N * @ingroup Common_register_group
N * @brief Mode Register address(R/W)\n
N * @ref MR is used for S/W reset, ping block mode, PPPoE mode and etc.
N * @details Each bit of @ref MR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>RST</td> <td>Reserved</td> <td>WOL</td> <td>PB</td> <td>PPPoE</td> <td>Reserved</td> <td>FARP</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref MR_RST		 	: Reset
N * - \ref MR_WOL       		: Wake on LAN
N * - \ref MR_PB         	: Ping block
N * - \ref MR_PPPOE      	: PPPoE mode
N * - \ref MR_FARP			: Force ARP mode
N */
N#define MR                 (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Gateway IP Register address(R/W)
N * @details @ref GAR configures the default gateway address.
N */
N#define GAR                (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Subnet mask Register address(R/W)
N * @details @ref SUBR configures the subnet mask address.
N */
N#define SUBR               (_W5500_IO_BASE_ + (0x0005 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source MAC Register address(R/W)
N * @details @ref SHAR configures the source hardware address.
N */
N#define SHAR               (_W5500_IO_BASE_ + (0x0009 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source IP Register address(R/W)
N * @details @ref SIPR configures the source IP address.
N */
N#define SIPR               (_W5500_IO_BASE_ + (0x000F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Set Interrupt low level timer register address(R/W)
N * @details @ref INTLEVEL configures the Interrupt Assert Time.
N */
N#define INTLEVEL           (_W5500_IO_BASE_ + (0x0013 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt Register(R/W)
N * @details @ref IR indicates the interrupt status. Each bit of @ref IR will be still until the bit will be written to by the host.
N * If @ref IR is not equal to x00 INTn PIN is asserted to low until it is x00\n\n
N * Each bit of @ref IR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>CONFLICT</td> <td>UNREACH</td> <td>PPPoE</td> <td>MP</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IR_CONFLICT : IP conflict
N * - \ref IR_UNREACH  : Destination unreachable
N * - \ref IR_PPPoE	  : PPPoE connection close
N * - \ref IR_MP		  : Magic packet
N */
N#define IR                 (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt mask register(R/W)
N * @details @ref IMR is used to mask interrupts. Each bit of @ref IMR corresponds to each bit of @ref IR.
N * When a bit of @ref IMR is and the corresponding bit of @ref IR is  an interrupt will be issued. In other words,
N * if a bit of @ref IMR is  an interrupt will not be issued even if the corresponding bit of @ref IR is \n\n
N * Each bit of @ref IMR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>IM_IR7</td> <td>IM_IR6</td> <td>IM_IR5</td> <td>IM_IR4</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IM_IR7 : IP Conflict Interrupt Mask
N * - \ref IM_IR6 : Destination unreachable Interrupt Mask
N * - \ref IM_IR5 : PPPoE Close Interrupt Mask
N * - \ref IM_IR4 : Magic Packet Interrupt Mask
N */
N#define IMR                (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Register(R/W)
N * @details @ref SIR indicates the interrupt status of Socket.\n
N * Each bit of @ref SIR be still until @ref Sn_IR is cleared by the host.\n
N * If @ref Sn_IR is not equal to x00 the n-th bit of @ref SIR is and INTn PIN is asserted until @ref SIR is x00 */
N#define SIR                (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Mask Register(R/W)
N * @details Each bit of @ref SIMR corresponds to each bit of @ref SIR.
N * When a bit of @ref SIMR is and the corresponding bit of @ref SIR is  Interrupt will be issued.
N * In other words, if a bit of @ref SIMR is  an interrupt will be not issued even if the corresponding bit of @ref SIR is 
N */
N#define SIMR               (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Timeout register address( 1 is 100us )(R/W)
N * @details @ref RTR configures the retransmission timeout period. The unit of timeout period is 100us and the default of @ref RTR is x07D0or 000
N * And so the default timeout period is 200ms(100us X 2000). During the time configured by @ref RTR, W5500 waits for the peer response
N * to the packet that is transmitted by \ref Sn_CR (CONNECT, DISCON, CLOSE, SEND, SEND_MAC, SEND_KEEP command).
N * If the peer does not respond within the @ref RTR time, W5500 retransmits the packet or issues timeout.
N */
N#define RTR                (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Retry count register(R/W)
N * @details @ref RCR configures the number of time of retransmission.
N * When retransmission occurs as many as ref RCR+1 Timeout interrupt is issued (@ref Sn_IR[TIMEOUT] = .
N */
N#define RCR                (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Request Timer register  in PPPoE mode(R/W)
N * @details @ref PTIMER configures the time for sending LCP echo request. The unit of time is 25ms.
N */
N#define PTIMER             (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Magic number register  in PPPoE mode(R/W)
N * @details @ref PMAGIC configures the 4bytes magic number to be used in LCP negotiation.
N */
N#define PMAGIC             (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Destination MAC Register address(R/W)
N * @details @ref PHAR configures the PPPoE server hardware address that is acquired during PPPoE connection process.
N */
N#define PHAR                (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Session Identification Register(R/W)
N * @details @ref PSID configures the PPPoE sever session ID acquired during PPPoE connection process.
N */
N#define PSID               (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Maximum Segment Size(MSS) register(R/W)
N * @details @ref PMRU configures the maximum receive unit of PPPoE.
N */
N#define PMRU               (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable IP register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR indicates
N * the destination IP address & port number respectively.
N */
N#define UIPR               (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable Port register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR
N * indicates the destination IP address & port number respectively.
N */
N#define UPORTR              (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PHY Status Register(R/W)
N * @details @ref PHYCFGR configures PHY operation mode and resets PHY. In addition, @ref PHYCFGR indicates the status of PHY such as duplex, Speed, Link.
N */
N#define PHYCFGR            (_W5500_IO_BASE_ + (0x002E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0031 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0032 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0033 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0034 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0035 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0036 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0037 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0038 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief chip version register address(R)
N * @details @ref VERSIONR always indicates the W5500 version as @b 0x04.
N */
N#define VERSIONR           (_W5500_IO_BASE_ + (0x0039 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N
N//----------------------------- W5500 Socket Registers IOMAP -----------------------------
N/**
N * @ingroup Socket_register_group
N * @brief socket Mode register(R/W)
N * @details @ref Sn_MR configures the option or protocol type of Socket n.\n\n
N * Each bit of @ref Sn_MR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>MULTI/MFEN</td> <td>BCASTB</td> <td>ND/MC/MMB</td> <td>UCASTB/MIP6B</td> <td>Protocol[3]</td> <td>Protocol[2]</td> <td>Protocol[1]</td> <td>Protocol[0]</td> </tr>
N * </table>
N * - @ref Sn_MR_MULTI	: Support UDP Multicasting
N * - @ref Sn_MR_BCASTB	: Broadcast block <b>in UDP Multicasting</b>
N * - @ref Sn_MR_ND		: No Delayed Ack(TCP) flag
N * - @ref Sn_MR_MC   	: IGMP version used <b>in UDP mulitcasting</b>
N * - @ref Sn_MR_MMB    	: Multicast Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - @ref Sn_MR_UCASTB	: Unicast Block <b>in UDP Multicating</b>
N * - @ref Sn_MR_MIP6B   : IPv6 packet Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - <b>Protocol</b>
N * <table>
N * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>Closed</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>TCP</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>UDP</td>   </tr>
N * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
N * </table>
N *	- @ref Sn_MR_MACRAW	: MAC LAYER RAW SOCK \n
N *  - @ref Sn_MR_UDP		: UDP
N *  - @ref Sn_MR_TCP		: TCP
N *  - @ref Sn_MR_CLOSE	: Unused socket
N *  @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR(N)           (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket command register(R/W)
N * @details This is used to set the command for Socket n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
N * After W5500 accepts the command, the @ref Sn_CR register is automatically cleared to 0x00.
N * Even though @ref Sn_CR is cleared to 0x00, the command is still being processed.\n
N * To check whether the command is completed or not, please check the @ref Sn_IR or @ref Sn_SR.
N * - @ref Sn_CR_OPEN 		: Initialize or open socket.
N * - @ref Sn_CR_LISTEN 		: Wait connection request in TCP mode(<b>Server mode</b>)
N * - @ref Sn_CR_CONNECT 	: Send connection request in TCP mode(<b>Client mode</b>)
N * - @ref Sn_CR_DISCON 		: Send closing request in TCP mode.
N * - @ref Sn_CR_CLOSE   	: Close socket.
N * - @ref Sn_CR_SEND    	: Update TX buffer pointer and send data.
N * - @ref Sn_CR_SEND_MAC	: Send data with MAC address, so without ARP process.
N * - @ref Sn_CR_SEND_KEEP 	: Send keep alive message.
N * - @ref Sn_CR_RECV		: Update RX buffer pointer and receive data.
N */
N#define Sn_CR(N)           (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket interrupt register(R)
N * @details @ref Sn_IR indicates the status of Socket Interrupt such as establishment, termination, receiving data, timeout).\n
N * When an interrupt occurs and the corresponding bit of @ref Sn_IMR is  the corresponding bit of @ref Sn_IR becomes \n
N * In order to clear the @ref Sn_IR bit, the host should write the bit to \n
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>SEND_OK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
N * </table>
N * - \ref Sn_IR_SENDOK : <b>SEND_OK Interrupt</b>
N * - \ref Sn_IR_TIMEOUT : <b>TIMEOUT Interrupt</b>
N * - \ref Sn_IR_RECV : <b>RECV Interrupt</b>
N * - \ref Sn_IR_DISCON : <b>DISCON Interrupt</b>
N * - \ref Sn_IR_CON : <b>CON Interrupt</b>
N */
N#define Sn_IR(N)           (_W5500_IO_BASE_ + (0x0002 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket status register(R)
N * @details @ref Sn_SR indicates the status of Socket n.\n
N * The status of Socket n is changed by @ref Sn_CR or some special control packet as SYN, FIN packet in TCP.
N * @par Normal status
N * - @ref SOCK_CLOSED 		: Closed
N * - @ref SOCK_INIT   		: Initiate state
N * - @ref SOCK_LISTEN    	: Listen state
N * - @ref SOCK_ESTABLISHED 	: Success to connect
N * - @ref SOCK_CLOSE_WAIT   : Closing state
N * - @ref SOCK_UDP   		: UDP socket
N * - @ref SOCK_MACRAW  		: MAC raw mode socket
N *@par Temporary status during changing the status of Socket n.
N * - @ref SOCK_SYNSENT   	: This indicates Socket n sent the connect-request packet (SYN packet) to a peer.
N * - @ref SOCK_SYNRECV    	: It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.
N * - @ref SOCK_FIN_WAIT		: Connection state
N * - @ref SOCK_CLOSING		: Closing state
N * - @ref SOCK_TIME_WAIT	: Closing state
N * - @ref SOCK_LAST_ACK 	: Closing state
N */
N#define Sn_SR(N)           (_W5500_IO_BASE_ + (0x0003 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief source port register(R/W)
N * @details @ref Sn_PORT configures the source port number of Socket n.
N * It is valid when Socket n is used in TCP/UPD mode. It should be set before OPEN command is ordered.
N */
N#define Sn_PORT(N)         (_W5500_IO_BASE_ + (0x0004 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer MAC register address(R/W)
N * @details @ref Sn_DHAR configures the destination hardware address of Socket n when using SEND_MAC command in UDP mode or
N * it indicates that it is acquired in ARP-process by CONNECT/SEND command.
N */
N#define Sn_DHAR(N)         (_W5500_IO_BASE_ + (0x0006 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer IP register address(R/W)
N * @details @ref Sn_DIPR configures or indicates the destination IP address of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In TCP client mode, it configures an IP address of �TCP serverbefore CONNECT command.
N * In TCP server mode, it indicates an IP address of �TCP clientafter successfully establishing connection.
N * In UDP mode, it configures an IP address of peer to be received the UDP packet by SEND or SEND_MAC command.
N */
N#define Sn_DIPR(N)         (_W5500_IO_BASE_ + (0x000C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer port register address(R/W)
N * @details @ref Sn_DPORT configures or indicates the destination port number of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In �TCP clientmode, it configures the listen port number of �TCP serverbefore CONNECT command.
N * In �TCP Servermode, it indicates the port number of TCP client after successfully establishing connection.
N * In UDP mode, it configures the port number of peer to be transmitted the UDP packet by SEND/SEND_MAC command.
N */
N#define Sn_DPORT(N)        (_W5500_IO_BASE_ + (0x0010 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Maximum Segment Size(Sn_MSSR0) register address(R/W)
N * @details @ref Sn_MSSR configures or indicates the MTU(Maximum Transfer Unit) of Socket n.
N */
N#define Sn_MSSR(N)         (_W5500_IO_BASE_ + (0x0012 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x0014 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief IP Type of Service(TOS) Register(R/W)
N * @details @ref Sn_TOS configures the TOS(Type Of Service field in IP Header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TOS(N)          (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N/**
N * @ingroup Socket_register_group
N * @brief IP Time to live(TTL) Register(R/W)
N * @details @ref Sn_TTL configures the TTL(Time To Live field in IP header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TTL(N)          (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3)) 
N// Reserved			         (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Receive memory size register(R/W)
N * @details @ref Sn_RXBUF_SIZE configures the RX buffer block size of Socket n.
N * Socket n RX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data cannot be normally received from a peer.
N * Although Socket n RX Buffer Block size is initially configured to 2Kbytes,
N * user can re-configure its size using @ref Sn_RXBUF_SIZE. The total sum of @ref Sn_RXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data reception error is occurred.
N */
N#define Sn_RXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory size register(R/W)
N * @details @ref Sn_TXBUF_SIZE configures the TX buffer block size of Socket n. Socket n TX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data can�t be normally transmitted to a peer.
N * Although Socket n TX Buffer Block size is initially configured to 2Kbytes,
N * user can be re-configure its size using @ref Sn_TXBUF_SIZE. The total sum of @ref Sn_TXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data transmission error is occurred.
N */
N#define Sn_TXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit free memory size register(R)
N * @details @ref Sn_TX_FSR indicates the free size of Socket n TX Buffer Block. It is initialized to the configured size by @ref Sn_TXBUF_SIZE.
N * Data bigger than @ref Sn_TX_FSR should not be saved in the Socket n TX Buffer because the bigger data overwrites the previous saved data not yet sent.
N * Therefore, check before saving the data to the Socket n TX Buffer, and if data is equal or smaller than its checked size,
N * transmit the data with SEND/SEND_MAC command after saving the data in Socket n TX buffer. But, if data is bigger than its checked size,
N * transmit the data after dividing into the checked size and saving in the Socket n TX buffer.
N */
N#define Sn_TX_FSR(N)       (_W5500_IO_BASE_ + (0x0020 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory read pointer register address(R)
N * @details @ref Sn_TX_RD is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.
N * After its initialization, it is auto-increased by SEND command.
N * SEND command transmits the saved data from the current @ref Sn_TX_RD to the @ref Sn_TX_WR in the Socket n TX Buffer.
N * After transmitting the saved data, the SEND command increases the @ref Sn_TX_RD as same as the @ref Sn_TX_WR.
N * If its increment value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_TX_RD(N)        (_W5500_IO_BASE_ + (0x0022 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory write pointer register address(R/W)
N * @details @ref Sn_TX_WR is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.\n
N * It should be read or be updated like as follows.\n
N * 1. Read the starting address for saving the transmitting data.\n
N * 2. Save the transmitting data from the starting address of Socket n TX buffer.\n
N * 3. After saving the transmitting data, update @ref Sn_TX_WR to the increased value as many as transmitting data size.
N * If the increment value exceeds the maximum value 0xFFFF(greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.\n
N * 4. Transmit the saved data in Socket n TX Buffer by using SEND/SEND command
N */
N#define Sn_TX_WR(N)        (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Received data size register(R)
N * @details @ref Sn_RX_RSR indicates the data size received and saved in Socket n RX Buffer.
N * @ref Sn_RX_RSR does not exceed the @ref Sn_RXBUF_SIZE and is calculated as the difference between
N * �Socket n RX Write Pointer (@ref Sn_RX_WR)and �Socket n RX Read Pointer (@ref Sn_RX_RD)
N */
N#define Sn_RX_RSR(N)       (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Read point of Receive memory(R/W)
N * @details @ref Sn_RX_RD is initialized by OPEN command. Make sure to be read or updated as follows.\n
N * 1. Read the starting save address of the received data.\n
N * 2. Read data from the starting address of Socket n RX Buffer.\n
N * 3. After reading the received data, Update @ref Sn_RX_RD to the increased value as many as the reading size.
N * If the increment value exceeds the maximum value 0xFFFF, that is, is greater than 0x10000 and the carry bit occurs,
N * update with the lower 16bits value ignored the carry bit.\n
N * 4. Order RECV command is for notifying the updated @ref Sn_RX_RD to W5500.
N */
N#define Sn_RX_RD(N)        (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Write point of Receive memory(R)
N * @details @ref Sn_RX_WR is initialized by OPEN command and it is auto-increased by the data reception.
N * If the increased value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_RX_WR(N)        (_W5500_IO_BASE_ + (0x002A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief socket interrupt mask register(R)
N * @details @ref Sn_IMR masks the interrupt of Socket n.
N * Each bit corresponds to each bit of @ref Sn_IR. When a Socket n Interrupt is occurred and the corresponding bit of @ref Sn_IMR is 
N * the corresponding bit of @ref Sn_IR becomes  When both the corresponding bit of @ref Sn_IMR and @ref Sn_IR are and the n-th bit of @ref IR is 
N * Host is interrupted by asserted INTn PIN to low.
N */
N#define Sn_IMR(N)          (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Fragment field value in IP header register(R/W)
N * @details @ref Sn_FRAG configures the FRAG(Fragment field in IP header).
N */
N#define Sn_FRAG(N)         (_W5500_IO_BASE_ + (0x002D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Keep Alive Timer register(R/W)
N * @details @ref Sn_KPALVTR configures the transmitting timer of �KEEP ALIVE(KA)packet of SOCKETn. It is valid only in TCP mode,
N * and ignored in other modes. The time unit is 5s.
N * KA packet is transmittable after @ref Sn_SR is changed to SOCK_ESTABLISHED and after the data is transmitted or received to/from a peer at least once.
N * In case of '@ref Sn_KPALVTR > 0', W5500 automatically transmits KA packet after time-period for checking the TCP connection (Auto-keepalive-process).
N * In case of '@ref Sn_KPALVTR = 0', Auto-keep-alive-process will not operate,
N * and KA packet can be transmitted by SEND_KEEP command by the host (Manual-keep-alive-process).
N * Manual-keep-alive-process is ignored in case of '@ref Sn_KPALVTR > 0'.
N */
N#define Sn_KPALVTR(N)      (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N//#define Sn_TSR(N)          (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N
N//----------------------------- W5500 Register values  -----------------------------
N
N/* MODE register values */
N/**
N * @brief Reset
N * @details If this bit is  All internal registers will be initialized. It will be automatically cleared as after S/W reset.
N */
N#define MR_RST                       0x80
N
N/**
N * @brief Wake on LAN
N * @details 0 : Disable WOL mode\n
N * 1 : Enable WOL mode\n
N * If WOL mode is enabled and the received magic packet over UDP has been normally processed, the Interrupt PIN (INTn) asserts to low.
N * When using WOL mode, the UDP Socket should be opened with any source port number. (Refer to Socket n Mode Register (@ref Sn_MR) for opening Socket.)
N * @note The magic packet over UDP supported by W5500 consists of 6 bytes synchronization stream (xFFFFFFFFFFFF and
N * 16 times Target MAC address stream in UDP payload. The options such like password are ignored. You can use any UDP source port number for WOL mode.
N */
N#define MR_WOL                       0x20
N
N/**
N * @brief Ping block
N * @details 0 : Disable Ping block\n
N * 1 : Enable Ping block\n
N * If the bit is  it blocks the response to a ping request.
N */
N#define MR_PB                        0x10
N
N/**
N * @brief Enable PPPoE
N * @details 0 : DisablePPPoE mode\n
N * 1 : EnablePPPoE mode\n
N * If you use ADSL, this bit should be 
N */
N#define MR_PPPOE                     0x08
N
N/**
N * @brief Enable UDP_FORCE_ARP CHECHK
N * @details 0 : Disable Force ARP mode\n
N * 1 : Enable Force ARP mode\n
N * In Force ARP mode, It forces on sending ARP Request whenever data is sent.
N */
N#define MR_FARP                      0x02
N
N/* IR register values */
N/**
N * @brief Check IP conflict.
N * @details Bit is set as when own source IP address is same with the sender IP address in the received ARP request.
N */
N#define IR_CONFLICT                  0x80
N
N/**
N * @brief Get the destination unreachable message in UDP sending.
N * @details When receiving the ICMP (Destination port unreachable) packet, this bit is set as 
N * When this bit is  Destination Information such as IP address and Port number may be checked with the corresponding @ref UIPR & @ref UPORTR.
N */
N#define IR_UNREACH                   0x40
N
N/**
N * @brief Get the PPPoE close message.
N * @details When PPPoE is disconnected during PPPoE mode, this bit is set.
N */
N#define IR_PPPoE                     0x20
N
N/**
N * @brief Get the magic packet interrupt.
N * @details When WOL mode is enabled and receives the magic packet over UDP, this bit is set.
N */
N#define IR_MP                        0x10
N
N
N/* PHYCFGR register value */
N#define PHYCFGR_RST                  ~(1<<7)  //< For PHY reset, must operate AND mask.
N#define PHYCFGR_OPMD                 (1<<6)   // Configre PHY with OPMDC value
N#define PHYCFGR_OPMDC_ALLA           (7<<3)
N#define PHYCFGR_OPMDC_PDOWN          (6<<3)
N#define PHYCFGR_OPMDC_NA             (5<<3)
N#define PHYCFGR_OPMDC_100FA          (4<<3)
N#define PHYCFGR_OPMDC_100F           (3<<3)
N#define PHYCFGR_OPMDC_100H           (2<<3)
N#define PHYCFGR_OPMDC_10F            (1<<3)
N#define PHYCFGR_OPMDC_10H            (0<<3)           
N#define PHYCFGR_DPX_FULL             (1<<2)
N#define PHYCFGR_DPX_HALF             (0<<2)
N#define PHYCFGR_SPD_100              (1<<1)
N#define PHYCFGR_SPD_10               (0<<1)
N#define PHYCFGR_LNK_ON               (1<<0)
N#define PHYCFGR_LNK_OFF              (0<<0)
N
N/* IMR register values */
N/**
N * @brief IP Conflict Interrupt Mask.
N * @details 0: Disable IP Conflict Interrupt\n
N * 1: Enable IP Conflict Interrupt
N */
N#define IM_IR7                  	 0x80
N
N/**
N * @brief Destination unreachable Interrupt Mask.
N * @details 0: Disable Destination unreachable Interrupt\n
N * 1: Enable Destination unreachable Interrupt
N */
N#define IM_IR6                  	 0x40
N
N/**
N * @brief PPPoE Close Interrupt Mask.
N * @details 0: Disable PPPoE Close Interrupt\n
N * 1: Enable PPPoE Close Interrupt
N */
N#define IM_IR5                  	 0x20
N
N/**
N * @brief Magic Packet Interrupt Mask.
N * @details 0: Disable Magic Packet Interrupt\n
N * 1: Enable Magic Packet Interrupt
N */
N#define IM_IR4                  	 0x10
N
N/* Sn_MR Default values */
N/**
N * @brief Support UDP Multicasting
N * @details 0 : disable Multicasting\n
N * 1 : enable Multicasting\n
N * This bit is applied only during UDP mode(P[3:0] = 010.\n
N * To use multicasting, @ref Sn_DIPR & @ref Sn_DPORT should be respectively configured with the multicast group IP address & port number
N * before Socket n is opened by OPEN command of @ref Sn_CR.
N */
N#define Sn_MR_MULTI                  0x80
N
N/**
N * @brief Broadcast block in UDP Multicasting.
N * @details 0 : disable Broadcast Blocking\n
N * 1 : enable Broadcast Blocking\n
N * This bit blocks to receive broadcasting packet during UDP mode(P[3:0] = 010.\m
N * In addition, This bit does when MACRAW mode(P[3:0] = 100
N */
N#define Sn_MR_BCASTB                 0x40
N
N/**
N * @brief No Delayed Ack(TCP), Multicast flag
N * @details 0 : Disable No Delayed ACK option\n
N * 1 : Enable No Delayed ACK option\n
N * This bit is applied only during TCP mode (P[3:0] = 001.\n
N * When this bit is  It sends the ACK packet without delay as soon as a Data packet is received from a peer.\n
N * When this bit is  It sends the ACK packet after waiting for the timeout time configured by @ref RTR.
N */
N#define Sn_MR_ND                     0x20
N
N/**
N * @brief Unicast Block in UDP Multicasting
N * @details 0 : disable Unicast Blocking\n
N * 1 : enable Unicast Blocking\n
N * This bit blocks receiving the unicast packet during UDP mode(P[3:0] = 010 and MULTI = 
N */
N#define Sn_MR_UCASTB                 0x10
N
N/**
N * @brief MAC LAYER RAW SOCK
N * @details This configures the protocol mode of Socket n.
N * @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR_MACRAW                 0x04
N
N//#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
N
N/**
N * @brief UDP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_UDP                    0x02
N
N/**
N * @brief TCP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_TCP                    0x01
N
N/**
N * @brief Unused socket
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_CLOSE                  0x00
N
N/* Sn_MR values used with Sn_MR_MACRAW */
N/**
N * @brief MAC filter enable in @ref Sn_MR_MACRAW mode
N * @details 0 : disable MAC Filtering\n
N * 1 : enable MAC Filtering\n
N * This bit is applied only during MACRAW mode(P[3:0] = 100.\n
N * When set as  W5500 can only receive broadcasting packet or packet sent to itself.
N * When this bit is  W5500 can receive all packets on Ethernet.
N * If user wants to implement Hybrid TCP/IP stack,
N * it is recommended that this bit is set as for reducing host overhead to process the all received packets.
N */
N#define Sn_MR_MFEN                   Sn_MR_MULTI
N
N/**
N * @brief Multicast Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : using IGMP version 2\n
N * 1 : using IGMP version 1\n
N * This bit is applied only during UDP mode(P[3:0] = 010 and MULTI = 
N * It configures the version for IGMP messages (Join/Leave/Report).
N */
N#define Sn_MR_MMB                    Sn_MR_ND
N
N/**
N * @brief IPv6 packet Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : disable IPv6 Blocking\n
N * 1 : enable IPv6 Blocking\n
N * This bit is applied only during MACRAW mode (P[3:0] = 100. It blocks to receiving the IPv6 packet.
N */
N#define Sn_MR_MIP6B                  Sn_MR_UCASTB
N
N/* Sn_MR value used with Sn_MR_UDP & Sn_MR_MULTI */
N/**
N * @brief IGMP version used in UDP mulitcasting
N * @details 0 : disable Multicast Blocking\n
N * 1 : enable Multicast Blocking\n
N * This bit is applied only when MACRAW mode(P[3:0] = 100. It blocks to receive the packet with multicast MAC address.
N */
N#define Sn_MR_MC                     Sn_MR_ND
N
N/* Sn_MR alternate values */
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_STREAM                  Sn_MR_TCP
N
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_DGRAM                   Sn_MR_UDP
N
N
N/* Sn_CR values */
N/**
N * @brief Initialize or open socket
N * @details Socket n is initialized and opened according to the protocol selected in Sn_MR(P3:P0).
N * The table below shows the value of @ref Sn_SR corresponding to @ref Sn_MR.\n
N * <table>
N *   <tr>  <td>\b Sn_MR (P[3:0])</td> <td>\b Sn_SR</td>            		 </tr>
N *   <tr>  <td>Sn_MR_CLOSE  (000</td> <td></td>         	   		 </tr>
N *   <tr>  <td>Sn_MR_TCP  (001</td> <td>SOCK_INIT (0x13)</td>  		 </tr>
N *   <tr>  <td>Sn_MR_UDP  (010</td>  <td>SOCK_UDP (0x22)</td>  		 </tr>
N *   <tr>  <td>S0_MR_MACRAW  (100</td>  <td>SOCK_MACRAW (0x02)</td>  </tr>
N * </table>
N */
N#define Sn_CR_OPEN                   0x01
N
N/**
N * @brief Wait connection request in TCP mode(Server mode)
N * @details This is valid only in TCP mode (Sn_MR(P3:P0) = Sn_MR_TCP).
N * In this mode, Socket n operates as a �TCP serverand waits for  connection-request (SYN packet) from any �TCP client
N * The @ref Sn_SR changes the state from SOCK_INIT to SOCKET_LISTEN.
N * When a �TCP clientconnection request is successfully established,
N * the @ref Sn_SR changes from SOCK_LISTEN to SOCK_ESTABLISHED and the Sn_IR(0) becomes 
N * But when a �TCP clientconnection request is failed, Sn_IR(3) becomes and the status of @ref Sn_SR changes to SOCK_CLOSED.
N */
N#define Sn_CR_LISTEN                 0x02
N
N/**
N * @brief Send connection request in TCP mode(Client mode)
N * @details  To connect, a connect-request (SYN packet) is sent to b>TCP server</b>configured by @ref Sn_DIPR & Sn_DPORT(destination address & port).
N * If the connect-request is successful, the @ref Sn_SR is changed to @ref SOCK_ESTABLISHED and the Sn_IR(0) becomes \n\n
N * The connect-request fails in the following three cases.\n
N * 1. When a @b ARPTO occurs (@ref Sn_IR[3] =  ) because destination hardware address is not acquired through the ARP-process.\n
N * 2. When a @b SYN/ACK packet is not received and @b TCPTO (Sn_IR(3) =  )\n
N * 3. When a @b RST packet is received instead of a @b SYN/ACK packet. In these cases, @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note This is valid only in TCP mode and operates when Socket n acts as b>TCP client</b>
N */
N#define Sn_CR_CONNECT                0x04
N
N/**
N * @brief Send closing request in TCP mode
N * @details Regardless of b>TCP server</b>or b>TCP client</b> the DISCON command processes the disconnect-process (b>Active close</b>or b>Passive close</b>.\n
N * @par Active close
N * it transmits disconnect-request(FIN packet) to the connected peer\n
N * @par Passive close
N * When FIN packet is received from peer, a FIN packet is replied back to the peer.\n
N * @details When the disconnect-process is successful (that is, FIN/ACK packet is received successfully), @ref Sn_SR is changed to @ref SOCK_CLOSED.\n
N * Otherwise, TCPTO occurs (Sn_IR(3)=)= and then @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_DISCON                 0x08
N
N/**
N * @brief Close socket
N * @details Sn_SR is changed to @ref SOCK_CLOSED.
N */
N#define Sn_CR_CLOSE                  0x10
N
N/**
N * @brief Update TX buffer pointer and send data
N * @details SEND transmits all the data in the Socket n TX buffer.\n
N * For more details, please refer to Socket n TX Free Size Register (@ref Sn_TX_FSR), Socket n,
N * TX Write Pointer Register(@ref Sn_TX_WR), and Socket n TX Read Pointer Register(@ref Sn_TX_RD).
N */
N#define Sn_CR_SEND                   0x20
N
N/**
N * @brief Send data with MAC address, so without ARP process
N * @details The basic operation is same as SEND.\n
N * Normally SEND transmits data after destination hardware address is acquired by the automatic ARP-process(Address Resolution Protocol).\n
N * But SEND_MAC transmits data without the automatic ARP-process.\n
N * In this case, the destination hardware address is acquired from @ref Sn_DHAR configured by host, instead of APR-process.
N * @note Valid only in UDP mode.
N */
N#define Sn_CR_SEND_MAC               0x21
N
N/**
N * @brief Send keep alive message
N * @details It checks the connection status by sending 1byte keep-alive packet.\n
N * If the peer can not respond to the keep-alive packet during timeout time, the connection is terminated and the timeout interrupt will occur.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_SEND_KEEP              0x22
N
N/**
N * @brief Update RX buffer pointer and receive data
N * @details RECV completes the processing of the received data in Socket n RX Buffer by using a RX read pointer register (@ref Sn_RX_RD).\n
N * For more details, refer to Socket n RX Received Size Register (@ref Sn_RX_RSR), Socket n RX Write Pointer Register (@ref Sn_RX_WR),
N * and Socket n RX Read Pointer Register (@ref Sn_RX_RD).
N */
N#define Sn_CR_RECV                   0x40
N
N/* Sn_IR values */
N/**
N * @brief SEND_OK Interrupt
N * @details This is issued when SEND command is completed.
N */
N#define Sn_IR_SENDOK                 0x10
N
N/**
N * @brief TIMEOUT Interrupt
N * @details This is issued when ARPTO or TCPTO occurs.
N */
N#define Sn_IR_TIMEOUT                0x08
N
N/**
N * @brief RECV Interrupt
N * @details This is issued whenever data is received from a peer.
N */
N#define Sn_IR_RECV                   0x04
N
N/**
N * @brief DISCON Interrupt
N * @details This is issued when FIN or FIN/ACK packet is received from a peer.
N */
N#define Sn_IR_DISCON                 0x02
N
N/**
N * @brief CON Interrupt
N * @details This is issued one time when the connection with peer is successful and then @ref Sn_SR is changed to @ref SOCK_ESTABLISHED.
N */
N#define Sn_IR_CON                    0x01
N
N/* Sn_SR values */
N/**
N * @brief Closed
N * @details This indicates that Socket n is released.\N
N * When DICON, CLOSE command is ordered, or when a timeout occurs, it is changed to @ref SOCK_CLOSED regardless of previous status.
N */
N#define SOCK_CLOSED                  0x00
N
N/**
N * @brief Initiate state
N * @details This indicates Socket n is opened with TCP mode.\N
N * It is changed to @ref SOCK_INIT when Sn_MR(P[3:0]) = 001and OPEN command is ordered.\N
N * After @ref SOCK_INIT, user can use LISTEN /CONNECT command.
N */
N#define SOCK_INIT                    0x13
N
N/**
N * @brief Listen state
N * @details This indicates Socket n is operating as b>TCP server</b>mode and waiting for connection-request (SYN packet) from a peer (b>TCP client</b>.\n
N * It will change to @ref SOCK_ESTALBLISHED when the connection-request is successfully accepted.\n
N * Otherwise it will change to @ref SOCK_CLOSED after TCPTO occurred (Sn_IR(TIMEOUT) = .
N */
N#define SOCK_LISTEN                  0x14
N
N/**
N * @brief Connection state
N * @details This indicates Socket n sent the connect-request packet (SYN packet) to a peer.\n
N * It is temporarily shown when @ref Sn_SR is changed from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by CONNECT command.\n
N * If connect-accept(SYN/ACK packet) is received from the peer at SOCK_SYNSENT, it changes to @ref SOCK_ESTABLISHED.\n
N * Otherwise, it changes to @ref SOCK_CLOSED after TCPTO (@ref Sn_IR[TIMEOUT] =  is occurred.
N */
N#define SOCK_SYNSENT                 0x15
N
N/**
N * @brief Connection state
N * @details It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.\n
N * If socket n sends the response (SYN/ACK  packet) to the peer successfully,  it changes to @ref SOCK_ESTABLISHED. \n
N * If not, it changes to @ref SOCK_CLOSED after timeout occurs (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_SYNRECV                 0x16
N
N/**
N * @brief Success to connect
N * @details This indicates the status of the connection of Socket n.\n
N * It changes to @ref SOCK_ESTABLISHED when the b>TCP SERVER</b>processed the SYN packet from the b>TCP CLIENT</b>during @ref SOCK_LISTEN, or
N * when the CONNECT command is successful.\n
N * During @ref SOCK_ESTABLISHED, DATA packet can be transferred using SEND or RECV command.
N */
N#define SOCK_ESTABLISHED             0x17
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_FIN_WAIT                0x18
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_CLOSING                 0x1A
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_TIME_WAIT               0x1B
N
N/**
N * @brief Closing state
N * @details This indicates Socket n received the disconnect-request (FIN packet) from the connected peer.\n
N * This is half-closing status, and data can be transferred.\n
N * For full-closing, DISCON command is used. But For just-closing, CLOSE command is used.
N */
N#define SOCK_CLOSE_WAIT              0x1C
N
N/**
N * @brief Closing state
N * @details This indicates Socket n is waiting for the response (FIN/ACK packet) to the disconnect-request (FIN packet) by passive-close.\n
N * It changes to @ref SOCK_CLOSED when Socket n received the response successfully, or when timeout occurs  (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_LAST_ACK                0x1D
N
N/**
N * @brief UDP socket
N * @details This indicates Socket n is opened in UDP mode(Sn_MR(P[3:0]) = 010.\n
N * It changes to SOCK_UPD when Sn_MR(P[3:0]) = 010 and OPEN command is ordered.\n
N * Unlike TCP mode, data can be transfered without the connection-process.
N */
N#define SOCK_UDP                     0x22
N
N//#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
N
N/**
N * @brief MAC raw mode socket
N * @details This indicates Socket 0 is opened in MACRAW mode (S0_MR(P[3:0]) = 100and is valid only in Socket 0.\n
N * It changes to SOCK_MACRAW when S0_MR(P[3:0] = 100and OPEN command is ordered.\n
N * Like UDP mode socket, MACRAW mode Socket 0 can transfer a MAC packet (Ethernet frame) without the connection-process.
N */
N#define SOCK_MACRAW                  0x42
N
N//#define SOCK_PPPOE                   0x5F
N
N/* IP PROTOCOL */
N#define IPPROTO_IP                   0        //< Dummy for IP 
N#define IPPROTO_ICMP                 1        //< Control message protocol
N#define IPPROTO_IGMP                 2        //< Internet group management protocol
N#define IPPROTO_GGP                  3        //< Gateway^2 (deprecated)
N#define IPPROTO_TCP                  6        //< TCP
N#define IPPROTO_PUP                  12       //< PUP
N#define IPPROTO_UDP                  17       //< UDP
N#define IPPROTO_IDP                  22       //< XNS idp
N#define IPPROTO_ND                   77       //< UNOFFICIAL net disk protocol
N#define IPPROTO_RAW                  255      //< Raw IP packet
N
N
N/**
N * @brief Enter a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n \n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt.\n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * \sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * \sa WIZCHIP_CRITICAL_EXIT()
N */
N#define WIZCHIP_CRITICAL_ENTER()    WIZCHIP.CRIS._enter()
N
N/**
N * @brief Exit a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n\n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt. \n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_ENTER()
N */
N#define WIZCHIP_CRITICAL_EXIT()     WIZCHIP.CRIS._exit()
N
N
N
N////////////////////////
N// Basic I/O Function //
N////////////////////////
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads 1 byte value from a register.
N * @param AddrSel Register address
N * @return The value of register
N */
Nuint8_t  WIZCHIP_READ (uint32_t AddrSel);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes 1 byte value to a register.
N * @param AddrSel Register address
N * @param wb Write data
N * @return void
N */
Nvoid     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads sequence data from registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to read data
N * @param len Data length
N */
Nvoid     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes sequence data to registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to write data
N * @param len Data length
N */
Nvoid     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/////////////////////////////////
N// Common Register I/O function //
N/////////////////////////////////
N/**
N * @ingroup Common_register_access_function
N * @brief Set Mode Register
N * @param (uint8_t)mr The value to be set.
N * @sa getMR()
N */
N#define setMR(mr) \
N	WIZCHIP_WRITE(MR,mr)
X#define setMR(mr) 	WIZCHIP_WRITE(MR,mr)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get Mode Register
N * @return uint8_t. The value of Mode register.
N * @sa setMR()
N */
N#define getMR() \
N		WIZCHIP_READ(MR)
X#define getMR() 		WIZCHIP_READ(MR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set gateway IP address
N * @param (uint8_t*)gar Pointer variable to set gateway IP address. It should be allocated 4 bytes.
N * @sa getGAR()
N */
N#define setGAR(gar) \
N		WIZCHIP_WRITE_BUF(GAR,gar,4)
X#define setGAR(gar) 		WIZCHIP_WRITE_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get gateway IP address
N * @param (uint8_t*)gar Pointer variable to get gateway IP address. It should be allocated 4 bytes.
N * @sa setGAR()
N */
N#define getGAR(gar) \
N		WIZCHIP_READ_BUF(GAR,gar,4)
X#define getGAR(gar) 		WIZCHIP_READ_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set subnet mask address
N * @param (uint8_t*)subr Pointer variable to set subnet mask address. It should be allocated 4 bytes.
N * @sa getSUBR()
N */
N#define setSUBR(subr) \
N		WIZCHIP_WRITE_BUF(SUBR, subr,4)
X#define setSUBR(subr) 		WIZCHIP_WRITE_BUF(SUBR, subr,4)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get subnet mask address
N * @param (uint8_t*)subr Pointer variable to get subnet mask address. It should be allocated 4 bytes.
N * @sa setSUBR()
N */
N#define getSUBR(subr) \
N		WIZCHIP_READ_BUF(SUBR, subr, 4)
X#define getSUBR(subr) 		WIZCHIP_READ_BUF(SUBR, subr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local MAC address
N * @param (uint8_t*)shar Pointer variable to set local MAC address. It should be allocated 6 bytes.
N * @sa getSHAR()
N */
N#define setSHAR(shar) \
N		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
X#define setSHAR(shar) 		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local MAC address
N * @param (uint8_t*)shar Pointer variable to get local MAC address. It should be allocated 6 bytes.
N * @sa setSHAR()
N */
N#define getSHAR(shar) \
N		WIZCHIP_READ_BUF(SHAR, shar, 6)
X#define getSHAR(shar) 		WIZCHIP_READ_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local IP address
N * @param (uint8_t*)sipr Pointer variable to set local IP address. It should be allocated 4 bytes.
N * @sa getSIPR()
N */
N#define setSIPR(sipr) \
N		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
X#define setSIPR(sipr) 		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)sipr Pointer variable to get local IP address. It should be allocated 4 bytes.
N * @sa setSIPR()
N */
N#define getSIPR(sipr) \
N		WIZCHIP_READ_BUF(SIPR, sipr, 4)
X#define getSIPR(sipr) 		WIZCHIP_READ_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set INTLEVEL register
N * @param (uint16_t)intlevel Value to set @ref INTLEVEL register.
N * @sa getINTLEVEL()
N */
N#define setINTLEVEL(intlevel)  {\
N		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); \
N	}
X#define setINTLEVEL(intlevel)  {		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); 	}
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get INTLEVEL register
N * @return uint16_t. Value of @ref INTLEVEL register.
N * @sa setINTLEVEL()
N */
N#define getINTLEVEL() \
N		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
X#define getINTLEVEL() 		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IR register
N * @param (uint8_t)ir Value to set @ref IR register.
N * @sa getIR()
N */
N#define setIR(ir) \
N		WIZCHIP_WRITE(IR, (ir & 0xF0))
X#define setIR(ir) 		WIZCHIP_WRITE(IR, (ir & 0xF0))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IR register
N * @return uint8_t. Value of @ref IR register.
N * @sa setIR()
N */
N#define getIR() \
N		(WIZCHIP_READ(IR) & 0xF0)
X#define getIR() 		(WIZCHIP_READ(IR) & 0xF0)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IMR register
N * @param (uint8_t)imr Value to set @ref IMR register.
N * @sa getIMR()
N */
N#define setIMR(imr) \
N		WIZCHIP_WRITE(IMR, imr)
X#define setIMR(imr) 		WIZCHIP_WRITE(IMR, imr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IMR register
N * @return uint8_t. Value of @ref IMR register.
N * @sa setIMR()
N */
N#define getIMR() \
N		WIZCHIP_READ(IMR)
X#define getIMR() 		WIZCHIP_READ(IMR)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIR register
N * @param (uint8_t)sir Value to set @ref SIR register.
N * @sa getSIR()
N */
N#define setSIR(sir) \
N		WIZCHIP_WRITE(SIR, sir)
X#define setSIR(sir) 		WIZCHIP_WRITE(SIR, sir)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIR register
N * @return uint8_t. Value of @ref SIR register.
N * @sa setSIR()
N */
N#define getSIR() \
N		WIZCHIP_READ(SIR)
X#define getSIR() 		WIZCHIP_READ(SIR)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIMR register
N * @param (uint8_t)simr Value to set @ref SIMR register.
N * @sa getSIMR()
N */
N#define setSIMR(simr) \
N		WIZCHIP_WRITE(SIMR, simr)
X#define setSIMR(simr) 		WIZCHIP_WRITE(SIMR, simr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIMR register
N * @return uint8_t. Value of @ref SIMR register.
N * @sa setSIMR()
N */
N#define getSIMR() \
N		WIZCHIP_READ(SIMR)
X#define getSIMR() 		WIZCHIP_READ(SIMR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RTR register
N * @param (uint16_t)rtr Value to set @ref RTR register.
N * @sa getRTR()
N */
N#define setRTR(rtr)   {\
N		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); \
N	}
X#define setRTR(rtr)   {		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RTR register
N * @return uint16_t. Value of @ref RTR register.
N * @sa setRTR()
N */
N#define getRTR() \
N		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
X#define getRTR() 		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RCR register
N * @param (uint8_t)rcr Value to set @ref RCR register.
N * @sa getRCR()
N */
N#define setRCR(rcr) \
N		WIZCHIP_WRITE(RCR, rcr)
X#define setRCR(rcr) 		WIZCHIP_WRITE(RCR, rcr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RCR register
N * @return uint8_t. Value of @ref RCR register.
N * @sa setRCR()
N */
N#define getRCR() \
N		WIZCHIP_READ(RCR)
X#define getRCR() 		WIZCHIP_READ(RCR)
N
N//================================================== test done ===========================================================
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PTIMER register
N * @param (uint8_t)ptimer Value to set @ref PTIMER register.
N * @sa getPTIMER()
N */
N#define setPTIMER(ptimer) \
N		WIZCHIP_WRITE(PTIMER, ptimer)
X#define setPTIMER(ptimer) 		WIZCHIP_WRITE(PTIMER, ptimer)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PTIMER register
N * @return uint8_t. Value of @ref PTIMER register.
N * @sa setPTIMER()
N */
N#define getPTIMER() \
N		WIZCHIP_READ(PTIMER)
X#define getPTIMER() 		WIZCHIP_READ(PTIMER)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMAGIC register
N * @param (uint8_t)pmagic Value to set @ref PMAGIC register.
N * @sa getPMAGIC()
N */
N#define setPMAGIC(pmagic) \
N		WIZCHIP_WRITE(PMAGIC, pmagic)
X#define setPMAGIC(pmagic) 		WIZCHIP_WRITE(PMAGIC, pmagic)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMAGIC register
N * @return uint8_t. Value of @ref PMAGIC register.
N * @sa setPMAGIC()
N */
N#define getPMAGIC() \
N		WIZCHIP_READ(PMAGIC)
X#define getPMAGIC() 		WIZCHIP_READ(PMAGIC)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set PHAR address
N * @param (uint8_t*)phar Pointer variable to set PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa getPHAR()
N */
N#define setPHAR(phar) \
N		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
X#define setPHAR(phar) 		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)phar Pointer variable to PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa setPHAR()
N */
N#define getPHAR(phar) \
N		WIZCHIP_READ_BUF(PHAR, phar, 6)
X#define getPHAR(phar) 		WIZCHIP_READ_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PSID register
N * @param (uint16_t)psid Value to set @ref PSID register.
N * @sa getPSID()
N */
N#define setPSID(psid)  {\
N		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); \
N	}
X#define setPSID(psid)  {		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PSID register
N * @return uint16_t. Value of @ref PSID register.
N * @sa setPSID()
N */
N//uint16_t getPSID(void);
N#define getPSID() \
N		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
X#define getPSID() 		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMRU register
N * @param (uint16_t)pmru Value to set @ref PMRU register.
N * @sa getPMRU()
N */
N#define setPMRU(pmru) { \
N		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); \
N	}
X#define setPMRU(pmru) { 		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMRU register
N * @return uint16_t. Value of @ref PMRU register.
N * @sa setPMRU()
N */
N#define getPMRU() \
N		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
X#define getPMRU() 		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get unreachable IP address
N * @param (uint8_t*)uipr Pointer variable to get unreachable IP address. It should be allocated 4 bytes.
N */
N#define getUIPR(uipr) \
N		WIZCHIP_READ_BUF(UIPR,uipr,6)
X#define getUIPR(uipr) 		WIZCHIP_READ_BUF(UIPR,uipr,6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref UPORTR register
N * @return uint16_t. Value of @ref UPORTR register.
N */
N#define getUPORTR() \
N	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
X#define getUPORTR() 	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PHYCFGR register
N * @param (uint8_t)phycfgr Value to set @ref PHYCFGR register.
N * @sa getPHYCFGR()
N */
N#define setPHYCFGR(phycfgr) \
N		WIZCHIP_WRITE(PHYCFGR, phycfgr)
X#define setPHYCFGR(phycfgr) 		WIZCHIP_WRITE(PHYCFGR, phycfgr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PHYCFGR register
N * @return uint8_t. Value of @ref PHYCFGR register.
N * @sa setPHYCFGR()
N */
N#define getPHYCFGR() \
N		WIZCHIP_READ(PHYCFGR)
X#define getPHYCFGR() 		WIZCHIP_READ(PHYCFGR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref VERSIONR register
N * @return uint8_t. Value of @ref VERSIONR register.
N */
N#define getVERSIONR() \
N		WIZCHIP_READ(VERSIONR)
X#define getVERSIONR() 		WIZCHIP_READ(VERSIONR)
N
N/////////////////////////////////////
N
N///////////////////////////////////
N// Socket N register I/O function //
N///////////////////////////////////
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)mr Value to set @ref Sn_MR
N * @sa getSn_MR()
N */
N#define setSn_MR(sn, mr) \
N		WIZCHIP_WRITE(Sn_MR(sn),mr)
X#define setSn_MR(sn, mr) 		WIZCHIP_WRITE(Sn_MR(sn),mr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_MR.
N * @sa setSn_MR()
N */
N#define getSn_MR(sn) \
N	WIZCHIP_READ(Sn_MR(sn))
X#define getSn_MR(sn) 	WIZCHIP_READ(Sn_MR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)cr Value to set @ref Sn_CR
N * @sa getSn_CR()
N */
N#define setSn_CR(sn, cr) \
N		WIZCHIP_WRITE(Sn_CR(sn), cr)
X#define setSn_CR(sn, cr) 		WIZCHIP_WRITE(Sn_CR(sn), cr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_CR.
N * @sa setSn_CR()
N */
N#define getSn_CR(sn) \
N		WIZCHIP_READ(Sn_CR(sn))
X#define getSn_CR(sn) 		WIZCHIP_READ(Sn_CR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ir Value to set @ref Sn_IR
N * @sa getSn_IR()
N */
N#define setSn_IR(sn, ir) \
N		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
X#define setSn_IR(sn, ir) 		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IR.
N * @sa setSn_IR()
N */
N#define getSn_IR(sn) \
N		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
X#define getSn_IR(sn) 		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)imr Value to set @ref Sn_IMR
N * @sa getSn_IMR()
N */
N#define setSn_IMR(sn, imr) \
N		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
X#define setSn_IMR(sn, imr) 		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IMR.
N * @sa setSn_IMR()
N */
N#define getSn_IMR(sn) \
N		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
X#define getSn_IMR(sn) 		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_SR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_SR.
N */
N#define getSn_SR(sn) \
N		WIZCHIP_READ(Sn_SR(sn))
X#define getSn_SR(sn) 		WIZCHIP_READ(Sn_SR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)port Value to set @ref Sn_PORT.
N * @sa getSn_PORT()
N */
N#define setSn_PORT(sn, port)  { \
N		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); \
N	}
X#define setSn_PORT(sn, port)  { 		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_PORT.
N * @sa setSn_PORT()
N */
N#define getSn_PORT(sn) \
N		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
X#define getSn_PORT(sn) 		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DHAR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to set socket n destination hardware address. It should be allocated 6 bytes.
N * @sa getSn_DHAR()
N */
N#define setSn_DHAR(sn, dhar) \
N		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
X#define setSn_DHAR(sn, dhar) 		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to get socket n destination hardware address. It should be allocated 6 bytes.
N * @sa setSn_DHAR()
N */
N#define getSn_DHAR(sn, dhar) \
N		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
X#define getSn_DHAR(sn, dhar) 		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to set socket n destination IP address. It should be allocated 4 bytes.
N * @sa getSn_DIPR()
N */
N#define setSn_DIPR(sn, dipr) \
N		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
X#define setSn_DIPR(sn, dipr) 		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to get socket n destination IP address. It should be allocated 4 bytes.
N * @sa SetSn_DIPR()
N */
N#define getSn_DIPR(sn, dipr) \
N		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
X#define getSn_DIPR(sn, dipr) 		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)dport Value to set @ref Sn_DPORT
N * @sa getSn_DPORT()
N */
N#define setSn_DPORT(sn, dport) { \
N		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); \
N	}
X#define setSn_DPORT(sn, dport) { 		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_DPORT.
N * @sa setSn_DPORT()
N */
N#define getSn_DPORT(sn) \
N		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
X#define getSn_DPORT(sn) 		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)mss Value to set @ref Sn_MSSR
N * @sa setSn_MSSR()
N */
N#define setSn_MSSR(sn, mss) { \
N		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); \
N	}
X#define setSn_MSSR(sn, mss) { 		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_MSSR.
N * @sa setSn_MSSR()
N */
N#define getSn_MSSR(sn) \
N		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
X#define getSn_MSSR(sn) 		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)tos Value to set @ref Sn_TOS
N * @sa getSn_TOS()
N */
N#define setSn_TOS(sn, tos) \
N		WIZCHIP_WRITE(Sn_TOS(sn), tos)
X#define setSn_TOS(sn, tos) 		WIZCHIP_WRITE(Sn_TOS(sn), tos)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of Sn_TOS.
N * @sa setSn_TOS()
N */
N#define getSn_TOS(sn) \
N		WIZCHIP_READ(Sn_TOS(sn))
X#define getSn_TOS(sn) 		WIZCHIP_READ(Sn_TOS(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ttl Value to set @ref Sn_TTL
N * @sa getSn_TTL()
N */
N#define setSn_TTL(sn, ttl) \
N		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
X#define setSn_TTL(sn, ttl) 		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TTL.
N * @sa setSn_TTL()
N */
N#define getSn_TTL(sn) \
N		WIZCHIP_READ(Sn_TTL(sn))
X#define getSn_TTL(sn) 		WIZCHIP_READ(Sn_TTL(sn))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)rxbufsize Value to set @ref Sn_RXBUF_SIZE
N * @sa getSn_RXBUF_SIZE()
N */
N#define setSn_RXBUF_SIZE(sn, rxbufsize) \
N		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
X#define setSn_RXBUF_SIZE(sn, rxbufsize) 		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_RXBUF_SIZE.
N * @sa setSn_RXBUF_SIZE()
N */
N#define getSn_RXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
X#define getSn_RXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)txbufsize Value to set @ref Sn_TXBUF_SIZE
N * @sa getSn_TXBUF_SIZE()
N */
N#define setSn_TXBUF_SIZE(sn, txbufsize) \
N		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
X#define setSn_TXBUF_SIZE(sn, txbufsize) 		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TXBUF_SIZE.
N * @sa setSn_TXBUF_SIZE()
N */
N#define getSn_TXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
X#define getSn_TXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_FSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_FSR.
N */
Nuint16_t getSn_TX_FSR(uint8_t sn);
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_RD.
N */
N#define getSn_TX_RD(sn) \
N		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
X#define getSn_TX_RD(sn) 		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)txwr Value to set @ref Sn_TX_WR
N * @sa GetSn_TX_WR()
N */
N#define setSn_TX_WR(sn, txwr) { \
N		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); \
N		}
X#define setSn_TX_WR(sn, txwr) { 		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); 		}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_WR.
N * @sa setSn_TX_WR()
N */
N#define getSn_TX_WR(sn) \
N		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
X#define getSn_TX_WR(sn) 		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_RSR.
N */
Nuint16_t getSn_RX_RSR(uint8_t sn);
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)rxrd Value to set @ref Sn_RX_RD
N * @sa getSn_RX_RD()
N */
N#define setSn_RX_RD(sn, rxrd) { \
N		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); \
N	}
X#define setSn_RX_RD(sn, rxrd) { 		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @regurn uint16_t. Value of @ref Sn_RX_RD.
N * @sa setSn_RX_RD()
N */
N#define getSn_RX_RD(sn) \
N		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
X#define getSn_RX_RD(sn) 		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_WR.
N */
N#define getSn_RX_WR(sn) \
N		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
X#define getSn_RX_WR(sn) 		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)frag Value to set @ref Sn_FRAG
N * @sa getSn_FRAD()
N */
N#define setSn_FRAG(sn, frag) { \
N		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); \
N	}
X#define setSn_FRAG(sn, frag) { 		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_FRAG.
N * @sa setSn_FRAG()
N */
N#define getSn_FRAG(sn) \
N		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
X#define getSn_FRAG(sn) 		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)kpalvt Value to set @ref Sn_KPALVTR
N * @sa getSn_KPALVTR()
N */
N#define setSn_KPALVTR(sn, kpalvt) \
N		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
X#define setSn_KPALVTR(sn, kpalvt) 		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_KPALVTR.
N * @sa setSn_KPALVTR()
N */
N#define getSn_KPALVTR(sn) \
N		WIZCHIP_READ(Sn_KPALVTR(sn))
X#define getSn_KPALVTR(sn) 		WIZCHIP_READ(Sn_KPALVTR(sn))
N
N//////////////////////////////////////
N
N/////////////////////////////////////
N// Sn_TXBUF & Sn_RXBUF IO function //
N/////////////////////////////////////
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameter.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n RX max buffer size.
N */
N#define getSn_RxMAX(sn) \
N		(getSn_RXBUF_SIZE(sn) << 10)
X#define getSn_RxMAX(sn) 		(getSn_RXBUF_SIZE(sn) << 10)
N
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameters.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n TX max buffer size.
N */
N//uint16_t getSn_TxMAX(uint8_t sn);
N#define getSn_TxMAX(sn) \
N		(getSn_TXBUF_SIZE(sn) << 10)
X#define getSn_TxMAX(sn) 		(getSn_TXBUF_SIZE(sn) << 10)
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to internal TX memory
N *
N * @details This function reads the Tx write pointer register and after that,
N * it copies the <i>wizdata(pointer buffer)</i> of the length of <i>len(variable)</i> bytes to internal TX memory
N * and updates the Tx write pointer register.
N * This function is being called by send() and sendto() function also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to write data
N * @param len Data length
N * @sa wiz_recv_data()
N */
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to your buffer from internal RX memory
N *
N * @details This function read the Rx read pointer register and after that,
N * it copies the received data from internal RX memory
N * to <i>wizdata(pointer variable)</i> of the length of <i>len(variable)</i> bytes.
N * This function is being called by recv() also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to read data
N * @param len Data length
N * @sa wiz_send_data()
N */
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It discard the received data in RX memory.
N * @details It discards the data of the length of <i>len(variable)</i> bytes in internal RX memory.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param len Data length
N */
Nvoid wiz_recv_ignore(uint8_t sn, uint16_t len);
N
N#endif   // _W5500_H_
L 115 "..\..\Ethernet\wizchip_conf.h" 2
N#else 
S   #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
N#endif
N
N#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
N#endif
N
N/**
N * @brief Define I/O base address when BUS IF mode.
N * @todo Should re-define it to fit your system when BUS IF Mode (@ref \_WIZCHIP_IO_MODE_BUS_,
N *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
N *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
N */
N#define _WIZCHIP_IO_BASE_              0x00000000  // 
N
N#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
X#if (0x0200 + 1) & _WIZCHIP_IO_MODE_BUS
S   #ifndef _WIZCHIP_IO_BASE_
S      #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
S   #endif
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   #define _WIZCHIP_SOCK_NUM_   8   ///< The count of independant socket of @b WIZCHIP
N#else
S   #define _WIZCHIP_SOCK_NUM_   4   ///< The count of independant socket of @b WIZCHIP
N#endif      
N
N
N/********************************************************
N* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
N*********************************************************/
N/**
N * @ingroup DATA_TYPE
N * @brief The set of callback functions for W5500:@ref WIZCHIP_IO_Functions W5200:@ref WIZCHIP_IO_Functions_W5200
N */
Ntypedef struct __WIZCHIP
N{
N   uint16_t  if_mode;               ///< host interface mode
N   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
N   /**
N    * The set of critical section callback func.
N    */
N   struct _CRIS
N   {
N      void (*_enter)  (void);       ///< crtical section enter 
N      void (*_exit) (void);         ///< critial section exit  
N   }CRIS;  
N   /**
N    *  The set of @ref\_WIZCHIP_ select control callback func.
N    */
N   struct _CS
N   {
N      void (*_select)  (void);      ///< @ref \_WIZCHIP_ selected
N      void (*_deselect)(void);      ///< @ref \_WIZCHIP_ deselected
N   }CS;  
N   /**
N    * The set of interface IO callback func.
N    */
N   union _IF
N   {	 
N      /**
N       * For BUS interface IO
N       */  
N      struct
N      {
N         uint8_t  (*_read_byte)  (uint32_t AddrSel);
N         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
N      }BUS;      
N      /**
N       * For SPI interface IO
N       */
N      struct
N      {
N         uint8_t (*_read_byte)   (void);
N         void    (*_write_byte)  (uint8_t wb);
N      }SPI;
N      // To be added
N      //
N   }IF;
N}_WIZCHIP;
N
Nextern _WIZCHIP  WIZCHIP;
N
N/**
N * @ingroup DATA_TYPE
N *  WIZCHIP control type enumration used in @ref ctlwizchip().
N */
Ntypedef enum
N{
N   CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
N   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
N   CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
N   CW_CLR_INTERRUPT,   ///< Clears interrupt
N   CW_SET_INTRMASK,    ///< Masks interrupt
N   CW_GET_INTRMASK,    ///< Get interrupt mask
N   CW_SET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_ID,          ///< Gets WIZCHIP name.
N
N#if _WIZCHIP_ ==  5500
X#if 5500 ==  5500
N   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
N   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
N   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
N   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
N   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
N#endif
N   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
N   CW_GET_PHYLINK      ///< Get PHY Link status
N}ctlwizchip_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Network control type enumration used in @ref ctlnetwork().
N */
Ntypedef enum
N{
N   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
N   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
N   CN_SET_NETMODE,  ///< Set network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_GET_NETMODE,  ///< Get network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_SET_TIMEOUT,  ///< Set network timeout as retry count and time.
N   CN_GET_TIMEOUT,  ///< Get network timeout as retry count and time.
N}ctlnetwork_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Interrupt kind when CW_SET_INTRRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK
N *  and CW_GET_INTRMASK is used in @ref ctlnetwork().
N *  It can be used with OR operation.
N */
Ntypedef enum
N{
N#if _WIZCHIP_ > 5200
X#if 5500 > 5200
N   IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
N#endif   
N
N   IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
N
N#if _WIZCHIP_ != 5200
X#if 5500 != 5200
N   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
N#endif   
N
N   IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
N
N   IK_SOCK_0            = (1 << 8),   ///< Socket 0 interrupt
N   IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
N   IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
N   IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
N#if _WIZCHIP_ > 5100   
X#if 5500 > 5100   
N   IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
N   IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
N   IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
N   IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
N#else
S   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
N#endif      
N}intr_kind;
N
N#define PHY_CONFBY_HW            0     ///< Configured PHY operation mode by HW pin
N#define PHY_CONFBY_SW            1     ///< Configured PHY operation mode by SW register   
N#define PHY_MODE_MANUAL          0     ///< Configured PHY operation mode with user setting.
N#define PHY_MODE_AUTONEGO        1     ///< Configured PHY operation mode with auto-negotiation
N#define PHY_SPEED_10             0     ///< Link Speed 10
N#define PHY_SPEED_100            1     ///< Link Speed 100
N#define PHY_DUPLEX_HALF          0     ///< Link Half-Duplex
N#define PHY_DUPLEX_FULL          1     ///< Link Full-Duplex
N#define PHY_LINK_OFF             0     ///< Link Off
N#define PHY_LINK_ON              1     ///< Link On
N#define PHY_POWER_NORM           0     ///< PHY power normal mode
N#define PHY_POWER_DOWN           1     ///< PHY power down mode 
N
N
N#if _WIZCHIP_ == 5500 
X#if 5500 == 5500 
N/**
N * @ingroup DATA_TYPE
N *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
N *  and it indicates the real PHY status configured by HW or SW in all WIZCHIP. \n
N *  Valid only in W5500.
N */
Ntypedef struct wiz_PhyConf_t
N{
N      uint8_t by;       ///< set by @ref PHY_CONFBY_HW or @ref PHY_CONFBY_SW
N      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL or @ref PHY_MODE_AUTONEGO
N      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
N      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
N      //uint8_t power;  ///< set by @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N      //uint8_t link;   ///< Valid only in CW_GET_PHYSTATUS. set by @ref PHY_LINK_ON or PHY_DUPLEX_OFF 
N   }wiz_PhyConf;
N#endif   
N
N/**
N * @ingroup DATA_TYPE
N *  It used in setting dhcp_mode of @ref wiz_NetInfo.
N */
Ntypedef enum
N{
N   NETINFO_STATIC = 1,    ///< Static IP configuration by manually.
N   NETINFO_DHCP           ///< Dynamic IP configruation from a DHCP sever
N}dhcp_mode;
N
N/**
N * @ingroup DATA_TYPE
N *  Network Information for WIZCHIP
N */
Ntypedef struct wiz_NetInfo_t
N{
N   uint8_t mac[6];  ///< Source Mac Address
N   uint8_t ip[4];   ///< Source IP Address
N   uint8_t sn[4];   ///< Subnet Mask 
N   uint8_t gw[4];   ///< Gateway IP Address
N   uint8_t dns[4];  ///< DNS server IP Address
N   dhcp_mode dhcp;  ///< 1 - Static, 2 - DHCP
N}wiz_NetInfo;
N
N/**
N * @ingroup DATA_TYPE
N *  Network mode
N */
Ntypedef enum
N{
N#if _WIZCHIP_ == 5500   
X#if 5500 == 5500   
N   NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
N#endif   
N   NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
N   NM_PINGBLOCK   = (1<<4),  ///< Block ping-request
N   NM_PPPOE       = (1<<3),  ///< PPPoE mode
N}netmode_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Used in CN_SET_TIMEOUT or CN_GET_TIMEOUT of @ref ctlwizchip() for timeout configruation.
N */
Ntypedef struct wiz_NetTimeout_t
N{
N   uint8_t  retry_cnt;     ///< retry count 
N   uint16_t time_100us;    ///< time unit 100us
N}wiz_NetTimeout;
N
N/**
N *@brief Registers call back function for critical section of I/O functions such as
N *\ref WIZCHIP_READ, @ref WIZCHIP_WRITE, @ref WIZCHIP_READ_BUF and @ref WIZCHIP_WRITE_BUF.
N *@param cris_en : callback function for critical section enter.
N *@param cris_ex : callback function for critical section exit.
N *@todo Describe @ref WIZCHIP_CRITICAL_ENTER and @ref WIZCHIP_CRITICAL_EXIT marco or register your functions.
N *@note If you do not describe or register, default functions(@ref wizchip_cris_enter & @ref wizchip_cris_exit) is called.
N */
Nvoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
N
N
N/**
N *@brief Registers call back function for WIZCHIP select & deselect.
N *@param cs_sel : callback function for WIZCHIP select
N *@param cs_desel : callback fucntion for WIZCHIP deselect
N *@todo Describe @ref wizchip_cs_select and @ref wizchip_cs_deselect function or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
N
N/**
N *@brief Registers call back function for bus interface.
N *@param bus_rb   : callback function to read byte data using system bus
N *@param bus_wb   : callback function to write byte data using system bus
N *@todo Describe @ref wizchip_bus_readbyte and @ref wizchip_bus_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
N
N/**
N *@brief Registers call back function for SPI interface.
N *@param spi_rb : callback function to read byte usig SPI 
N *@param spi_wb : callback function to write byte usig SPI 
N *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb));
N
N/**
N * @ingroup extra_functions
N * @brief Controls to the WIZCHIP.
N * @details Resets WIZCHIP & internal PHY, Configures PHY mode, Monitor PHY(Link,Speed,Half/Full/Auto),
N * controls interrupt & mask and so on.
N * @param cwtype : Decides to the control type
N * @param arg : arg type is dependent on cwtype.
N * @return  0 : Success \n
N *         -1 : Fail because of invalid \ref ctlwizchip_type or unsupported \ref ctlwizchip_type in WIZCHIP 
N */          
Nint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network.
N * @details Controls to network environment, mode, timeout and so on.
N * @param cntype : Input. Decides to the control type
N * @param arg : Inout. arg type is dependent on cntype.
N * @return -1 : Fail because of invalid \ref ctlnetwork_type or unsupported \ref ctlnetwork_type in WIZCHIP \n
N *          0 : Success      
N */          
Nint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
N
N
N/* 
N * The following functions are implemented for internal use. 
N * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
N */
N 
N/**
N * @ingroup extra_functions
N * @brief Reset WIZCHIP by softly.
N */ 
Nvoid   wizchip_sw_reset(void);
N
N/**
N * @ingroup extra_functions
N * @brief Initializes WIZCHIP with socket buffer size
N * @param txsize Socket tx buffer sizes. If null, initialized the default size 2KB.
N * @param rxsize Socket rx buffer sizes. If null, initialized the default size 2KB.
N * @return 0 : succcess \n
N *        -1 : fail. Invalid buffer size
N */
Nint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
N
N/** 
N * @ingroup extra_functions
N * @brief Clear Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_clrinterrupt(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt of WIZCHIP.
N * @return @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterrupt(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Mask or Unmask Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_setinterruptmask(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt mask of WIZCHIP.
N * @return : The operated OR vaule of @ref intr_kind. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterruptmask(void);
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
N   int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
N#endif
N
N#if _WIZCHIP_ == 5500
X#if 5500 == 5500
N   void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
N/**
N * @ingroup extra_functions
N * @brief Set the phy information for WIZCHIP without power mode
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_setphyconf(wiz_PhyConf* phyconf);  
N /**
N * @ingroup extra_functions
N * @brief Get phy configuration information.
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_getphyconf(wiz_PhyConf* phyconf); 
N /**
N * @ingroup extra_functions
N * @brief Get phy status.
N * @param phyconf : @ref wiz_PhyConf
N */ 
N   void   wizphy_getphystat(wiz_PhyConf* phyconf);
N /**
N * @ingroup extra_functions
N * @brief set the power mode of phy inside WIZCHIP. Refer to @ref PHYCFGR in W5500, @ref PHYSTATUS in W5200
N * @param pmode Settig value of power down mode.
N */   
N   int8_t wizphy_setphypmode(uint8_t pmode);    
N#endif
N
N/**
N* @ingroup extra_functions
N * @brief Set the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @param pnetinfo Value of network mode. Refer to @ref netmode_type.
N */
Nint8_t wizchip_setnetmode(netmode_type netmode);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @return Value of network mode. Refer to @ref netmode_type.
N */
Nnetmode_type wizchip_getnetmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_settimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_gettimeout(wiz_NetTimeout* nettime);
N
N#endif   // _WIZCHIP_CONF_H_
L 85 "..\..\Ethernet\socket.h" 2
N
N#define SOCKET                uint8_t  ///< SOCKET type define for legacy driver
N
N#define SOCK_OK               1        ///< Result is OK about socket process.
N#define SOCK_BUSY             0        ///< Socket is busy on processing the operation. Valid only Non-block IO Mode.
N#define SOCK_FATAL            -1000    ///< Result is fatal error about socket process.
N
N#define SOCK_ERROR            0        
N#define SOCKERR_SOCKNUM       (SOCK_ERROR - 1)     ///< Invalid socket number
N#define SOCKERR_SOCKOPT       (SOCK_ERROR - 2)     ///< Invalid socket option
N#define SOCKERR_SOCKINIT      (SOCK_ERROR - 3)     ///< Socket is not initialized
N#define SOCKERR_SOCKCLOSED    (SOCK_ERROR - 4)     ///< Socket unexpectedly closed.
N#define SOCKERR_SOCKMODE      (SOCK_ERROR - 5)     ///< Invalid socket mode for socket operation.
N#define SOCKERR_SOCKFLAG      (SOCK_ERROR - 6)     ///< Invalid socket flag
N#define SOCKERR_SOCKSTATUS    (SOCK_ERROR - 7)     ///< Invalid socket status for socket operation.
N#define SOCKERR_ARG           (SOCK_ERROR - 10)    ///< Invalid argrument.
N#define SOCKERR_PORTZERO      (SOCK_ERROR - 11)    ///< Port number is zero
N#define SOCKERR_IPINVALID     (SOCK_ERROR - 12)    ///< Invalid IP address
N#define SOCKERR_TIMEOUT       (SOCK_ERROR - 13)    ///< Timeout occurred
N#define SOCKERR_DATALEN       (SOCK_ERROR - 14)    ///< Data length is zero or greater than buffer max size.
N#define SOCKERR_BUFFER        (SOCK_ERROR - 15)    ///< Socket buffer is not enough for data communication.
N
N#define SOCKFATAL_PACKLEN     (SOCK_FATAL - 1)     ///< Invalid packet length. Fatal Error.
N
N/*
N * SOCKET FLAG
N */
N#define SF_ETHER_OWN           (Sn_MR_MFEN)        ///< In \ref Sn_MR_MACRAW, Receive only the packet as broadcast, multicast and own packet
N#define SF_IGMP_VER2           (Sn_MR_MC)          ///< In \ref Sn_MR_UDP with \ref SF_MULTI_ENABLE, Select IGMP version 2.   
N#define SF_TCP_NODELAY         (Sn_MR_ND)          ///< In \ref Sn_MR_TCP, Use to nodelayed ack.
N#define SF_MULTI_ENABLE        (Sn_MR_MULTI)       ///< In \ref Sn_MR_UDP, Enable multicast mode.
N
N#if _WIZCHIP_ == 5500
X#if 5500 == 5500
N   #define SF_BROAD_BLOCK         (Sn_MR_BCASTB)   ///< In \ref Sn_MR_UDP or \ref Sn_MR_MACRAW, Block broadcast packet. Valid only in W5500
N   #define SF_MULTI_BLOCK         (Sn_MR_MMB)      ///< In \ref Sn_MR_MACRAW, Block multicast packet. Valid only in W5500
N   #define SF_IPv6_BLOCK          (Sn_MR_MIP6B)    ///< In \ref Sn_MR_MACRAW, Block IPv6 packet. Valid only in W5500
N   #define SF_UNI_BLOCK           (Sn_MR_UCASTB)   ///< In \ref Sn_MR_UDP with \ref SF_MULTI_ENABLE. Valid only in W5500
N#endif
N
N#define SF_IO_NONBLOCK           0x01              ///< Socket nonblock io mode. It used parameter in \ref socket().
N
N/*
N * UDP & MACRAW Packet Infomation
N */
N#define PACK_FIRST               0x80              ///< In Non-TCP packet, It indicates to start receiving a packet.
N#define PACK_REMAINED            0x01              ///< In Non-TCP packet, It indicates to remain a packet to be received.
N#define PACK_COMPLETED           0x00              ///< In Non-TCP packet, It indicates to complete to receive a packet.
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Open a socket.
N * @details Initializes the socket with 'sn' passed as parameter and open.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param protocol Protocol type to operate such as TCP, UDP and MACRAW.
N * @param port Port number to be bined.
N * @param flag Socket flags as \ref SF_ETHER_OWN, \ref SF_IGMP_VER2, \ref SF_TCP_NODELAY, \ref SF_MULTI_ENABLE, \ref SF_IO_NONBLOCK and so on.\n
N *             Valid flags only in W5500 : @ref SF_BROAD_BLOCK, @ref SF_MULTI_BLOCK, @ref SF_IPv6_BLOCK, and @ref SF_UNI_BLOCK.
N * @sa Sn_MR
N *
N * @return @b Success : The socket number @b 'sn' passed as parameter\n
N *         @b Fail    :\n @ref SOCKERR_SOCKNUM     - Invalid socket number\n
N *                        @ref SOCKERR_SOCKMODE    - Not support socket mode as TCP, UDP, and so on. \n
N *                        @ref SOCKERR_SOCKFLAG    - Invaild socket flag.
N */
Nint8_t  socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Close a socket.
N * @details It closes the socket  with @b'sn' passed as parameter.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N *
N * @return @b Success : @ref SOCK_OK \n
N *         @b Fail    : @ref SOCKERR_SOCKNUM - Invalid socket number
N */
Nint8_t  close(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Listen to a connection request from a client.
N * @details It is listening to a connection request from a client.
N * If connection request is accepted successfully, the connection is established. Socket sn is used in passive(server) mode.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @return @b Success : @ref SOCK_OK \n
N *         @b Fail    :\n @ref SOCKERR_SOCKINIT   - Socket is not initialized \n
N *                        @ref SOCKERR_SOCKCLOSED - Socket closed unexpectedly.
N */
Nint8_t  listen(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Try to connect a server.
N * @details It requests connection to the server with destination IP address and port number passed as parameter.\n
N * @note It is valid only in TCP client mode. 
N *       In block io mode, it does not return until connection is completed.
N *       In Non-block io mode, it return @ref SOCK_BUSY immediatly.
N *
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param addr Pointer variable of destination IP address. It should be allocated 4 bytes.
N * @param port Destination port number.
N *
N * @return @b Success : @ref SOCK_OK \n
N * @b Fail    :\n @ref SOCKERR_SOCKNUM   - Invalid socket number\n
N *                @ref SOCKERR_SOCKMODE  - Invalid socket mode\n
N *                @ref SOCKERR_SOCKINIT  - Socket is not initialized\n
N *                @ref SOCKERR_IPINVALID - Wrong server IP address\n
N *                @ref SOCKERR_PORTZERO  - Server port zero\n
N *                @ref SOCKERR_TIMEOUT   - Timeout occurred during request connection\n
N *                @ref SOCK_BUSY         - In non-block io mode, it returned immediatly\n 
N */
Nint8_t  connect(uint8_t sn, uint8_t * addr, uint16_t port);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Try to disconnect a connection socket.
N * @details It sends request message to disconnect the TCP socket 'sn' passed as parameter to the server or client.
N * @note It is valid only in TCP server or client mode. \n
N *       In block io mode, it does not return until disconnection is completed. \n
N *       In Non-block io mode, it return @ref SOCK_BUSY immediatly. \n
N
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @return @b Success :   @ref SOCK_OK \n
N *         @b Fail    :\n @ref SOCKERR_SOCKNUM  - Invalid socket number \n
N *                        @ref SOCKERR_SOCKMODE - Invalid operation in the socket \n
N *                        @ref SOCKERR_TIMEOUT  - Timeout occurred \n
N *                        @ref SOCK_BUSY        - Socket is busy.
N */
Nint8_t  disconnect(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief	Send data to the connected peer in TCP socket.
N * @details It is used to send outgoing data to the connected socket.
N * @note    It is valid only in TCP server or client mode. It can't send data greater than socket buffer size. \n
N *          In block io mode, It doesn't return until data send is completed - socket buffer size is greater than data. \n
N *          In non-block io mode, It return @ref SOCK_BUSY immediatly when socket buffer is not enough. \n
N * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf Pointer buffer containing data to be sent.
N * @param len The byte length of data in buf.
N * @return	@b Success : The sent data size \n
N *          @b Fail    : \n @ref SOCKERR_SOCKSTATUS - Invalid socket status for socket operation \n
N *                          @ref SOCKERR_TIMEOUT    - Timeout occurred \n
N *                          @ref SOCKERR_SOCKMODE 	- Invalid operation in the socket \n
N *                          @ref SOCKERR_SOCKNUM    - Invalid socket number \n
N *                          @ref SOCKERR_DATALEN    - zero data length \n
N *                          @ref SOCK_BUSY          - Socket is busy.
N */
Nint32_t send(uint8_t sn, uint8_t * buf, uint16_t len);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief	Receive data from the connected peer.
N * @details It is used to read incoming data from the connected socket.\n
N *          It waits for data as much as the application wants to receive.
N * @note    It is valid only in TCP server or client mode. It can't receive data greater than socket buffer size. \n
N *          In block io mode, it doesn't return until data reception is completed - data is filled as <I>len</I> in socket buffer. \n
N *          In non-block io mode, it return @ref SOCK_BUSY immediatly when <I>len</I> is greater than data size in socket buffer. \n
N *
N * @param sn  Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf Pointer buffer to read incoming data.
N * @param len The max data length of data in buf.
N * @return	@b Success : The real received data size \n
N *          @b Fail    :\n
N *                     @ref SOCKERR_SOCKSTATUS - Invalid socket status for socket operation \n
N *                     @ref SOCKERR_SOCKMODE   - Invalid operation in the socket \n
N *                     @ref SOCKERR_SOCKNUM    - Invalid socket number \n
N *                     @ref SOCKERR_DATALEN    - zero data length \n
N *                     @ref SOCK_BUSY          - Socket is busy.
N */
Nint32_t recv(uint8_t sn, uint8_t * buf, uint16_t len);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief	Sends datagram to the peer with destination IP address and port number passed as parameter.
N * @details It sends datagram of UDP or MACRAW to the peer with destination IP address and port number passed as parameter.\n
N *          Even if the connectionless socket has been previously connected to a specific address,
N *          the address and port number parameters override the destination address for that particular datagram only.
N * @note    In block io mode, It doesn't return until data send is completed - socket buffer size is greater than <I>len</I>.
N *          In non-block io mode, It return @ref SOCK_BUSY immediatly when socket buffer is not enough.
N *
N * @param sn    Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf   Pointer buffer to send outgoing data.
N * @param len   The byte length of data in buf.
N * @param addr  Pointer variable of destination IP address. It should be allocated 4 bytes.
N * @param port  Destination port number.
N *
N * @return @b Success : The sent data size \n
N *         @b Fail    :\n @ref SOCKERR_SOCKNUM     - Invalid socket number \n
N *                        @ref SOCKERR_SOCKMODE    - Invalid operation in the socket \n
N *                        @ref SOCKERR_SOCKSTATUS  - Invalid socket status for socket operation \n
N *                        @ref SOCKERR_DATALEN     - zero data length \n
N *                        @ref SOCKERR_IPINVALID   - Wrong server IP address\n
N *                        @ref SOCKERR_PORTZERO    - Server port zero\n
N *                        @ref SOCKERR_SOCKCLOSED  - Socket unexpectedly closed \n
N *                        @ref SOCKERR_TIMEOUT     - Timeout occurred \n
N *                        @ref SOCK_BUSY           - Socket is busy. 
N */
Nint32_t sendto(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Receive datagram of UDP or MACRAW
N * @details This function is an application I/F function which is used to receive the data in other then TCP mode. \n
N *          This function is used to receive UDP and MAC_RAW mode, and handle the header as well. 
N *          This function can divide to received the packet data.
N *          On the MACRAW SOCKET, the addr and port parameters are ignored.
N * @note    In block io mode, it doesn't return until data reception is completed - data is filled as <I>len</I> in socket buffer
N *          In non-block io mode, it return @ref SOCK_BUSY immediatly when <I>len</I> is greater than data size in socket buffer.
N *
N * @param sn   Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
N * @param buf  Pointer buffer to read incoming data.
N * @param len  The max data length of data in buf. 
N *             When the received packet size <= len, receives data as packet sized.
N *             When others, receives data as len.
N * @param addr Pointer variable of destination IP address. It should be allocated 4 bytes.
N *             It is valid only when the first call recvfrom for receiving the packet.
N *             When it is valid, @ref  packinfo[7] should be set as '1' after call @ref getsockopt(sn, SO_PACKINFO, &packinfo).
N * @param port Pointer variable of destination port number.
N *             It is valid only when the first call recvform for receiving the packet.
N*             When it is valid, @ref  packinfo[7] should be set as '1' after call @ref getsockopt(sn, SO_PACKINFO, &packinfo).
N *
N * @return	@b Success : This function return real received data size for success.\n
N *          @b Fail    : @ref SOCKERR_DATALEN    - zero data length \n
N *                       @ref SOCKERR_SOCKMODE   - Invalid operation in the socket \n
N *                       @ref SOCKERR_SOCKNUM    - Invalid socket number \n
N *                       @ref SOCKBUSY           - Socket is busy.
N */
Nint32_t recvfrom(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port);
N
N
N/////////////////////////////
N// SOCKET CONTROL & OPTION //
N/////////////////////////////
N#define SOCK_IO_BLOCK         0  ///< Socket Block IO Mode in @ref setsockopt().
N#define SOCK_IO_NONBLOCK      1  ///< Socket Non-block IO Mode in @ref setsockopt().
N
N/**
N * @defgroup DATA_TYPE DATA TYPE
N */
N
N/**
N * @ingroup DATA_TYPE
N * @brief The kind of Socket Interrupt.
N * @sa Sn_IR, Sn_IMR, setSn_IR(), getSn_IR(), setSn_IMR(), getSn_IMR()
N */
Ntypedef enum
N{
N   SIK_CONNECTED     = (1 << 0),    ///< conntected
N   SIK_DISCONNECTED  = (1 << 1),    ///< disconnected
N   SIK_RECEIVED      = (1 << 2),    ///< data received
N   SIK_TIMEOUT       = (1 << 3),    ///< timeout occured
N   SIK_SENT          = (1 << 4),    ///< send ok
N   SIK_ALL           = 0x1F,        ///< all interrupt
N}sockint_kind;
N
N/**
N * @ingroup DATA_TYPE
N * @brief The type of @ref ctlsocket().
N */
Ntypedef enum
N{
N   CS_SET_IOMODE,          ///< set socket IO mode with @ref SOCK_IO_BLOCK or @ref SOCK_IO_NONBLOCK
N   CS_GET_IOMODE,          ///< get socket IO mode
N   CS_GET_MAXTXBUF,        ///< get the size of socket buffer allocated in TX memory
N   CS_GET_MAXRXBUF,        ///< get the size of socket buffer allocated in RX memory
N   CS_CLR_INTERRUPT,       ///< clear the interrupt of socket with @ref sockint_kind
N   CS_GET_INTERRUPT,       ///< get the socket interrupt. refer to @ref sockint_kind
N   CS_SET_INTMASK,         ///< set the interrupt mask of socket with @ref sockint_kind
N   CS_GET_INTMASK          ///< get the masked interrupt of socket. refer to @ref sockint_kind
N}ctlsock_type;
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief The type of socket option in @ref setsockopt() or @ref getsockopt()
N */ 
Ntypedef enum
N{
N   SO_FLAG,           ///< Valid only in getsockopt(), For set flag of socket refer to <I>flag</I> in @ref socket().
N   SO_TTL,              ///< Set/Get TTL. @ref Sn_TTL  ( @ref setSn_TTL(), @ref getSn_TTL() )
N   SO_TOS,              ///< Set/Get TOS. @ref Sn_TOS  ( @ref setSn_TOS(), @ref getSn_TOS() )
N   SO_MSS,              ///< Set/Get MSS. @ref Sn_MSSR ( @ref setSn_MSSR(), @ref getSn_MSSR() )
N   SO_DESTIP,           ///< Set/Get the destination IP address. @ref Sn_DIPR ( @ref setSn_DIPR(), @ref getSn_DIPR() )
N   SO_DESTPORT,         ///< Set/Get the destionation Port number. @ref Sn_DPORT ( @ref setSn_DPORT(), @ref getSn_DPORT() )
N#if _WIZCHIP_ != 5100   
X#if 5500 != 5100   
N   SO_KEEPALIVESEND,    ///< Valid only in setsockopt. Manually send keep-alive packet in TCP mode
N   #if _WIZCHIP_ > 5200   
X   #if 5500 > 5200   
N      SO_KEEPALIVEAUTO, ///< Set/Get keep-alive auto transmittion timer in TCP mode
N   #endif      
N#endif
N   SO_SENDBUF,          ///< Valid only in getsockopt. Get the free data size of Socekt TX buffer. @ref Sn_TX_FSR, @ref getSn_TX_FSR()
N   SO_RECVBUF,          ///< Valid only in getsockopt. Get the received data size in socket RX buffer. @ref Sn_RX_RSR, @ref getSn_RX_RSR()
N   SO_STATUS,           ///< Valid only in getsockopt. Get the socket status. @ref Sn_SR, @ref getSn_SR()
N   SO_REMAINSIZE,       ///< Valid only in getsockopt. Get the remained packet size in other then TCP mode.
N   SO_PACKINFO          ///< Valid only in getsockopt. Get the packet information as @ref PACK_FIRST, @ref PACK_REMAINED, and @ref PACK_COMPLETED in other then TCP mode.
N}sockopt_type;
N
N/**
N * @ingroup WIZnet_socket_APIs
N *  @brief Control socket.
N *  @details Control IO mode, Interrupt & Mask of socket and get the socket buffer information.
N *           Refer to @ref ctlsock_type.
N *  @param sn socket number
N *  @param cstype type of control socket. refer to @ref ctlsock_type.
N *  @param arg Data type and value is determined according to @ref ctlsock_type. \n
N *             <table>
N *                  <tr> <td> @b cstype </td> <td> @b data type</td><td>@b value</td></tr>
N *                  <tr> <td> @ref CS_SET_IOMODE \n @ref CS_GET_IOMODE </td> <td> uint8_t </td><td>@ref SOCK_IO_BLOCK @ref SOCK_IO_NONBLOCK</td></tr>
N *                  <tr> <td> @ref CS_GET_MAXTXBUF \n @ref CS_GET_MAXRXBUF </td> <td> uint16_t </td><td> 0 ~ 16K </td></tr>
N *                  <tr> <td> @ref CS_CLR_INTERRUPT \n @ref CS_GET_INTERRUPT \n @ref CS_SET_INTMASK \n @ref CS_GET_INTMASK </td> <td> @ref sockint_kind </td><td> @ref SIK_CONNECTED, etc.  </td></tr> 
N *             </table>
N *  @return @b Success @ref SOCK_OK \n
N *          @b fail    @ref SOCKERR_ARG         - Invalid argument\n
N */
Nint8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg);
N
N/** 
N * @ingroup WIZnet_socket_APIs
N *  @brief set socket options
N *  @details Set socket option like as TTL, MSS, TOS, and so on. Refer to @ref sockopt_type.
N *               
N *  @param sn socket number
N *  @param sotype socket option type. refer to @ref sockopt_type
N *  @param arg Data type and value is determined according to <I>sotype</I>. \n
N *             <table>
N *                  <tr> <td> @b sotype </td> <td> @b data type</td><td>@b value</td></tr> 
N *                  <tr> <td> @ref SO_TTL </td> <td> uint8_t </td><td> 0 ~ 255 </td> </tr>
N *                  <tr> <td> @ref SO_TOS </td> <td> uint8_t </td><td> 0 ~ 255 </td> </tr>
N *                  <tr> <td> @ref SO_MSS </td> <td> uint16_t </td><td> 0 ~ 65535 </td> </tr>
N *                  <tr> <td> @ref SO_DESTIP </td> <td> uint8_t[4] </td><td>  </td></tr> 
N *                  <tr> <td> @ref SO_DESTPORT </td> <td> uint16_t </td><td> 0 ~ 65535 </td></tr> 
N *                  <tr> <td> @ref SO_KEEPALIVESEND </td> <td> null </td><td> null </td></tr> 
N *                  <tr> <td> @ref SO_KEEPALIVEAUTO </td> <td> uint8_t </td><td> 0 ~ 255 </td></tr> 
N *             </table>
N * @return 
N * - @b Success : @ref SOCK_OK \n
N * - @b Fail 
N *  - @ref SOCKERR_SOCKNUM     - Invalid Socket number \n
N *  - @ref SOCKERR_SOCKMODE    - Invalid socket mode \n
N *  - @ref SOCKERR_SOCKOPT     - Invalid socket option or its value \n
N *  - @ref SOCKERR_TIMEOUT     - Timeout occurred when sending keep-alive packet \n
N */
Nint8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg);
N
N/** 
N * @ingroup WIZnet_socket_APIs
N *  @brief get socket options
N *  @details Get socket option like as FLAG, TTL, MSS, and so on. Refer to @ref sockopt_type
N *  @param sn socket number
N *  @param sotype socket option type. refer to @ref sockopt_type
N *  @param arg Data type and value is determined according to <I>sotype</I>. \n
N *             <table>
N *                  <tr> <td> @b sotype </td> <td>@b data type</td><td>@b value</td></tr>
N *                  <tr> <td> @ref SO_FLAG </td> <td> uint8_t </td><td> @ref SF_ETHER_OWN, etc... </td> </tr>
N *                  <tr> <td> @ref SO_TOS </td> <td> uint8_t </td><td> 0 ~ 255 </td> </tr>
N *                  <tr> <td> @ref SO_MSS </td> <td> uint16_t </td><td> 0 ~ 65535 </td> </tr>
N *                  <tr> <td> @ref SO_DESTIP </td> <td> uint8_t[4] </td><td>  </td></tr> 
N *                  <tr> <td> @ref SO_DESTPORT </td> <td> uint16_t </td><td>  </td></tr> 
N *                  <tr> <td> @ref SO_KEEPALIVEAUTO </td> <td> uint8_t </td><td> 0 ~ 255 </td></tr> 
N *                  <tr> <td> @ref SO_SENDBUF </td> <td> uint16_t </td><td> 0 ~ 65535 </td></tr>  
N *                  <tr> <td> @ref SO_RECVBUF </td> <td> uint16_t </td><td> 0 ~ 65535 </td></tr>  
N *                  <tr> <td> @ref SO_STATUS </td> <td> uint8_t </td><td> @ref SOCK_ESTABLISHED, etc.. </td></tr>  
N *                  <tr> <td> @ref SO_REMAINSIZE </td> <td> uint16_t </td><td> 0~ 65535 </td></tr>
N *                  <tr> <td> @ref SO_PACKINFO </td> <td> uint8_t </td><td> @ref PACK_FIRST, etc... </td></tr>
N *             </table>
N * @return 
N * - @b Success : @ref SOCK_OK \n
N * - @b Fail 
N *  - @ref SOCKERR_SOCKNUM     - Invalid Socket number \n
N *  - @ref SOCKERR_SOCKOPT     - Invalid socket option or its value \n
N *  - @ref SOCKERR_SOCKMODE    - Invalid socket mode \n
N * @note
N *   The option as PACK_REMAINED and SO_PACKINFO is valid only in NON-TCP mode and after call @ref recvfrom(). \n
N *   When SO_PACKINFO value is PACK_FIRST and the return value of recvfrom() is zero, 
N *   This means the zero byte UDP data(UDP Header only) received.
N  */
Nint8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg);
N
N#endif   // _SOCKET_H_
L 56 "..\..\Internet\DNS\dns.c" 2
N#include "dns.h"
L 1 "..\..\Internet\DNS\dns.h" 1
N//*****************************************************************************
N//
N//! \file dns.h
N//! \brief DNS APIs Header file.
N//! \details Send DNS query & Receive DNS reponse. 
N//! \version 1.1.0
N//! \date 2013/11/18
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//!       <2013/12/20> V1.1.0
N//!         1. Remove secondary DNS server in DNS_run
N//!            If 1st DNS_run failed, call DNS_run with 2nd DNS again
N//!         2. DNS_timerHandler -> DNS_time_handler
N//!         3. Move the no reference define to dns.c
N//!         4. Integrated dns.h dns.c & dns_parse.h dns_parse.c into dns.h & dns.c
N//!       <2013/12/20> V1.1.0
N//!
N//! \author Eric Jung & MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#ifndef	_DNS_H_
N#define	_DNS_H_
N
N#include <stdint.h>
N/*
N * @brief Define it for Debug & Monitor DNS processing.
N * @note If defined, it dependens on <stdio.h>
N */
N#define _DNS_DEBUG_
N
N#define	MAX_DNS_BUF_SIZE	256		///< maximum size of DNS buffer. */
N/*
N * @brief Maxium length of your queried Domain name 
N * @todo SHOULD BE defined it equal as or greater than your Domain name lenght + null character(1)
N * @note SHOULD BE careful to stack overflow because it is allocated 1.5 times as MAX_DOMAIN_NAME in stack.
N */
N#define  MAX_DOMAIN_NAME   32       // for example "www.google.com"
N
N#define	MAX_DNS_RETRY     2        ///< Requery Count
N#define	DNS_WAIT_TIME     3        ///< Wait response time. unit 1s.
N
N#define	IPPORT_DOMAIN     53       ///< DNS server port number
N
N#define DNS_MSG_ID         0x1122   ///< ID for DNS message. You can be modifyed it any number
N/*
N * @brief DNS process initialize
N * @param s   : Socket number for DNS
N * @param buf : Buffer for DNS message
N */
Nvoid DNS_init(uint8_t s, uint8_t * buf);
N
N/*
N * @brief DNS process
N * @details Send DNS query and receive DNS response
N * @param dns_ip        : DNS server ip
N * @param name          : Domain name to be queryed
N * @param ip_from_dns   : IP address from DNS server
N * @return  -1 : failed. @ref MAX_DOMIN_NAME is too small \n
N *           0 : failed  (Timeout or Parse error)\n
N *           1 : success
N * @note This funtion blocks until success or fail. max time = @ref MAX_DNS_RETRY * @ref DNS_WAIT_TIME
N */
Nint8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns);
N
N/*
N * @brief DNS 1s Tick Timer handler
N * @note SHOULD BE register to your system 1s Tick timer handler 
N */
Nvoid DNS_time_handler(void);
N
N#endif	/* _DNS_H_ */
L 57 "..\..\Internet\DNS\dns.c" 2
N
N#ifdef _DNS_DEBUG_
N   #include <stdio.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 60 "..\..\Internet\DNS\dns.c" 2
N#endif
N
N#define	INITRTT		2000L	/* Initial smoothed response time */
N#define	MAXCNAME	   (MAX_DOMAIN_NAME + (MAX_DOMAIN_NAME>>1))	   /* Maximum amount of cname recursion */
N
N#define	TYPE_A		1	   /* Host address */
N#define	TYPE_NS		2	   /* Name server */
N#define	TYPE_MD		3	   /* Mail destination (obsolete) */
N#define	TYPE_MF		4	   /* Mail forwarder (obsolete) */
N#define	TYPE_CNAME	5	   /* Canonical name */
N#define	TYPE_SOA	   6	   /* Start of Authority */
N#define	TYPE_MB		7	   /* Mailbox name (experimental) */
N#define	TYPE_MG		8	   /* Mail group member (experimental) */
N#define	TYPE_MR		9	   /* Mail rename name (experimental) */
N#define	TYPE_NULL	10	   /* Null (experimental) */
N#define	TYPE_WKS	   11	   /* Well-known sockets */
N#define	TYPE_PTR	   12	   /* Pointer record */
N#define	TYPE_HINFO	13	   /* Host information */
N#define	TYPE_MINFO	14	   /* Mailbox information (experimental)*/
N#define	TYPE_MX		15	   /* Mail exchanger */
N#define	TYPE_TXT	   16	   /* Text strings */
N#define	TYPE_ANY	   255	/* Matches any type */
N
N#define	CLASS_IN	   1	   /* The ARPA Internet */
N
N/* Round trip timing parameters */
N#define	AGAIN	      8     /* Average RTT gain = 1/8 */
N#define	LAGAIN      3     /* Log2(AGAIN) */
N#define	DGAIN       4     /* Mean deviation gain = 1/4 */
N#define	LDGAIN      2     /* log2(DGAIN) */
N
N/* Header for all domain messages */
Nstruct dhdr
N{
N	uint16_t id;   /* Identification */
N	uint8_t	qr;      /* Query/Response */
N#define	QUERY    0
N#define	RESPONSE 1
N	uint8_t	opcode;
N#define	IQUERY   1
N	uint8_t	aa;      /* Authoratative answer */
N	uint8_t	tc;      /* Truncation */
N	uint8_t	rd;      /* Recursion desired */
N	uint8_t	ra;      /* Recursion available */
N	uint8_t	rcode;   /* Response code */
N#define	NO_ERROR       0
N#define	FORMAT_ERROR   1
N#define	SERVER_FAIL    2
N#define	NAME_ERROR     3
N#define	NOT_IMPL       4
N#define	REFUSED        5
N	uint16_t qdcount;	/* Question count */
N	uint16_t ancount;	/* Answer count */
N	uint16_t nscount;	/* Authority (name server) count */
N	uint16_t arcount;	/* Additional record count */
N};
N
N
Nuint8_t* pDNSMSG;       // DNS message buffer
Nuint8_t  DNS_SOCKET;    // SOCKET number for DNS
Nuint16_t DNS_MSGID;     // DNS message ID
N
Nuint32_t dns_1s_tick;   // for timout of DNS processing
N
N/* converts uint16_t from network buffer to a host byte order integer. */
Nuint16_t get16(uint8_t * s)
N{
N	uint16_t i;
N	i = *s++ << 8;
N	i = i + *s;
N	return i;
N}
N
N/* copies uint16_t to the network buffer with network byte order. */
Nuint8_t * put16(uint8_t * s, uint16_t i)
N{
N	*s++ = i >> 8;
N	*s++ = i;
N	return s;
N}
N
N
N/*
N *              CONVERT A DOMAIN NAME TO THE HUMAN-READABLE FORM
N *
N * Description : This function converts a compressed domain name to the human-readable form
N * Arguments   : msg        - is a pointer to the reply message
N *               compressed - is a pointer to the domain name in reply message.
N *               buf        - is a pointer to the buffer for the human-readable form name.
N *               len        - is the MAX. size of buffer.
N * Returns     : the length of compressed message
N */
Nint parse_name(uint8_t * msg, uint8_t * compressed, char * buf, int16_t len)
N{
N	uint16_t slen;		/* Length of current segment */
N	uint8_t * cp;
N	int clen = 0;		/* Total length of compressed name */
N	int indirect = 0;	/* Set if indirection encountered */
N	int nseg = 0;		/* Total number of segments in name */
N
N	cp = compressed;
N
N	for (;;)
N	{
N		slen = *cp++;	/* Length of this segment */
N
N		if (!indirect) clen++;
N
N		if ((slen & 0xc0) == 0xc0)
N		{
N			if (!indirect)
N				clen++;
N			indirect = 1;
N			/* Follow indirection */
N			cp = &msg[((slen & 0x3f)<<8) + *cp];
N			slen = *cp++;
N		}
N
N		if (slen == 0)	/* zero length == all done */
N			break;
N
N		len -= slen + 1;
N
N		if (len < 0) return -1;
N
N		if (!indirect) clen += slen;
N
N		while (slen-- != 0) *buf++ = (char)*cp++;
N		*buf++ = '.';
N		nseg++;
N	}
N
N	if (nseg == 0)
N	{
N		/* Root name; represent as single dot */
N		*buf++ = '.';
N		len--;
N	}
N
N	*buf++ = '\0';
N	len--;
N
N	return clen;	/* Length of compressed message */
N}
N
N/*
N *              PARSE QUESTION SECTION
N *
N * Description : This function parses the qeustion record of the reply message.
N * Arguments   : msg - is a pointer to the reply message
N *               cp  - is a pointer to the qeustion record.
N * Returns     : a pointer the to next record.
N */
Nuint8_t * dns_question(uint8_t * msg, uint8_t * cp)
N{
N	int len;
N	char name[MAXCNAME];
X	char name[(32 + (32>>1))];
N
N	len = parse_name(msg, cp, name, MAXCNAME);
X	len = parse_name(msg, cp, name, (32 + (32>>1)));
N
N
N	if (len == -1) return 0;
N
N	cp += len;
N	cp += 2;		/* type */
N	cp += 2;		/* class */
N
N	return cp;
N}
N
N
N/*
N *              PARSE ANSER SECTION
N *
N * Description : This function parses the answer record of the reply message.
N * Arguments   : msg - is a pointer to the reply message
N *               cp  - is a pointer to the answer record.
N * Returns     : a pointer the to next record.
N */
Nuint8_t * dns_answer(uint8_t * msg, uint8_t * cp, uint8_t * ip_from_dns)
N{
N	int len, type;
N	char name[MAXCNAME];
X	char name[(32 + (32>>1))];
N
N	len = parse_name(msg, cp, name, MAXCNAME);
X	len = parse_name(msg, cp, name, (32 + (32>>1)));
N
N	if (len == -1) return 0;
N
N	cp += len;
N	type = get16(cp);
N	cp += 2;		/* type */
N	cp += 2;		/* class */
N	cp += 4;		/* ttl */
N	cp += 2;		/* len */
N
N
N	switch (type)
N	{
N	case TYPE_A:
X	case 1:
N		/* Just read the address directly into the structure */
N		ip_from_dns[0] = *cp++;
N		ip_from_dns[1] = *cp++;
N		ip_from_dns[2] = *cp++;
N		ip_from_dns[3] = *cp++;
N		break;
N	case TYPE_CNAME:
X	case 5:
N	case TYPE_MB:
X	case 7:
N	case TYPE_MG:
X	case 8:
N	case TYPE_MR:
X	case 9:
N	case TYPE_NS:
X	case 2:
N	case TYPE_PTR:
X	case 12:
N		/* These types all consist of a single domain name */
N		/* convert it to ascii format */
N		len = parse_name(msg, cp, name, MAXCNAME);
X		len = parse_name(msg, cp, name, (32 + (32>>1)));
N		if (len == -1) return 0;
N
N		cp += len;
N		break;
N	case TYPE_HINFO:
X	case 13:
N		len = *cp++;
N		cp += len;
N
N		len = *cp++;
N		cp += len;
N		break;
N	case TYPE_MX:
X	case 15:
N		cp += 2;
N		/* Get domain name of exchanger */
N		len = parse_name(msg, cp, name, MAXCNAME);
X		len = parse_name(msg, cp, name, (32 + (32>>1)));
N		if (len == -1) return 0;
N
N		cp += len;
N		break;
N	case TYPE_SOA:
X	case 6:
N		/* Get domain name of name server */
N		len = parse_name(msg, cp, name, MAXCNAME);
X		len = parse_name(msg, cp, name, (32 + (32>>1)));
N		if (len == -1) return 0;
N
N		cp += len;
N
N		/* Get domain name of responsible person */
N		len = parse_name(msg, cp, name, MAXCNAME);
X		len = parse_name(msg, cp, name, (32 + (32>>1)));
N		if (len == -1) return 0;
N
N		cp += len;
N
N		cp += 4;
N		cp += 4;
N		cp += 4;
N		cp += 4;
N		cp += 4;
N		break;
N	case TYPE_TXT:
X	case 16:
N		/* Just stash */
N		break;
N	default:
N		/* Ignore */
N		break;
N	}
N
N	return cp;
N}
N
N/*
N *              PARSE THE DNS REPLY
N *
N * Description : This function parses the reply message from DNS server.
N * Arguments   : dhdr - is a pointer to the header for DNS message
N *               buf  - is a pointer to the reply message.
N *               len  - is the size of reply message.
N * Returns     : -1 - Domain name lenght is too big 
N *                0 - Fail (Timout or parse error)
N *                1 - Success, 
N */
Nint8_t parseDNSMSG(struct dhdr * pdhdr, uint8_t * pbuf, uint8_t * ip_from_dns)
N{
N	uint16_t tmp;
N	uint16_t i;
N	uint8_t * msg;
N	uint8_t * cp;
N
N	msg = pbuf;
N	memset(pdhdr, 0, sizeof(pdhdr));
N
N	pdhdr->id = get16(&msg[0]);
N	tmp = get16(&msg[2]);
N	if (tmp & 0x8000) pdhdr->qr = 1;
N
N	pdhdr->opcode = (tmp >> 11) & 0xf;
N
N	if (tmp & 0x0400) pdhdr->aa = 1;
N	if (tmp & 0x0200) pdhdr->tc = 1;
N	if (tmp & 0x0100) pdhdr->rd = 1;
N	if (tmp & 0x0080) pdhdr->ra = 1;
N
N	pdhdr->rcode = tmp & 0xf;
N	pdhdr->qdcount = get16(&msg[4]);
N	pdhdr->ancount = get16(&msg[6]);
N	pdhdr->nscount = get16(&msg[8]);
N	pdhdr->arcount = get16(&msg[10]);
N
N
N	/* Now parse the variable length sections */
N	cp = &msg[12];
N
N	/* Question section */
N	for (i = 0; i < pdhdr->qdcount; i++)
N	{
N		cp = dns_question(msg, cp);
N   #ifdef _DNS_DEUBG_
S      printf("MAX_DOMAIN_NAME is too small, it should be redfine in dns.h"
N   #endif
N		if(!cp) return -1;
N	}
N
N	/* Answer section */
N	for (i = 0; i < pdhdr->ancount; i++)
N	{
N		cp = dns_answer(msg, cp, ip_from_dns);
N   #ifdef _DNS_DEUBG_
S      printf("MAX_DOMAIN_NAME is too small, it should be redfine in dns.h"
N   #endif
N		if(!cp) return -1;
N	}
N
N	/* Name server (authority) section */
N	for (i = 0; i < pdhdr->nscount; i++)
N	{
N		;
N	}
N
N	/* Additional section */
N	for (i = 0; i < pdhdr->arcount; i++)
N	{
N		;
N	}
N
N	if(pdhdr->rcode == 0) return 1;		// No error
N	else return 0;
N}
N
N
N/*
N *              MAKE DNS QUERY MESSAGE
N *
N * Description : This function makes DNS query message.
N * Arguments   : op   - Recursion desired
N *               name - is a pointer to the domain name.
N *               buf  - is a pointer to the buffer for DNS message.
N *               len  - is the MAX. size of buffer.
N * Returns     : the pointer to the DNS message.
N */
Nint16_t dns_makequery(uint16_t op, char * name, uint8_t * buf, uint16_t len)
N{
N	uint8_t *cp;
N	char *cp1;
N	char sname[MAXCNAME];
X	char sname[(32 + (32>>1))];
N	char *dname;
N	uint16_t p;
N	uint16_t dlen;
N
N	cp = buf;
N
N	DNS_MSGID++;
N	cp = put16(cp, DNS_MSGID);
N	p = (op << 11) | 0x0100;			/* Recursion desired */
N	cp = put16(cp, p);
N	cp = put16(cp, 1);
N	cp = put16(cp, 0);
N	cp = put16(cp, 0);
N	cp = put16(cp, 0);
N
N	strcpy(sname, name);
N	dname = sname;
N	dlen = strlen(dname);
N	for (;;)
N	{
N		/* Look for next dot */
N		cp1 = strchr(dname, '.');
N
N		if (cp1 != NULL) len = cp1 - dname;	/* More to come */
X		if (cp1 != 0) len = cp1 - dname;	 
N		else len = dlen;			/* Last component */
N
N		*cp++ = len;				/* Write length of component */
N		if (len == 0) break;
N
N		/* Copy component up to (but not including) dot */
N		strncpy((char *)cp, dname, len);
N		cp += len;
N		if (cp1 == NULL)
X		if (cp1 == 0)
N		{
N			*cp++ = 0;			/* Last one; write null and finish */
N			break;
N		}
N		dname += len+1;
N		dlen -= len+1;
N	}
N
N	cp = put16(cp, 0x0001);				/* type */
N	cp = put16(cp, 0x0001);				/* class */
N
N	return ((int16_t)((uint32_t)(cp) - (uint32_t)(buf)));
N}
N
N/*
N *              CHECK DNS TIMEOUT
N *
N * Description : This function check the DNS timeout
N * Arguments   : None.
N * Returns     : -1 - timeout occurred, 0 - timer over, but no timeout, 1 - no timer over, no timeout occur
N * Note        : timeout : retry count and timer both over.
N */
N
Nint8_t check_DNS_timeout(void)
N{
N	static uint8_t retry_count;
N
N	if(dns_1s_tick >= DNS_WAIT_TIME)
X	if(dns_1s_tick >= 3)
N	{
N		dns_1s_tick = 0;
N		if(retry_count >= MAX_DNS_RETRY) {
X		if(retry_count >= 2) {
N			retry_count = 0;
N			return -1; // timeout occurred
N		}
N		retry_count++;
N		return 0; // timer over, but no timeout
N	}
N
N	return 1; // no timer over, no timeout occur
N}
N
N
N
N/* DNS CLIENT INIT */
Nvoid DNS_init(uint8_t s, uint8_t * buf)
N{
N	DNS_SOCKET = s; // SOCK_DNS
N	pDNSMSG = buf; // User's shared buffer
N	DNS_MSGID = DNS_MSG_ID;
X	DNS_MSGID = 0x1122;
N}
N
N/* DNS CLIENT RUN */
Nint8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns)
N{
N	int8_t ret;
N	struct dhdr dhp;
N	uint8_t ip[4];
N	uint16_t len, port;
N	int8_t ret_check_timeout;
N   
N   // Socket open
N   socket(DNS_SOCKET, Sn_MR_UDP, 0, 0);
X   socket(DNS_SOCKET, 0x02, 0, 0);
N
N#ifdef _DNS_DEBUG_
N	printf("> DNS Query to DNS Server : %d.%d.%d.%d\r\n", dns_ip[0], dns_ip[1], dns_ip[2], dns_ip[3]);
N#endif
N   
N	len = dns_makequery(0, (char *)name, pDNSMSG, MAX_DNS_BUF_SIZE);
X	len = dns_makequery(0, (char *)name, pDNSMSG, 256);
N	sendto(DNS_SOCKET, pDNSMSG, len, dns_ip, IPPORT_DOMAIN);
X	sendto(DNS_SOCKET, pDNSMSG, len, dns_ip, 53);
N
N	while (1)
N	{
N		if ((len = getSn_RX_RSR(DNS_SOCKET)) > 0)
N		{
N			if (len > MAX_DNS_BUF_SIZE) len = MAX_DNS_BUF_SIZE;
X			if (len > 256) len = 256;
N			len = recvfrom(DNS_SOCKET, pDNSMSG, len, ip, &port);
N      #ifdef _DNS_DEBUG_
N	      printf("> Receive DNS message from %d.%d.%d.%d(%d). len = %d\r\n", ip[0], ip[1], ip[2], ip[3],port,len);
N      #endif
N         ret = parseDNSMSG(&dhp, pDNSMSG, ip_from_dns);
N			break;
N		}
N		// Check Timeout
N		ret_check_timeout = check_DNS_timeout();
N		if (ret_check_timeout < 0) {
N
N#ifdef _DNS_DEBUG_
N			printf("> DNS Server is not responding : %d.%d.%d.%d\r\n", dns_ip[0], dns_ip[1], dns_ip[2], dns_ip[3]);
N#endif
N			return 0; // timeout occurred
N		}
N		else if (ret_check_timeout == 0) {
N
N#ifdef _DNS_DEBUG_
N			printf("> DNS Timeout\r\n");
N#endif
N			sendto(DNS_SOCKET, pDNSMSG, len, dns_ip, IPPORT_DOMAIN);
X			sendto(DNS_SOCKET, pDNSMSG, len, dns_ip, 53);
N		}
N	}
N	close(DNS_SOCKET);
N	// Return value
N	// 0 > :  failed / 1 - success
N	return ret;
N}
N
N
N/* DNS TIMER HANDLER */
Nvoid DNS_time_handler(void)
N{
N	dns_1s_tick++;
N}
N
N
N
