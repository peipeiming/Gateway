; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_sht3x.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_sht3x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\MQTT -I..\..\Ethernet -I..\..\Ethernet\W5500 -I..\..\Internet\DHCP -I..\..\Internet\DNS -I..\..\User\app\src -I..\..\User\app\inc -I..\..\Internet\NTP -I..\..\Internet\HTTP -I.\RTE\_Flash -ID:\MDK5\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\MDK5\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_sht3x.crf ..\..\User\bsp\bsp_sht3x.c]
                          THUMB

                          AREA ||i.SHT3X_CalcCrc||, CODE, READONLY, ALIGN=1

                  SHT3X_CalcCrc PROC
;;;82     //校验
;;;83     unsigned char SHT3X_CalcCrc(unsigned char *data, unsigned char nbrOfBytes)
000000  b530              PUSH     {r4,r5,lr}
;;;84     {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;85     	unsigned char bit;        // bit mask
;;;86         unsigned char crc = 0xFF; // calculated checksum
000006  20ff              MOVS     r0,#0xff
;;;87         unsigned char byteCtr;    // byte counter
;;;88     
;;;89         // calculates 8-Bit checksum with given polynomial
;;;90         for(byteCtr = 0; byteCtr < nbrOfBytes; byteCtr++) 
000008  2100              MOVS     r1,#0
00000a  e013              B        |L1.52|
                  |L1.12|
;;;91     	{
;;;92             crc ^= (data[byteCtr]);
00000c  5c55              LDRB     r5,[r2,r1]
00000e  4068              EORS     r0,r0,r5
;;;93             for(bit = 8; bit > 0; --bit) 
000010  2408              MOVS     r4,#8
000012  e00b              B        |L1.44|
                  |L1.20|
;;;94     		{
;;;95                 if(crc & 0x80) 
000014  f0000580          AND      r5,r0,#0x80
000018  b125              CBZ      r5,|L1.36|
;;;96     				crc = (crc << 1) ^ POLYNOMIAL;
00001a  2531              MOVS     r5,#0x31
00001c  ea850540          EOR      r5,r5,r0,LSL #1
000020  b2e8              UXTB     r0,r5
000022  e001              B        |L1.40|
                  |L1.36|
;;;97     			else 
;;;98                     crc = (crc << 1);
000024  0645              LSLS     r5,r0,#25
000026  0e28              LSRS     r0,r5,#24
                  |L1.40|
000028  1e65              SUBS     r5,r4,#1              ;93
00002a  b2ec              UXTB     r4,r5                 ;93
                  |L1.44|
00002c  2c00              CMP      r4,#0                 ;93
00002e  dcf1              BGT      |L1.20|
000030  1c4d              ADDS     r5,r1,#1              ;90
000032  b2e9              UXTB     r1,r5                 ;90
                  |L1.52|
000034  4299              CMP      r1,r3                 ;90
000036  dbe9              BLT      |L1.12|
;;;99             }
;;;100        }
;;;101    	return crc;
;;;102    }
000038  bd30              POP      {r4,r5,pc}
;;;103    
                          ENDP


                          AREA ||i.SHT3X_CalcRH||, CODE, READONLY, ALIGN=2

                  SHT3X_CalcRH PROC
;;;123    //计算湿度
;;;124    unsigned char SHT3X_CalcRH(unsigned int rawValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;125    {
000004  4604              MOV      r4,r0
;;;126        // calculate relative humidity [%RH]
;;;127        unsigned char temp1 = (100 * (float)rawValue / 65535) ;  // RH = rawValue / (2^16-1) * 10
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       __aeabi_ui2f
00000c  4680              MOV      r8,r0
00000e  4907              LDR      r1,|L2.44|
000010  f7fffffe          BL       __aeabi_fmul
000014  4607              MOV      r7,r0
000016  4906              LDR      r1,|L2.48|
000018  f7fffffe          BL       __aeabi_fdiv
00001c  4606              MOV      r6,r0
00001e  f7fffffe          BL       __aeabi_f2uiz
000022  b2c5              UXTB     r5,r0
;;;128        return temp1;
000024  4628              MOV      r0,r5
;;;129    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;130    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x42c80000
                  |L2.48|
                          DCD      0x477fff00

                          AREA ||i.SHT3X_CalcTemperature||, CODE, READONLY, ALIGN=2

                  SHT3X_CalcTemperature PROC
;;;114    //计算温度
;;;115    unsigned int SHT3X_CalcTemperature(unsigned int rawValue)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;116    {
000004  4604              MOV      r4,r0
;;;117        // calculate temperature 
;;;118        unsigned int temp;
;;;119        temp = (175 * (float)rawValue / 65535 - 45) ; // T = -45 + 175 * rawValue / (2^16-1)
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       __aeabi_ui2f
00000c  4681              MOV      r9,r0
00000e  4909              LDR      r1,|L3.52|
000010  f7fffffe          BL       __aeabi_fmul
000014  4680              MOV      r8,r0
000016  4908              LDR      r1,|L3.56|
000018  f7fffffe          BL       __aeabi_fdiv
00001c  4607              MOV      r7,r0
00001e  4907              LDR      r1,|L3.60|
000020  f7fffffe          BL       __aeabi_fsub
000024  4606              MOV      r6,r0
000026  f7fffffe          BL       __aeabi_f2uiz
00002a  4605              MOV      r5,r0
;;;120        return temp;
00002c  4628              MOV      r0,r5
;;;121    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;122    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x432f0000
                  |L3.56|
                          DCD      0x477fff00
                  |L3.60|
                          DCD      0x42340000

                          AREA ||i.SHT3X_CheckCrc||, CODE, READONLY, ALIGN=1

                  SHT3X_CheckCrc PROC
;;;104    //校验检测
;;;105    unsigned char SHT3X_CheckCrc(unsigned char *pdata, unsigned char nbrOfBytes, unsigned char checksum)
000000  b5f0              PUSH     {r4-r7,lr}
;;;106    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;107        unsigned char crc;
;;;108    	crc = SHT3X_CalcCrc(pdata, nbrOfBytes);// calculates 8-Bit checksum
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       SHT3X_CalcCrc
000010  4607              MOV      r7,r0
;;;109        if(crc != checksum) 
000012  42a7              CMP      r7,r4
000014  d001              BEQ      |L4.26|
;;;110            return 1;           
000016  2001              MOVS     r0,#1
                  |L4.24|
;;;111        return 0;              
;;;112    }
000018  bdf0              POP      {r4-r7,pc}
                  |L4.26|
00001a  2000              MOVS     r0,#0                 ;111
00001c  e7fc              B        |L4.24|
;;;113    
                          ENDP


                          AREA ||i.SHT3X_Init||, CODE, READONLY, ALIGN=1

                  SHT3X_Init PROC
;;;49     
;;;50     void SHT3X_Init(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52       delay_us(250);
000002  20fa              MOVS     r0,#0xfa
000004  f7fffffe          BL       delay_us
;;;53       SHT3X_WriteCMD(CMD_MEAS_PERI_2_H);//设置测量周期和模式
000008  f2422036          MOV      r0,#0x2236
00000c  f7fffffe          BL       SHT3X_WriteCMD
;;;54     }
000010  bd10              POP      {r4,pc}
;;;55     
                          ENDP


                          AREA ||i.SHT3X_ReadState||, CODE, READONLY, ALIGN=1

                  SHT3X_ReadState PROC
;;;29     //读取SHT30寄存器状态
;;;30     void SHT3X_ReadState(unsigned char *temp)
000000  b510              PUSH     {r4,lr}
;;;31     {
000002  4604              MOV      r4,r0
;;;32         IIC_Start();
000004  f7fffffe          BL       IIC_Start
;;;33         IIC_Send_Byte(i2cAddWrite_8bit);
000008  2088              MOVS     r0,#0x88
00000a  f7fffffe          BL       IIC_Send_Byte
;;;34         IIC_Wait_Ack();
00000e  f7fffffe          BL       IIC_Wait_Ack
;;;35         IIC_Send_Byte(0xf3);
000012  20f3              MOVS     r0,#0xf3
000014  f7fffffe          BL       IIC_Send_Byte
;;;36         IIC_Wait_Ack();
000018  f7fffffe          BL       IIC_Wait_Ack
;;;37         IIC_Send_Byte(0X2d);
00001c  202d              MOVS     r0,#0x2d
00001e  f7fffffe          BL       IIC_Send_Byte
;;;38         IIC_Wait_Ack();
000022  f7fffffe          BL       IIC_Wait_Ack
;;;39       
;;;40         IIC_Start();
000026  f7fffffe          BL       IIC_Start
;;;41         IIC_Send_Byte(i2cAddRead_8bit);
00002a  2089              MOVS     r0,#0x89
00002c  f7fffffe          BL       IIC_Send_Byte
;;;42         IIC_Wait_Ack();
000030  f7fffffe          BL       IIC_Wait_Ack
;;;43     
;;;44         temp[0] = IIC_Read_Byte(1);//高
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       IIC_Read_Byte
00003a  7020              STRB     r0,[r4,#0]
;;;45         temp[1] = IIC_Read_Byte(1);//低
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       IIC_Read_Byte
000042  7060              STRB     r0,[r4,#1]
;;;46         temp[2] = IIC_Read_Byte(0);//校验
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       IIC_Read_Byte
00004a  70a0              STRB     r0,[r4,#2]
;;;47         IIC_Stop(); 
00004c  f7fffffe          BL       IIC_Stop
;;;48     }
000050  bd10              POP      {r4,pc}
;;;49     
                          ENDP


                          AREA ||i.SHT3X_WriteCMD||, CODE, READONLY, ALIGN=1

                  SHT3X_WriteCMD PROC
;;;16     
;;;17     void SHT3X_WriteCMD(unsigned int cmd)
000000  b510              PUSH     {r4,lr}
;;;18     {
000002  4604              MOV      r4,r0
;;;19       IIC_Start();
000004  f7fffffe          BL       IIC_Start
;;;20       IIC_Send_Byte(i2cAddWrite_8bit);
000008  2088              MOVS     r0,#0x88
00000a  f7fffffe          BL       IIC_Send_Byte
;;;21       IIC_Wait_Ack();
00000e  f7fffffe          BL       IIC_Wait_Ack
;;;22       IIC_Send_Byte(cmd>>8);
000012  f3c42007          UBFX     r0,r4,#8,#8
000016  f7fffffe          BL       IIC_Send_Byte
;;;23       IIC_Wait_Ack();
00001a  f7fffffe          BL       IIC_Wait_Ack
;;;24       IIC_Send_Byte(cmd);
00001e  b2e0              UXTB     r0,r4
000020  f7fffffe          BL       IIC_Send_Byte
;;;25       IIC_Wait_Ack();
000024  f7fffffe          BL       IIC_Wait_Ack
;;;26       IIC_Stop();
000028  f7fffffe          BL       IIC_Stop
;;;27     }
00002c  bd10              POP      {r4,pc}
;;;28     
                          ENDP


                          AREA ||i.SHT_GetValue||, CODE, READONLY, ALIGN=2

                  SHT_GetValue PROC
;;;131    //读取温度---20ms即可读取完成
;;;132    void SHT_GetValue(unsigned char *TemValue, unsigned char *RhValue)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;133    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;134        unsigned char temp = 0;
000008  2600              MOVS     r6,#0
;;;135        unsigned int dat;
;;;136        unsigned char p[3];
;;;137        unsigned char cnt;
;;;138        unsigned char tem_status,hum_status;
;;;139        cnt = 0;
00000a  46b2              MOV      r10,r6
;;;140        tem_status = 0;
00000c  2700              MOVS     r7,#0
;;;141        hum_status = 0;
00000e  46b0              MOV      r8,r6
;;;142        
;;;143        while(cnt++<2)
000010  e052              B        |L8.184|
                  |L8.18|
;;;144    	{
;;;145    		SHX3X_ReadResults(CMD_FETCH_DATA, buffer);//获取温度湿度
000012  4935              LDR      r1,|L8.232|
000014  f44f4060          MOV      r0,#0xe000
000018  f7fffffe          BL       SHX3X_ReadResults
;;;146    
;;;147    		p[0] = buffer[0];
00001c  4832              LDR      r0,|L8.232|
00001e  7800              LDRB     r0,[r0,#0]  ; buffer
000020  f88d0000          STRB     r0,[sp,#0]
;;;148    		p[1] = buffer[1];
000024  4830              LDR      r0,|L8.232|
000026  7840              LDRB     r0,[r0,#1]  ; buffer
000028  f88d0001          STRB     r0,[sp,#1]
;;;149    		p[2] = buffer[2];
00002c  482e              LDR      r0,|L8.232|
00002e  7880              LDRB     r0,[r0,#2]  ; buffer
000030  f88d0002          STRB     r0,[sp,#2]
;;;150    		temp = SHT3X_CheckCrc(p,2,p[2]);//校验
000034  f89d2002          LDRB     r2,[sp,#2]
000038  2102              MOVS     r1,#2
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       SHT3X_CheckCrc
000040  4606              MOV      r6,r0
;;;151    		if( !temp ) 
000042  b966              CBNZ     r6,|L8.94|
;;;152    		{
;;;153    			dat = ((unsigned int)buffer[0] << 8) | buffer[1];
000044  4828              LDR      r0,|L8.232|
000046  7840              LDRB     r0,[r0,#1]  ; buffer
000048  4927              LDR      r1,|L8.232|
00004a  7809              LDRB     r1,[r1,#0]  ; buffer
00004c  ea402901          ORR      r9,r0,r1,LSL #8
;;;154    			*TemValue = SHT3X_CalcTemperature( dat )-TEM_CHEAK_VALUE;    //计算温度加校正
000050  4648              MOV      r0,r9
000052  f7fffffe          BL       SHT3X_CalcTemperature
000056  1e80              SUBS     r0,r0,#2
000058  7020              STRB     r0,[r4,#0]
;;;155    			tem_status = 0;
00005a  2700              MOVS     r7,#0
00005c  e000              B        |L8.96|
                  |L8.94|
;;;156    		}
;;;157    		else
;;;158    			tem_status = 1;  
00005e  2701              MOVS     r7,#1
                  |L8.96|
;;;159    
;;;160    		p[0] = buffer[3];
000060  4821              LDR      r0,|L8.232|
000062  78c0              LDRB     r0,[r0,#3]  ; buffer
000064  f88d0000          STRB     r0,[sp,#0]
;;;161    		p[1] = buffer[4];
000068  481f              LDR      r0,|L8.232|
00006a  7900              LDRB     r0,[r0,#4]  ; buffer
00006c  f88d0001          STRB     r0,[sp,#1]
;;;162    		p[2] = buffer[5];
000070  481d              LDR      r0,|L8.232|
000072  7940              LDRB     r0,[r0,#5]  ; buffer
000074  f88d0002          STRB     r0,[sp,#2]
;;;163    		temp = SHT3X_CheckCrc(p,2,p[2]);//校验
000078  f89d2002          LDRB     r2,[sp,#2]
00007c  2102              MOVS     r1,#2
00007e  4668              MOV      r0,sp
000080  f7fffffe          BL       SHT3X_CheckCrc
000084  4606              MOV      r6,r0
;;;164    		if( !temp )
000086  b96e              CBNZ     r6,|L8.164|
;;;165    		{
;;;166    			dat = ((unsigned int)p[0] << 8) | p[1];
000088  f89d0001          LDRB     r0,[sp,#1]
00008c  f89d1000          LDRB     r1,[sp,#0]
000090  ea402901          ORR      r9,r0,r1,LSL #8
;;;167    			*RhValue = SHT3X_CalcRH( dat )+RH_CHEAK_VALUE; //计算湿度加校正
000094  4648              MOV      r0,r9
000096  f7fffffe          BL       SHT3X_CalcRH
00009a  300d              ADDS     r0,r0,#0xd
00009c  7028              STRB     r0,[r5,#0]
;;;168    			hum_status = 0;
00009e  f04f0800          MOV      r8,#0
0000a2  e001              B        |L8.168|
                  |L8.164|
;;;169    		}
;;;170    		else
;;;171    			hum_status = 1;  
0000a4  f04f0801          MOV      r8,#1
                  |L8.168|
;;;172    
;;;173    		if((tem_status==0) && (hum_status==0))  
0000a8  b91f              CBNZ     r7,|L8.178|
0000aa  f1b80f00          CMP      r8,#0
0000ae  d100              BNE      |L8.178|
;;;174    			break;
0000b0  e008              B        |L8.196|
                  |L8.178|
;;;175    		
;;;176    		delay_us(10); 
0000b2  200a              MOVS     r0,#0xa
0000b4  f7fffffe          BL       delay_us
                  |L8.184|
0000b8  4650              MOV      r0,r10                ;143
0000ba  1c41              ADDS     r1,r0,#1              ;143
0000bc  f0010aff          AND      r10,r1,#0xff          ;143
0000c0  2802              CMP      r0,#2                 ;143
0000c2  dba6              BLT      |L8.18|
                  |L8.196|
0000c4  bf00              NOP                            ;174
;;;177    	}
;;;178    	
;;;179    	if((tem_status!=0) || (hum_status!=0))
0000c6  b917              CBNZ     r7,|L8.206|
0000c8  f1b80f00          CMP      r8,#0
0000cc  d009              BEQ      |L8.226|
                  |L8.206|
;;;180    	{   
;;;181    		//      SCL_OUT();
;;;182    		delay_us(250);
0000ce  20fa              MOVS     r0,#0xfa
0000d0  f7fffffe          BL       delay_us
;;;183    		SHT3X_WriteCMD(CMD_MEAS_PERI_2_H);//设置测量周期和模式
0000d4  f2422036          MOV      r0,#0x2236
0000d8  f7fffffe          BL       SHT3X_WriteCMD
;;;184    		delay_us(150);
0000dc  2096              MOVS     r0,#0x96
0000de  f7fffffe          BL       delay_us
                  |L8.226|
;;;185    	}
;;;186    }
0000e2  e8bd8ff8          POP      {r3-r11,pc}
;;;187    /*
                          ENDP

0000e6  0000              DCW      0x0000
                  |L8.232|
                          DCD      buffer

                          AREA ||i.SHX3X_ReadResults||, CODE, READONLY, ALIGN=1

                  SHX3X_ReadResults PROC
;;;56     //读取SHT30结果
;;;57     void SHX3X_ReadResults(unsigned int cmd,  unsigned char *p)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;59     	IIC_Start();
000006  f7fffffe          BL       IIC_Start
;;;60     	IIC_Send_Byte(i2cAddWrite_8bit);
00000a  2088              MOVS     r0,#0x88
00000c  f7fffffe          BL       IIC_Send_Byte
;;;61     	IIC_Wait_Ack();
000010  f7fffffe          BL       IIC_Wait_Ack
;;;62     	IIC_Send_Byte(cmd>>8);
000014  f3c52007          UBFX     r0,r5,#8,#8
000018  f7fffffe          BL       IIC_Send_Byte
;;;63     	IIC_Wait_Ack();
00001c  f7fffffe          BL       IIC_Wait_Ack
;;;64     	IIC_Send_Byte(cmd);
000020  b2e8              UXTB     r0,r5
000022  f7fffffe          BL       IIC_Send_Byte
;;;65     	IIC_Wait_Ack();
000026  f7fffffe          BL       IIC_Wait_Ack
;;;66     
;;;67     	IIC_Start();
00002a  f7fffffe          BL       IIC_Start
;;;68     	IIC_Send_Byte(i2cAddRead_8bit);
00002e  2089              MOVS     r0,#0x89
000030  f7fffffe          BL       IIC_Send_Byte
;;;69     
;;;70     	if(IIC_Wait_Ack()==0)
000034  f7fffffe          BL       IIC_Wait_Ack
000038  b9c8              CBNZ     r0,|L9.110|
;;;71     	{     
;;;72     		p[0] = IIC_Read_Byte(1);//温度高
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       IIC_Read_Byte
000040  7020              STRB     r0,[r4,#0]
;;;73     		p[1] = IIC_Read_Byte(1);//温度低
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       IIC_Read_Byte
000048  7060              STRB     r0,[r4,#1]
;;;74     		p[2] = IIC_Read_Byte(1);//校验
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       IIC_Read_Byte
000050  70a0              STRB     r0,[r4,#2]
;;;75     		p[3] = IIC_Read_Byte(1);//湿度高
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       IIC_Read_Byte
000058  70e0              STRB     r0,[r4,#3]
;;;76     		p[4] = IIC_Read_Byte(1);//湿度低
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       IIC_Read_Byte
000060  7120              STRB     r0,[r4,#4]
;;;77     		p[5] = IIC_Read_Byte(0);//校验
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       IIC_Read_Byte
000068  7160              STRB     r0,[r4,#5]
;;;78     		IIC_Stop();
00006a  f7fffffe          BL       IIC_Stop
                  |L9.110|
;;;79     	}
;;;80     }
00006e  bd70              POP      {r4-r6,pc}
;;;81     
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=1

                  delay_us PROC
;;;3      unsigned char buffer[6];
;;;4      void delay_us(uint32_t time)
000000  2100              MOVS     r1,#0
;;;5      {
;;;6      	uint32_t i=0;
;;;7      	for(i=0;i<time;i++){
000002  bf00              NOP      
000004  e048              B        |L10.152|
                  |L10.6|
;;;8      		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
000014  bf00              NOP      
000016  bf00              NOP      
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  bf00              NOP      
000020  bf00              NOP      
000022  bf00              NOP      
;;;9      		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000024  bf00              NOP      
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  bf00              NOP      
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  bf00              NOP      
000040  bf00              NOP      
;;;10     		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000042  bf00              NOP      
000044  bf00              NOP      
000046  bf00              NOP      
000048  bf00              NOP      
00004a  bf00              NOP      
00004c  bf00              NOP      
00004e  bf00              NOP      
000050  bf00              NOP      
000052  bf00              NOP      
000054  bf00              NOP      
000056  bf00              NOP      
000058  bf00              NOP      
00005a  bf00              NOP      
00005c  bf00              NOP      
00005e  bf00              NOP      
;;;11     		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000060  bf00              NOP      
000062  bf00              NOP      
000064  bf00              NOP      
000066  bf00              NOP      
000068  bf00              NOP      
00006a  bf00              NOP      
00006c  bf00              NOP      
00006e  bf00              NOP      
000070  bf00              NOP      
000072  bf00              NOP      
000074  bf00              NOP      
000076  bf00              NOP      
000078  bf00              NOP      
00007a  bf00              NOP      
00007c  bf00              NOP      
;;;12     		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
00007e  bf00              NOP      
000080  bf00              NOP      
000082  bf00              NOP      
000084  bf00              NOP      
000086  bf00              NOP      
000088  bf00              NOP      
00008a  bf00              NOP      
00008c  bf00              NOP      
00008e  bf00              NOP      
000090  bf00              NOP      
000092  bf00              NOP      
000094  bf00              NOP      
000096  1c49              ADDS     r1,r1,#1              ;7
                  |L10.152|
000098  4281              CMP      r1,r0                 ;7
00009a  d3b4              BCC      |L10.6|
;;;13     	}
;;;14     
;;;15     }
00009c  4770              BX       lr
;;;16     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  buffer
                          DCDU     0x00000000
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\bsp_sht3x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_sht3x_c_delay_us____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_sht3x_c_delay_us____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_sht3x_c_delay_us____REVSH|
#line 128
|__asm___11_bsp_sht3x_c_delay_us____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
