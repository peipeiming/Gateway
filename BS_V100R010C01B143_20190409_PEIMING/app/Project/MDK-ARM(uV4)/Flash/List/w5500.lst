L 1 "..\..\Ethernet\W5500\w5500.c"
N//*****************************************************************************
N//
N//! \file w5500.c
N//! \brief W5500 HAL Interface.
N//! \version 1.0.2
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2014/05/01> V1.0.2
N//!         1. Implicit type casting -> Explicit type casting. Refer to M20140501
N//!            Fixed the problem on porting into under 32bit MCU
N//!            Issued by Mathias ClauBen, wizwiki forum ID Think01 and bobh
N//!            Thank for your interesting and serious advices.
N//!       <2013/12/20> V1.0.1
N//!         1. Remove warning
N//!         2. WIZCHIP_READ_BUF WIZCHIP_WRITE_BUF in case _WIZCHIP_IO_MODE_SPI_FDM_
N//!            for loop optimized(removed). refer to M20131220
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N//#include <stdio.h>
N#include "w5500.h"
L 1 "..\..\Ethernet\W5500\w5500.h" 1
N//*****************************************************************************
N//
N//! \file w5500.h
N//! \brief W5500 HAL Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#ifndef  _W5500_H_
N#define  _W5500_H_
N
N#include <stdint.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 46 "..\..\Ethernet\W5500\w5500.h" 2
N#include "wizchip_conf.h"
L 1 "..\..\Ethernet\wizchip_conf.h" 1
N//*****************************************************************************
N//
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. It could be replaced at WIZCHIP I/O function because they were made by WIZCHIP I/O functions.  
N * @details There are functions of configuring WIZCHIP, network, interrupt, phy, network information and timer. \n
N * 
N */
N
N#ifndef  _WIZCHIP_CONF_H_
N#define  _WIZCHIP_CONF_H_
N
N#include <stdint.h>
N/**
N * @brief Select WIZCHIP.
N * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
N *       ex> <code> #define \_WIZCHIP_      5500 </code>
N */
N#define _WIZCHIP_                      5500   // 5100, 5200, 5500
N
N#define _WIZCHIP_IO_MODE_NONE_         0x0000
N#define _WIZCHIP_IO_MODE_BUS_          0x0100 /**< Bus interface mode */
N#define _WIZCHIP_IO_MODE_SPI_          0x0200 /**< SPI interface mode */
N//#define _WIZCHIP_IO_MODE_IIC_          0x0400
N//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
N// Add to
N//
N
N#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) /**< BUS interface mode for direct  */
N#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) /**< BUS interface mode for indirect */
N
N#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
N#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
N
N
N#if   (_WIZCHIP_ == 5100)
X#if   (5500 == 5100)
S   #define _WIZCHIP_ID_                "W5100\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S
S#elif (_WIZCHIP_ == 5200)
X#elif (5500 == 5200)
S   #define _WIZCHIP_ID_                "W5200\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S   #include "W5200/w5200.h"
N#elif (_WIZCHIP_ == 5500)
X#elif (5500 == 5500)
N  #define _WIZCHIP_ID_                 "W5500\0"
N  
N/**
N * @brief Define interface mode. \n
N * @todo Should select interface mode as chip. 
N *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
N *        - Others will be defined in future. \n\n
N *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
N *       
N */
N   //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
N   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
N   #include "W5500/w5500.h"
L 1 "..\..\Ethernet\W5500/w5500.h" 1
N//*****************************************************************************
N//
N//! \file w5500.h
N//! \brief W5500 HAL Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#ifndef  _W5500_H_
S#define  _W5500_H_
S
S#include <stdint.h>
S#include "wizchip_conf.h"
S
S#define _W5500_IO_BASE_              0x00000000
S
S#define _W5500_SPI_READ_			   (0x00 << 2) //< SPI interface Read operation in Control Phase
S#define _W5500_SPI_WRITE_			   (0x01 << 2) //< SPI interface Write operation in Control Phase
S
S#define WIZCHIP_CREG_BLOCK          0x00 	//< Common register block
S#define WIZCHIP_SREG_BLOCK(N)       (1+4*N) //< Socket N register block
S#define WIZCHIP_TXBUF_BLOCK(N)      (2+4*N) //< Socket N Tx buffer address block
S#define WIZCHIP_RXBUF_BLOCK(N)      (3+4*N) //< Socket N Rx buffer address block
S
S#define WIZCHIP_OFFSET_INC(ADDR, N)    (ADDR + (N<<8)) //< Increase offset address
S
S
S///////////////////////////////////////
S// Definition For Legacy Chip Driver //
S///////////////////////////////////////
S#define IINCHIP_READ(ADDR)                WIZCHIP_READ(ADDR)               ///< The defined for legacy chip driver
S#define IINCHIP_WRITE(ADDR,VAL)           WIZCHIP_WRITE(ADDR,VAL)          ///< The defined for legacy chip driver
S#define IINCHIP_READ_BUF(ADDR,BUF,LEN)    WIZCHIP_READ_BUF(ADDR,BUF,LEN)   ///< The defined for legacy chip driver
S#define IINCHIP_WRITE_BUF(ADDR,BUF,LEN)   WIZCHIP_WRITE(ADDR,BUF,LEN)      ///< The defined for legacy chip driver
S
S//////////////////////////////
S//--------------------------  defgroup ---------------------------------
S/**
S * @defgroup W5500 W5500
S *
S * @brief WHIZCHIP register defines and I/O functions of @b W5500.
S *
S * - @ref WIZCHIP_register : @ref Common_register_group and @ref Socket_register_group
S * - @ref WIZCHIP_IO_Functions : @ref Basic_IO_function, @ref Common_register_access_function and @ref Socket_register_access_function
S */
S 
S 
S/**
S * @defgroup WIZCHIP_register WIZCHIP register
S * @ingroup W5500
S *
S * @brief WHIZCHIP register defines register group of @b W5500.
S *
S * - @ref Common_register_group : Common register group
S * - @ref Socket_register_group : \c SOCKET n register group
S */
S
S
S/**
S * @defgroup WIZCHIP_IO_Functions WIZCHIP I/O functions
S * @ingroup W5500
S *
S * @brief This supports the basic I/O functions for @ref WIZCHIP_register.
S *
S * - <b> Basic I/O function </b> \n
S *   WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF() \n\n
S *
S * - @ref Common_register_group <b>access functions</b> \n
S * 	-# @b Mode \n
S *    getMR(), setMR()
S * 	-# @b Interrupt \n
S *    getIR(), setIR(), getIMR(), setIMR(), getSIR(), setSIR(), getSIMR(), setSIMR(), getINTLEVEL(), setINTLEVEL()
S * 	-# <b> Network Information </b> \n
S *    getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR()
S * 	-# @b Retransmission \n
S *    getRCR(), setRCR(), getRTR(), setRTR()
S * 	-# @b PPPoE \n
S *    getPTIMER(), setPTIMER(), getPMAGIC(), getPMAGIC(), getPSID(), setPSID(), getPHAR(), setPHAR(), getPMRU(), setPMRU()
S * 	-# <b> ICMP packet </b>\n
S *    getUIPR(), getUPORTR()
S * 	-# @b etc. \n
S *    getPHYCFGR(), setPHYCFGR(), getVERSIONR() \n\n
S *
S * - \ref Socket_register_group <b>access functions</b> \n
S *   -# <b> SOCKET control</b> \n
S *      getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IR()
S *   -# <b> SOCKET information</b> \n
S *      getSn_SR(), getSn_DHAR(), setSn_DHAR(), getSn_PORT(), setSn_PORT(), getSn_DIPR(), setSn_DIPR(), getSn_DPORT(), setSn_DPORT()
S *      getSn_MSSR(), setSn_MSSR()
S *   -# <b> SOCKET communication </b> \n
S *      getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE() \n
S *      getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
S *      getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
S *      getSn_TX_FSR(), getSn_RX_RSR(), getSn_KPALVTR(), setSn_KPALVTR()
S *   -# <b> IP header field </b> \n
S *      getSn_FRAG(), setSn_FRAG(),  getSn_TOS(), setSn_TOS() \n
S *      getSn_TTL(), setSn_TTL()
S */
S
S
S
S/**
S * @defgroup Common_register_group Common register
S * @ingroup WIZCHIP_register
S *
S * @brief Common register group\n
S * It set the basic for the networking\n
S * It set the configuration such as interrupt, network information, ICMP, etc.
S * @details
S * @sa MR : Mode register.
S * @sa GAR, SUBR, SHAR, SIPR
S * @sa INTLEVEL, IR, IMR, SIR, SIMR : Interrupt.
S * @sa RTR, RCR : Data retransmission.
S * @sa PTIMER, PMAGIC, PHAR, PSID, PMRU : PPPoE.
S * @sa UIPR, UPORTR : ICMP message.
S * @sa PHYCFGR, VERSIONR : etc.
S */
S 
S  
S 
S/**
S * @defgroup Socket_register_group Socket register
S * @ingroup WIZCHIP_register
S *
S * @brief Socket register group.\n
S * Socket register configures and control SOCKETn which is necessary to data communication.
S * @details
S * @sa Sn_MR, Sn_CR, Sn_IR, Sn_IMR : SOCKETn Control
S * @sa Sn_SR, Sn_PORT, Sn_DHAR, Sn_DIPR, Sn_DPORT : SOCKETn Information
S * @sa Sn_MSSR, Sn_TOS, Sn_TTL, Sn_KPALVTR, Sn_FRAG : Internet protocol.
S * @sa Sn_RXBUF_SIZE, Sn_TXBUF_SIZE, Sn_TX_FSR, Sn_TX_RD, Sn_TX_WR, Sn_RX_RSR, Sn_RX_RD, Sn_RX_WR : Data communication
S */
S 
S 
S 
S /**
S * @defgroup Basic_IO_function Basic I/O function
S * @ingroup WIZCHIP_IO_Functions
S * @brief These are basic input/output functions to read values from register or write values to register.
S */
S
S/**
S * @defgroup Common_register_access_function Common register access functions
S * @ingroup WIZCHIP_IO_Functions
S * @brief These are functions to access <b>common registers</b>.
S */
S
S/**
S * @defgroup Socket_register_access_function Socket register access functions
S * @ingroup WIZCHIP_IO_Functions
S * @brief These are functions to access <b>socket registers</b>.
S */
S 
S//------------------------------- defgroup end --------------------------------------------
S//----------------------------- W5500 Common Registers IOMAP -----------------------------
S/**
S * @ingroup Common_register_group
S * @brief Mode Register address(R/W)\n
S * @ref MR is used for S/W reset, ping block mode, PPPoE mode and etc.
S * @details Each bit of @ref MR defined as follows.
S * <table>
S * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
S * 		<tr>  <td>RST</td> <td>Reserved</td> <td>WOL</td> <td>PB</td> <td>PPPoE</td> <td>Reserved</td> <td>FARP</td> <td>Reserved</td> </tr>
S * </table>
S * - \ref MR_RST		 	: Reset
S * - \ref MR_WOL       		: Wake on LAN
S * - \ref MR_PB         	: Ping block
S * - \ref MR_PPPOE      	: PPPoE mode
S * - \ref MR_FARP			: Force ARP mode
S */
S#define MR                 (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Gateway IP Register address(R/W)
S * @details @ref GAR configures the default gateway address.
S */
S#define GAR                (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Subnet mask Register address(R/W)
S * @details @ref SUBR configures the subnet mask address.
S */
S#define SUBR               (_W5500_IO_BASE_ + (0x0005 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Source MAC Register address(R/W)
S * @details @ref SHAR configures the source hardware address.
S */
S#define SHAR               (_W5500_IO_BASE_ + (0x0009 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Source IP Register address(R/W)
S * @details @ref SIPR configures the source IP address.
S */
S#define SIPR               (_W5500_IO_BASE_ + (0x000F << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Set Interrupt low level timer register address(R/W)
S * @details @ref INTLEVEL configures the Interrupt Assert Time.
S */
S#define INTLEVEL           (_W5500_IO_BASE_ + (0x0013 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Interrupt Register(R/W)
S * @details @ref IR indicates the interrupt status. Each bit of @ref IR will be still until the bit will be written to by the host.
S * If @ref IR is not equal to x00 INTn PIN is asserted to low until it is x00\n\n
S * Each bit of @ref IR defined as follows.
S * <table>
S * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
S * 		<tr>  <td>CONFLICT</td> <td>UNREACH</td> <td>PPPoE</td> <td>MP</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
S * </table>
S * - \ref IR_CONFLICT : IP conflict
S * - \ref IR_UNREACH  : Destination unreachable
S * - \ref IR_PPPoE	  : PPPoE connection close
S * - \ref IR_MP		  : Magic packet
S */
S#define IR                 (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Interrupt mask register(R/W)
S * @details @ref IMR is used to mask interrupts. Each bit of @ref IMR corresponds to each bit of @ref IR.
S * When a bit of @ref IMR is and the corresponding bit of @ref IR is  an interrupt will be issued. In other words,
S * if a bit of @ref IMR is  an interrupt will not be issued even if the corresponding bit of @ref IR is \n\n
S * Each bit of @ref IMR defined as the following.
S * <table>
S * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
S * 		<tr>  <td>IM_IR7</td> <td>IM_IR6</td> <td>IM_IR5</td> <td>IM_IR4</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
S * </table>
S * - \ref IM_IR7 : IP Conflict Interrupt Mask
S * - \ref IM_IR6 : Destination unreachable Interrupt Mask
S * - \ref IM_IR5 : PPPoE Close Interrupt Mask
S * - \ref IM_IR4 : Magic Packet Interrupt Mask
S */
S#define IMR                (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Socket Interrupt Register(R/W)
S * @details @ref SIR indicates the interrupt status of Socket.\n
S * Each bit of @ref SIR be still until @ref Sn_IR is cleared by the host.\n
S * If @ref Sn_IR is not equal to x00 the n-th bit of @ref SIR is and INTn PIN is asserted until @ref SIR is x00 */
S#define SIR                (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Socket Interrupt Mask Register(R/W)
S * @details Each bit of @ref SIMR corresponds to each bit of @ref SIR.
S * When a bit of @ref SIMR is and the corresponding bit of @ref SIR is  Interrupt will be issued.
S * In other words, if a bit of @ref SIMR is  an interrupt will be not issued even if the corresponding bit of @ref SIR is 
S */
S#define SIMR               (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Timeout register address( 1 is 100us )(R/W)
S * @details @ref RTR configures the retransmission timeout period. The unit of timeout period is 100us and the default of @ref RTR is x07D0or 000
S * And so the default timeout period is 200ms(100us X 2000). During the time configured by @ref RTR, W5500 waits for the peer response
S * to the packet that is transmitted by \ref Sn_CR (CONNECT, DISCON, CLOSE, SEND, SEND_MAC, SEND_KEEP command).
S * If the peer does not respond within the @ref RTR time, W5500 retransmits the packet or issues timeout.
S */
S#define RTR                (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Retry count register(R/W)
S * @details @ref RCR configures the number of time of retransmission.
S * When retransmission occurs as many as ref RCR+1 Timeout interrupt is issued (@ref Sn_IR[TIMEOUT] = .
S */
S#define RCR                (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief PPP LCP Request Timer register  in PPPoE mode(R/W)
S * @details @ref PTIMER configures the time for sending LCP echo request. The unit of time is 25ms.
S */
S#define PTIMER             (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief PPP LCP Magic number register  in PPPoE mode(R/W)
S * @details @ref PMAGIC configures the 4bytes magic number to be used in LCP negotiation.
S */
S#define PMAGIC             (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief PPP Destination MAC Register address(R/W)
S * @details @ref PHAR configures the PPPoE server hardware address that is acquired during PPPoE connection process.
S */
S#define PHAR                (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief PPP Session Identification Register(R/W)
S * @details @ref PSID configures the PPPoE sever session ID acquired during PPPoE connection process.
S */
S#define PSID               (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief PPP Maximum Segment Size(MSS) register(R/W)
S * @details @ref PMRU configures the maximum receive unit of PPPoE.
S */
S#define PMRU               (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Unreachable IP register address in UDP mode(R)
S * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
S * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR indicates
S * the destination IP address & port number respectively.
S */
S#define UIPR               (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief Unreachable Port register address in UDP mode(R)
S * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
S * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR
S * indicates the destination IP address & port number respectively.
S */
S#define UPORTR              (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief PHY Status Register(R/W)
S * @details @ref PHYCFGR configures PHY operation mode and resets PHY. In addition, @ref PHYCFGR indicates the status of PHY such as duplex, Speed, Link.
S */
S#define PHYCFGR            (_W5500_IO_BASE_ + (0x002E << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S// Reserved			         (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0031 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0032 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0033 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0034 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0035 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0036 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0037 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0038 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S/**
S * @ingroup Common_register_group
S * @brief chip version register address(R)
S * @details @ref VERSIONR always indicates the W5500 version as @b 0x04.
S */
S#define VERSIONR           (_W5500_IO_BASE_ + (0x0039 << 8) + (WIZCHIP_CREG_BLOCK << 3))
S
S
S//----------------------------- W5500 Socket Registers IOMAP -----------------------------
S/**
S * @ingroup Socket_register_group
S * @brief socket Mode register(R/W)
S * @details @ref Sn_MR configures the option or protocol type of Socket n.\n\n
S * Each bit of @ref Sn_MR defined as the following.
S * <table>
S * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
S * 		<tr>  <td>MULTI/MFEN</td> <td>BCASTB</td> <td>ND/MC/MMB</td> <td>UCASTB/MIP6B</td> <td>Protocol[3]</td> <td>Protocol[2]</td> <td>Protocol[1]</td> <td>Protocol[0]</td> </tr>
S * </table>
S * - @ref Sn_MR_MULTI	: Support UDP Multicasting
S * - @ref Sn_MR_BCASTB	: Broadcast block <b>in UDP Multicasting</b>
S * - @ref Sn_MR_ND		: No Delayed Ack(TCP) flag
S * - @ref Sn_MR_MC   	: IGMP version used <b>in UDP mulitcasting</b>
S * - @ref Sn_MR_MMB    	: Multicast Blocking <b>in @ref Sn_MR_MACRAW mode</b>
S * - @ref Sn_MR_UCASTB	: Unicast Block <b>in UDP Multicating</b>
S * - @ref Sn_MR_MIP6B   : IPv6 packet Blocking <b>in @ref Sn_MR_MACRAW mode</b>
S * - <b>Protocol</b>
S * <table>
S * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
S * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>Closed</td>   </tr>
S * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>TCP</td>   </tr>
S * 		<tr>   <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>UDP</td>   </tr>
S * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
S * </table>
S *	- @ref Sn_MR_MACRAW	: MAC LAYER RAW SOCK \n
S *  - @ref Sn_MR_UDP		: UDP
S *  - @ref Sn_MR_TCP		: TCP
S *  - @ref Sn_MR_CLOSE	: Unused socket
S *  @note MACRAW mode should be only used in Socket 0.
S */
S#define Sn_MR(N)           (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Socket command register(R/W)
S * @details This is used to set the command for Socket n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
S * After W5500 accepts the command, the @ref Sn_CR register is automatically cleared to 0x00.
S * Even though @ref Sn_CR is cleared to 0x00, the command is still being processed.\n
S * To check whether the command is completed or not, please check the @ref Sn_IR or @ref Sn_SR.
S * - @ref Sn_CR_OPEN 		: Initialize or open socket.
S * - @ref Sn_CR_LISTEN 		: Wait connection request in TCP mode(<b>Server mode</b>)
S * - @ref Sn_CR_CONNECT 	: Send connection request in TCP mode(<b>Client mode</b>)
S * - @ref Sn_CR_DISCON 		: Send closing request in TCP mode.
S * - @ref Sn_CR_CLOSE   	: Close socket.
S * - @ref Sn_CR_SEND    	: Update TX buffer pointer and send data.
S * - @ref Sn_CR_SEND_MAC	: Send data with MAC address, so without ARP process.
S * - @ref Sn_CR_SEND_KEEP 	: Send keep alive message.
S * - @ref Sn_CR_RECV		: Update RX buffer pointer and receive data.
S */
S#define Sn_CR(N)           (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Socket interrupt register(R)
S * @details @ref Sn_IR indicates the status of Socket Interrupt such as establishment, termination, receiving data, timeout).\n
S * When an interrupt occurs and the corresponding bit of @ref Sn_IMR is  the corresponding bit of @ref Sn_IR becomes \n
S * In order to clear the @ref Sn_IR bit, the host should write the bit to \n
S * <table>
S * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
S * 		<tr>  <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>SEND_OK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
S * </table>
S * - \ref Sn_IR_SENDOK : <b>SEND_OK Interrupt</b>
S * - \ref Sn_IR_TIMEOUT : <b>TIMEOUT Interrupt</b>
S * - \ref Sn_IR_RECV : <b>RECV Interrupt</b>
S * - \ref Sn_IR_DISCON : <b>DISCON Interrupt</b>
S * - \ref Sn_IR_CON : <b>CON Interrupt</b>
S */
S#define Sn_IR(N)           (_W5500_IO_BASE_ + (0x0002 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Socket status register(R)
S * @details @ref Sn_SR indicates the status of Socket n.\n
S * The status of Socket n is changed by @ref Sn_CR or some special control packet as SYN, FIN packet in TCP.
S * @par Normal status
S * - @ref SOCK_CLOSED 		: Closed
S * - @ref SOCK_INIT   		: Initiate state
S * - @ref SOCK_LISTEN    	: Listen state
S * - @ref SOCK_ESTABLISHED 	: Success to connect
S * - @ref SOCK_CLOSE_WAIT   : Closing state
S * - @ref SOCK_UDP   		: UDP socket
S * - @ref SOCK_MACRAW  		: MAC raw mode socket
S *@par Temporary status during changing the status of Socket n.
S * - @ref SOCK_SYNSENT   	: This indicates Socket n sent the connect-request packet (SYN packet) to a peer.
S * - @ref SOCK_SYNRECV    	: It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.
S * - @ref SOCK_FIN_WAIT		: Connection state
S * - @ref SOCK_CLOSING		: Closing state
S * - @ref SOCK_TIME_WAIT	: Closing state
S * - @ref SOCK_LAST_ACK 	: Closing state
S */
S#define Sn_SR(N)           (_W5500_IO_BASE_ + (0x0003 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief source port register(R/W)
S * @details @ref Sn_PORT configures the source port number of Socket n.
S * It is valid when Socket n is used in TCP/UPD mode. It should be set before OPEN command is ordered.
S */
S#define Sn_PORT(N)         (_W5500_IO_BASE_ + (0x0004 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Peer MAC register address(R/W)
S * @details @ref Sn_DHAR configures the destination hardware address of Socket n when using SEND_MAC command in UDP mode or
S * it indicates that it is acquired in ARP-process by CONNECT/SEND command.
S */
S#define Sn_DHAR(N)         (_W5500_IO_BASE_ + (0x0006 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Peer IP register address(R/W)
S * @details @ref Sn_DIPR configures or indicates the destination IP address of Socket n. It is valid when Socket n is used in TCP/UDP mode.
S * In TCP client mode, it configures an IP address of �TCP serverbefore CONNECT command.
S * In TCP server mode, it indicates an IP address of �TCP clientafter successfully establishing connection.
S * In UDP mode, it configures an IP address of peer to be received the UDP packet by SEND or SEND_MAC command.
S */
S#define Sn_DIPR(N)         (_W5500_IO_BASE_ + (0x000C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Peer port register address(R/W)
S * @details @ref Sn_DPORT configures or indicates the destination port number of Socket n. It is valid when Socket n is used in TCP/UDP mode.
S * In �TCP clientmode, it configures the listen port number of �TCP serverbefore CONNECT command.
S * In �TCP Servermode, it indicates the port number of TCP client after successfully establishing connection.
S * In UDP mode, it configures the port number of peer to be transmitted the UDP packet by SEND/SEND_MAC command.
S */
S#define Sn_DPORT(N)        (_W5500_IO_BASE_ + (0x0010 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Maximum Segment Size(Sn_MSSR0) register address(R/W)
S * @details @ref Sn_MSSR configures or indicates the MTU(Maximum Transfer Unit) of Socket n.
S */
S#define Sn_MSSR(N)         (_W5500_IO_BASE_ + (0x0012 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S// Reserved			         (_W5500_IO_BASE_ + (0x0014 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief IP Type of Service(TOS) Register(R/W)
S * @details @ref Sn_TOS configures the TOS(Type Of Service field in IP Header) of Socket n.
S * It is set before OPEN command.
S */
S#define Sn_TOS(N)          (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S/**
S * @ingroup Socket_register_group
S * @brief IP Time to live(TTL) Register(R/W)
S * @details @ref Sn_TTL configures the TTL(Time To Live field in IP header) of Socket n.
S * It is set before OPEN command.
S */
S#define Sn_TTL(N)          (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3)) 
S// Reserved			         (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x001A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S// Reserved			         (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Receive memory size register(R/W)
S * @details @ref Sn_RXBUF_SIZE configures the RX buffer block size of Socket n.
S * Socket n RX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
S * If a different size is configured, the data cannot be normally received from a peer.
S * Although Socket n RX Buffer Block size is initially configured to 2Kbytes,
S * user can re-configure its size using @ref Sn_RXBUF_SIZE. The total sum of @ref Sn_RXBUF_SIZE can not be exceed 16Kbytes.
S * When exceeded, the data reception error is occurred.
S */
S#define Sn_RXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Transmit memory size register(R/W)
S * @details @ref Sn_TXBUF_SIZE configures the TX buffer block size of Socket n. Socket n TX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
S * If a different size is configured, the data can�t be normally transmitted to a peer.
S * Although Socket n TX Buffer Block size is initially configured to 2Kbytes,
S * user can be re-configure its size using @ref Sn_TXBUF_SIZE. The total sum of @ref Sn_TXBUF_SIZE can not be exceed 16Kbytes.
S * When exceeded, the data transmission error is occurred.
S */
S#define Sn_TXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Transmit free memory size register(R)
S * @details @ref Sn_TX_FSR indicates the free size of Socket n TX Buffer Block. It is initialized to the configured size by @ref Sn_TXBUF_SIZE.
S * Data bigger than @ref Sn_TX_FSR should not be saved in the Socket n TX Buffer because the bigger data overwrites the previous saved data not yet sent.
S * Therefore, check before saving the data to the Socket n TX Buffer, and if data is equal or smaller than its checked size,
S * transmit the data with SEND/SEND_MAC command after saving the data in Socket n TX buffer. But, if data is bigger than its checked size,
S * transmit the data after dividing into the checked size and saving in the Socket n TX buffer.
S */
S#define Sn_TX_FSR(N)       (_W5500_IO_BASE_ + (0x0020 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Transmit memory read pointer register address(R)
S * @details @ref Sn_TX_RD is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.
S * After its initialization, it is auto-increased by SEND command.
S * SEND command transmits the saved data from the current @ref Sn_TX_RD to the @ref Sn_TX_WR in the Socket n TX Buffer.
S * After transmitting the saved data, the SEND command increases the @ref Sn_TX_RD as same as the @ref Sn_TX_WR.
S * If its increment value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
S * then the carry bit is ignored and will automatically update with the lower 16bits value.
S */
S#define Sn_TX_RD(N)        (_W5500_IO_BASE_ + (0x0022 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Transmit memory write pointer register address(R/W)
S * @details @ref Sn_TX_WR is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.\n
S * It should be read or be updated like as follows.\n
S * 1. Read the starting address for saving the transmitting data.\n
S * 2. Save the transmitting data from the starting address of Socket n TX buffer.\n
S * 3. After saving the transmitting data, update @ref Sn_TX_WR to the increased value as many as transmitting data size.
S * If the increment value exceeds the maximum value 0xFFFF(greater than 0x10000 and the carry bit occurs),
S * then the carry bit is ignored and will automatically update with the lower 16bits value.\n
S * 4. Transmit the saved data in Socket n TX Buffer by using SEND/SEND command
S */
S#define Sn_TX_WR(N)        (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Received data size register(R)
S * @details @ref Sn_RX_RSR indicates the data size received and saved in Socket n RX Buffer.
S * @ref Sn_RX_RSR does not exceed the @ref Sn_RXBUF_SIZE and is calculated as the difference between
S * �Socket n RX Write Pointer (@ref Sn_RX_WR)and �Socket n RX Read Pointer (@ref Sn_RX_RD)
S */
S#define Sn_RX_RSR(N)       (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Read point of Receive memory(R/W)
S * @details @ref Sn_RX_RD is initialized by OPEN command. Make sure to be read or updated as follows.\n
S * 1. Read the starting save address of the received data.\n
S * 2. Read data from the starting address of Socket n RX Buffer.\n
S * 3. After reading the received data, Update @ref Sn_RX_RD to the increased value as many as the reading size.
S * If the increment value exceeds the maximum value 0xFFFF, that is, is greater than 0x10000 and the carry bit occurs,
S * update with the lower 16bits value ignored the carry bit.\n
S * 4. Order RECV command is for notifying the updated @ref Sn_RX_RD to W5500.
S */
S#define Sn_RX_RD(N)        (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Write point of Receive memory(R)
S * @details @ref Sn_RX_WR is initialized by OPEN command and it is auto-increased by the data reception.
S * If the increased value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
S * then the carry bit is ignored and will automatically update with the lower 16bits value.
S */
S#define Sn_RX_WR(N)        (_W5500_IO_BASE_ + (0x002A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief socket interrupt mask register(R)
S * @details @ref Sn_IMR masks the interrupt of Socket n.
S * Each bit corresponds to each bit of @ref Sn_IR. When a Socket n Interrupt is occurred and the corresponding bit of @ref Sn_IMR is 
S * the corresponding bit of @ref Sn_IR becomes  When both the corresponding bit of @ref Sn_IMR and @ref Sn_IR are and the n-th bit of @ref IR is 
S * Host is interrupted by asserted INTn PIN to low.
S */
S#define Sn_IMR(N)          (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Fragment field value in IP header register(R/W)
S * @details @ref Sn_FRAG configures the FRAG(Fragment field in IP header).
S */
S#define Sn_FRAG(N)         (_W5500_IO_BASE_ + (0x002D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S/**
S * @ingroup Socket_register_group
S * @brief Keep Alive Timer register(R/W)
S * @details @ref Sn_KPALVTR configures the transmitting timer of �KEEP ALIVE(KA)packet of SOCKETn. It is valid only in TCP mode,
S * and ignored in other modes. The time unit is 5s.
S * KA packet is transmittable after @ref Sn_SR is changed to SOCK_ESTABLISHED and after the data is transmitted or received to/from a peer at least once.
S * In case of '@ref Sn_KPALVTR > 0', W5500 automatically transmits KA packet after time-period for checking the TCP connection (Auto-keepalive-process).
S * In case of '@ref Sn_KPALVTR = 0', Auto-keep-alive-process will not operate,
S * and KA packet can be transmitted by SEND_KEEP command by the host (Manual-keep-alive-process).
S * Manual-keep-alive-process is ignored in case of '@ref Sn_KPALVTR > 0'.
S */
S#define Sn_KPALVTR(N)      (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S//#define Sn_TSR(N)          (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
S
S
S//----------------------------- W5500 Register values  -----------------------------
S
S/* MODE register values */
S/**
S * @brief Reset
S * @details If this bit is  All internal registers will be initialized. It will be automatically cleared as after S/W reset.
S */
S#define MR_RST                       0x80
S
S/**
S * @brief Wake on LAN
S * @details 0 : Disable WOL mode\n
S * 1 : Enable WOL mode\n
S * If WOL mode is enabled and the received magic packet over UDP has been normally processed, the Interrupt PIN (INTn) asserts to low.
S * When using WOL mode, the UDP Socket should be opened with any source port number. (Refer to Socket n Mode Register (@ref Sn_MR) for opening Socket.)
S * @note The magic packet over UDP supported by W5500 consists of 6 bytes synchronization stream (xFFFFFFFFFFFF and
S * 16 times Target MAC address stream in UDP payload. The options such like password are ignored. You can use any UDP source port number for WOL mode.
S */
S#define MR_WOL                       0x20
S
S/**
S * @brief Ping block
S * @details 0 : Disable Ping block\n
S * 1 : Enable Ping block\n
S * If the bit is  it blocks the response to a ping request.
S */
S#define MR_PB                        0x10
S
S/**
S * @brief Enable PPPoE
S * @details 0 : DisablePPPoE mode\n
S * 1 : EnablePPPoE mode\n
S * If you use ADSL, this bit should be 
S */
S#define MR_PPPOE                     0x08
S
S/**
S * @brief Enable UDP_FORCE_ARP CHECHK
S * @details 0 : Disable Force ARP mode\n
S * 1 : Enable Force ARP mode\n
S * In Force ARP mode, It forces on sending ARP Request whenever data is sent.
S */
S#define MR_FARP                      0x02
S
S/* IR register values */
S/**
S * @brief Check IP conflict.
S * @details Bit is set as when own source IP address is same with the sender IP address in the received ARP request.
S */
S#define IR_CONFLICT                  0x80
S
S/**
S * @brief Get the destination unreachable message in UDP sending.
S * @details When receiving the ICMP (Destination port unreachable) packet, this bit is set as 
S * When this bit is  Destination Information such as IP address and Port number may be checked with the corresponding @ref UIPR & @ref UPORTR.
S */
S#define IR_UNREACH                   0x40
S
S/**
S * @brief Get the PPPoE close message.
S * @details When PPPoE is disconnected during PPPoE mode, this bit is set.
S */
S#define IR_PPPoE                     0x20
S
S/**
S * @brief Get the magic packet interrupt.
S * @details When WOL mode is enabled and receives the magic packet over UDP, this bit is set.
S */
S#define IR_MP                        0x10
S
S
S/* PHYCFGR register value */
S#define PHYCFGR_RST                  ~(1<<7)  //< For PHY reset, must operate AND mask.
S#define PHYCFGR_OPMD                 (1<<6)   // Configre PHY with OPMDC value
S#define PHYCFGR_OPMDC_ALLA           (7<<3)
S#define PHYCFGR_OPMDC_PDOWN          (6<<3)
S#define PHYCFGR_OPMDC_NA             (5<<3)
S#define PHYCFGR_OPMDC_100FA          (4<<3)
S#define PHYCFGR_OPMDC_100F           (3<<3)
S#define PHYCFGR_OPMDC_100H           (2<<3)
S#define PHYCFGR_OPMDC_10F            (1<<3)
S#define PHYCFGR_OPMDC_10H            (0<<3)           
S#define PHYCFGR_DPX_FULL             (1<<2)
S#define PHYCFGR_DPX_HALF             (0<<2)
S#define PHYCFGR_SPD_100              (1<<1)
S#define PHYCFGR_SPD_10               (0<<1)
S#define PHYCFGR_LNK_ON               (1<<0)
S#define PHYCFGR_LNK_OFF              (0<<0)
S
S/* IMR register values */
S/**
S * @brief IP Conflict Interrupt Mask.
S * @details 0: Disable IP Conflict Interrupt\n
S * 1: Enable IP Conflict Interrupt
S */
S#define IM_IR7                  	 0x80
S
S/**
S * @brief Destination unreachable Interrupt Mask.
S * @details 0: Disable Destination unreachable Interrupt\n
S * 1: Enable Destination unreachable Interrupt
S */
S#define IM_IR6                  	 0x40
S
S/**
S * @brief PPPoE Close Interrupt Mask.
S * @details 0: Disable PPPoE Close Interrupt\n
S * 1: Enable PPPoE Close Interrupt
S */
S#define IM_IR5                  	 0x20
S
S/**
S * @brief Magic Packet Interrupt Mask.
S * @details 0: Disable Magic Packet Interrupt\n
S * 1: Enable Magic Packet Interrupt
S */
S#define IM_IR4                  	 0x10
S
S/* Sn_MR Default values */
S/**
S * @brief Support UDP Multicasting
S * @details 0 : disable Multicasting\n
S * 1 : enable Multicasting\n
S * This bit is applied only during UDP mode(P[3:0] = 010.\n
S * To use multicasting, @ref Sn_DIPR & @ref Sn_DPORT should be respectively configured with the multicast group IP address & port number
S * before Socket n is opened by OPEN command of @ref Sn_CR.
S */
S#define Sn_MR_MULTI                  0x80
S
S/**
S * @brief Broadcast block in UDP Multicasting.
S * @details 0 : disable Broadcast Blocking\n
S * 1 : enable Broadcast Blocking\n
S * This bit blocks to receive broadcasting packet during UDP mode(P[3:0] = 010.\m
S * In addition, This bit does when MACRAW mode(P[3:0] = 100
S */
S#define Sn_MR_BCASTB                 0x40
S
S/**
S * @brief No Delayed Ack(TCP), Multicast flag
S * @details 0 : Disable No Delayed ACK option\n
S * 1 : Enable No Delayed ACK option\n
S * This bit is applied only during TCP mode (P[3:0] = 001.\n
S * When this bit is  It sends the ACK packet without delay as soon as a Data packet is received from a peer.\n
S * When this bit is  It sends the ACK packet after waiting for the timeout time configured by @ref RTR.
S */
S#define Sn_MR_ND                     0x20
S
S/**
S * @brief Unicast Block in UDP Multicasting
S * @details 0 : disable Unicast Blocking\n
S * 1 : enable Unicast Blocking\n
S * This bit blocks receiving the unicast packet during UDP mode(P[3:0] = 010 and MULTI = 
S */
S#define Sn_MR_UCASTB                 0x10
S
S/**
S * @brief MAC LAYER RAW SOCK
S * @details This configures the protocol mode of Socket n.
S * @note MACRAW mode should be only used in Socket 0.
S */
S#define Sn_MR_MACRAW                 0x04
S
S//#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
S
S/**
S * @brief UDP
S * @details This configures the protocol mode of Socket n.
S */
S#define Sn_MR_UDP                    0x02
S
S/**
S * @brief TCP
S * @details This configures the protocol mode of Socket n.
S */
S#define Sn_MR_TCP                    0x01
S
S/**
S * @brief Unused socket
S * @details This configures the protocol mode of Socket n.
S */
S#define Sn_MR_CLOSE                  0x00
S
S/* Sn_MR values used with Sn_MR_MACRAW */
S/**
S * @brief MAC filter enable in @ref Sn_MR_MACRAW mode
S * @details 0 : disable MAC Filtering\n
S * 1 : enable MAC Filtering\n
S * This bit is applied only during MACRAW mode(P[3:0] = 100.\n
S * When set as  W5500 can only receive broadcasting packet or packet sent to itself.
S * When this bit is  W5500 can receive all packets on Ethernet.
S * If user wants to implement Hybrid TCP/IP stack,
S * it is recommended that this bit is set as for reducing host overhead to process the all received packets.
S */
S#define Sn_MR_MFEN                   Sn_MR_MULTI
S
S/**
S * @brief Multicast Blocking in @ref Sn_MR_MACRAW mode
S * @details 0 : using IGMP version 2\n
S * 1 : using IGMP version 1\n
S * This bit is applied only during UDP mode(P[3:0] = 010 and MULTI = 
S * It configures the version for IGMP messages (Join/Leave/Report).
S */
S#define Sn_MR_MMB                    Sn_MR_ND
S
S/**
S * @brief IPv6 packet Blocking in @ref Sn_MR_MACRAW mode
S * @details 0 : disable IPv6 Blocking\n
S * 1 : enable IPv6 Blocking\n
S * This bit is applied only during MACRAW mode (P[3:0] = 100. It blocks to receiving the IPv6 packet.
S */
S#define Sn_MR_MIP6B                  Sn_MR_UCASTB
S
S/* Sn_MR value used with Sn_MR_UDP & Sn_MR_MULTI */
S/**
S * @brief IGMP version used in UDP mulitcasting
S * @details 0 : disable Multicast Blocking\n
S * 1 : enable Multicast Blocking\n
S * This bit is applied only when MACRAW mode(P[3:0] = 100. It blocks to receive the packet with multicast MAC address.
S */
S#define Sn_MR_MC                     Sn_MR_ND
S
S/* Sn_MR alternate values */
S/**
S * @brief For Berkeley Socket API
S */
S#define SOCK_STREAM                  Sn_MR_TCP
S
S/**
S * @brief For Berkeley Socket API
S */
S#define SOCK_DGRAM                   Sn_MR_UDP
S
S
S/* Sn_CR values */
S/**
S * @brief Initialize or open socket
S * @details Socket n is initialized and opened according to the protocol selected in Sn_MR(P3:P0).
S * The table below shows the value of @ref Sn_SR corresponding to @ref Sn_MR.\n
S * <table>
S *   <tr>  <td>\b Sn_MR (P[3:0])</td> <td>\b Sn_SR</td>            		 </tr>
S *   <tr>  <td>Sn_MR_CLOSE  (000</td> <td></td>         	   		 </tr>
S *   <tr>  <td>Sn_MR_TCP  (001</td> <td>SOCK_INIT (0x13)</td>  		 </tr>
S *   <tr>  <td>Sn_MR_UDP  (010</td>  <td>SOCK_UDP (0x22)</td>  		 </tr>
S *   <tr>  <td>S0_MR_MACRAW  (100</td>  <td>SOCK_MACRAW (0x02)</td>  </tr>
S * </table>
S */
S#define Sn_CR_OPEN                   0x01
S
S/**
S * @brief Wait connection request in TCP mode(Server mode)
S * @details This is valid only in TCP mode (Sn_MR(P3:P0) = Sn_MR_TCP).
S * In this mode, Socket n operates as a �TCP serverand waits for  connection-request (SYN packet) from any �TCP client
S * The @ref Sn_SR changes the state from SOCK_INIT to SOCKET_LISTEN.
S * When a �TCP clientconnection request is successfully established,
S * the @ref Sn_SR changes from SOCK_LISTEN to SOCK_ESTABLISHED and the Sn_IR(0) becomes 
S * But when a �TCP clientconnection request is failed, Sn_IR(3) becomes and the status of @ref Sn_SR changes to SOCK_CLOSED.
S */
S#define Sn_CR_LISTEN                 0x02
S
S/**
S * @brief Send connection request in TCP mode(Client mode)
S * @details  To connect, a connect-request (SYN packet) is sent to b>TCP server</b>configured by @ref Sn_DIPR & Sn_DPORT(destination address & port).
S * If the connect-request is successful, the @ref Sn_SR is changed to @ref SOCK_ESTABLISHED and the Sn_IR(0) becomes \n\n
S * The connect-request fails in the following three cases.\n
S * 1. When a @b ARPTO occurs (@ref Sn_IR[3] =  ) because destination hardware address is not acquired through the ARP-process.\n
S * 2. When a @b SYN/ACK packet is not received and @b TCPTO (Sn_IR(3) =  )\n
S * 3. When a @b RST packet is received instead of a @b SYN/ACK packet. In these cases, @ref Sn_SR is changed to @ref SOCK_CLOSED.
S * @note This is valid only in TCP mode and operates when Socket n acts as b>TCP client</b>
S */
S#define Sn_CR_CONNECT                0x04
S
S/**
S * @brief Send closing request in TCP mode
S * @details Regardless of b>TCP server</b>or b>TCP client</b> the DISCON command processes the disconnect-process (b>Active close</b>or b>Passive close</b>.\n
S * @par Active close
S * it transmits disconnect-request(FIN packet) to the connected peer\n
S * @par Passive close
S * When FIN packet is received from peer, a FIN packet is replied back to the peer.\n
S * @details When the disconnect-process is successful (that is, FIN/ACK packet is received successfully), @ref Sn_SR is changed to @ref SOCK_CLOSED.\n
S * Otherwise, TCPTO occurs (Sn_IR(3)=)= and then @ref Sn_SR is changed to @ref SOCK_CLOSED.
S * @note Valid only in TCP mode.
S */
S#define Sn_CR_DISCON                 0x08
S
S/**
S * @brief Close socket
S * @details Sn_SR is changed to @ref SOCK_CLOSED.
S */
S#define Sn_CR_CLOSE                  0x10
S
S/**
S * @brief Update TX buffer pointer and send data
S * @details SEND transmits all the data in the Socket n TX buffer.\n
S * For more details, please refer to Socket n TX Free Size Register (@ref Sn_TX_FSR), Socket n,
S * TX Write Pointer Register(@ref Sn_TX_WR), and Socket n TX Read Pointer Register(@ref Sn_TX_RD).
S */
S#define Sn_CR_SEND                   0x20
S
S/**
S * @brief Send data with MAC address, so without ARP process
S * @details The basic operation is same as SEND.\n
S * Normally SEND transmits data after destination hardware address is acquired by the automatic ARP-process(Address Resolution Protocol).\n
S * But SEND_MAC transmits data without the automatic ARP-process.\n
S * In this case, the destination hardware address is acquired from @ref Sn_DHAR configured by host, instead of APR-process.
S * @note Valid only in UDP mode.
S */
S#define Sn_CR_SEND_MAC               0x21
S
S/**
S * @brief Send keep alive message
S * @details It checks the connection status by sending 1byte keep-alive packet.\n
S * If the peer can not respond to the keep-alive packet during timeout time, the connection is terminated and the timeout interrupt will occur.
S * @note Valid only in TCP mode.
S */
S#define Sn_CR_SEND_KEEP              0x22
S
S/**
S * @brief Update RX buffer pointer and receive data
S * @details RECV completes the processing of the received data in Socket n RX Buffer by using a RX read pointer register (@ref Sn_RX_RD).\n
S * For more details, refer to Socket n RX Received Size Register (@ref Sn_RX_RSR), Socket n RX Write Pointer Register (@ref Sn_RX_WR),
S * and Socket n RX Read Pointer Register (@ref Sn_RX_RD).
S */
S#define Sn_CR_RECV                   0x40
S
S/* Sn_IR values */
S/**
S * @brief SEND_OK Interrupt
S * @details This is issued when SEND command is completed.
S */
S#define Sn_IR_SENDOK                 0x10
S
S/**
S * @brief TIMEOUT Interrupt
S * @details This is issued when ARPTO or TCPTO occurs.
S */
S#define Sn_IR_TIMEOUT                0x08
S
S/**
S * @brief RECV Interrupt
S * @details This is issued whenever data is received from a peer.
S */
S#define Sn_IR_RECV                   0x04
S
S/**
S * @brief DISCON Interrupt
S * @details This is issued when FIN or FIN/ACK packet is received from a peer.
S */
S#define Sn_IR_DISCON                 0x02
S
S/**
S * @brief CON Interrupt
S * @details This is issued one time when the connection with peer is successful and then @ref Sn_SR is changed to @ref SOCK_ESTABLISHED.
S */
S#define Sn_IR_CON                    0x01
S
S/* Sn_SR values */
S/**
S * @brief Closed
S * @details This indicates that Socket n is released.\N
S * When DICON, CLOSE command is ordered, or when a timeout occurs, it is changed to @ref SOCK_CLOSED regardless of previous status.
S */
S#define SOCK_CLOSED                  0x00
S
S/**
S * @brief Initiate state
S * @details This indicates Socket n is opened with TCP mode.\N
S * It is changed to @ref SOCK_INIT when Sn_MR(P[3:0]) = 001and OPEN command is ordered.\N
S * After @ref SOCK_INIT, user can use LISTEN /CONNECT command.
S */
S#define SOCK_INIT                    0x13
S
S/**
S * @brief Listen state
S * @details This indicates Socket n is operating as b>TCP server</b>mode and waiting for connection-request (SYN packet) from a peer (b>TCP client</b>.\n
S * It will change to @ref SOCK_ESTALBLISHED when the connection-request is successfully accepted.\n
S * Otherwise it will change to @ref SOCK_CLOSED after TCPTO occurred (Sn_IR(TIMEOUT) = .
S */
S#define SOCK_LISTEN                  0x14
S
S/**
S * @brief Connection state
S * @details This indicates Socket n sent the connect-request packet (SYN packet) to a peer.\n
S * It is temporarily shown when @ref Sn_SR is changed from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by CONNECT command.\n
S * If connect-accept(SYN/ACK packet) is received from the peer at SOCK_SYNSENT, it changes to @ref SOCK_ESTABLISHED.\n
S * Otherwise, it changes to @ref SOCK_CLOSED after TCPTO (@ref Sn_IR[TIMEOUT] =  is occurred.
S */
S#define SOCK_SYNSENT                 0x15
S
S/**
S * @brief Connection state
S * @details It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.\n
S * If socket n sends the response (SYN/ACK  packet) to the peer successfully,  it changes to @ref SOCK_ESTABLISHED. \n
S * If not, it changes to @ref SOCK_CLOSED after timeout occurs (@ref Sn_IR[TIMEOUT] = .
S */
S#define SOCK_SYNRECV                 0x16
S
S/**
S * @brief Success to connect
S * @details This indicates the status of the connection of Socket n.\n
S * It changes to @ref SOCK_ESTABLISHED when the b>TCP SERVER</b>processed the SYN packet from the b>TCP CLIENT</b>during @ref SOCK_LISTEN, or
S * when the CONNECT command is successful.\n
S * During @ref SOCK_ESTABLISHED, DATA packet can be transferred using SEND or RECV command.
S */
S#define SOCK_ESTABLISHED             0x17
S
S/**
S * @brief Closing state
S * @details These indicate Socket n is closing.\n
S * These are shown in disconnect-process such as active-close and passive-close.\n
S * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
S */
S#define SOCK_FIN_WAIT                0x18
S
S/**
S * @brief Closing state
S * @details These indicate Socket n is closing.\n
S * These are shown in disconnect-process such as active-close and passive-close.\n
S * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
S */
S#define SOCK_CLOSING                 0x1A
S
S/**
S * @brief Closing state
S * @details These indicate Socket n is closing.\n
S * These are shown in disconnect-process such as active-close and passive-close.\n
S * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
S */
S#define SOCK_TIME_WAIT               0x1B
S
S/**
S * @brief Closing state
S * @details This indicates Socket n received the disconnect-request (FIN packet) from the connected peer.\n
S * This is half-closing status, and data can be transferred.\n
S * For full-closing, DISCON command is used. But For just-closing, CLOSE command is used.
S */
S#define SOCK_CLOSE_WAIT              0x1C
S
S/**
S * @brief Closing state
S * @details This indicates Socket n is waiting for the response (FIN/ACK packet) to the disconnect-request (FIN packet) by passive-close.\n
S * It changes to @ref SOCK_CLOSED when Socket n received the response successfully, or when timeout occurs  (@ref Sn_IR[TIMEOUT] = .
S */
S#define SOCK_LAST_ACK                0x1D
S
S/**
S * @brief UDP socket
S * @details This indicates Socket n is opened in UDP mode(Sn_MR(P[3:0]) = 010.\n
S * It changes to SOCK_UPD when Sn_MR(P[3:0]) = 010 and OPEN command is ordered.\n
S * Unlike TCP mode, data can be transfered without the connection-process.
S */
S#define SOCK_UDP                     0x22
S
S//#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
S
S/**
S * @brief MAC raw mode socket
S * @details This indicates Socket 0 is opened in MACRAW mode (S0_MR(P[3:0]) = 100and is valid only in Socket 0.\n
S * It changes to SOCK_MACRAW when S0_MR(P[3:0] = 100and OPEN command is ordered.\n
S * Like UDP mode socket, MACRAW mode Socket 0 can transfer a MAC packet (Ethernet frame) without the connection-process.
S */
S#define SOCK_MACRAW                  0x42
S
S//#define SOCK_PPPOE                   0x5F
S
S/* IP PROTOCOL */
S#define IPPROTO_IP                   0        //< Dummy for IP 
S#define IPPROTO_ICMP                 1        //< Control message protocol
S#define IPPROTO_IGMP                 2        //< Internet group management protocol
S#define IPPROTO_GGP                  3        //< Gateway^2 (deprecated)
S#define IPPROTO_TCP                  6        //< TCP
S#define IPPROTO_PUP                  12       //< PUP
S#define IPPROTO_UDP                  17       //< UDP
S#define IPPROTO_IDP                  22       //< XNS idp
S#define IPPROTO_ND                   77       //< UNOFFICIAL net disk protocol
S#define IPPROTO_RAW                  255      //< Raw IP packet
S
S
S/**
S * @brief Enter a critical section
S *
S * @details It is provided to protect your shared code which are executed without distribution. \n \n
S *
S * In non-OS environment, It can be just implemented by disabling whole interrupt.\n
S * In OS environment, You can replace it to critical section api supported by OS.
S *
S * \sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S * \sa WIZCHIP_CRITICAL_EXIT()
S */
S#define WIZCHIP_CRITICAL_ENTER()    WIZCHIP.CRIS._enter()
S
S/**
S * @brief Exit a critical section
S *
S * @details It is provided to protect your shared code which are executed without distribution. \n\n
S *
S * In non-OS environment, It can be just implemented by disabling whole interrupt. \n
S * In OS environment, You can replace it to critical section api supported by OS.
S *
S * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S * @sa WIZCHIP_CRITICAL_ENTER()
S */
S#define WIZCHIP_CRITICAL_EXIT()     WIZCHIP.CRIS._exit()
S
S
S
S////////////////////////
S// Basic I/O Function //
S////////////////////////
S
S/**
S * @ingroup Basic_IO_function
S * @brief It reads 1 byte value from a register.
S * @param AddrSel Register address
S * @return The value of register
S */
Suint8_t  WIZCHIP_READ (uint32_t AddrSel);
S
S/**
S * @ingroup Basic_IO_function
S * @brief It writes 1 byte value to a register.
S * @param AddrSel Register address
S * @param wb Write data
S * @return void
S */
Svoid     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
S
S/**
S * @ingroup Basic_IO_function
S * @brief It reads sequence data from registers.
S * @param AddrSel Register address
S * @param pBuf Pointer buffer to read data
S * @param len Data length
S */
Svoid     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
S
S/**
S * @ingroup Basic_IO_function
S * @brief It writes sequence data to registers.
S * @param AddrSel Register address
S * @param pBuf Pointer buffer to write data
S * @param len Data length
S */
Svoid     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
S
S/////////////////////////////////
S// Common Register I/O function //
S/////////////////////////////////
S/**
S * @ingroup Common_register_access_function
S * @brief Set Mode Register
S * @param (uint8_t)mr The value to be set.
S * @sa getMR()
S */
S#define setMR(mr) \
S	WIZCHIP_WRITE(MR,mr)
X#define setMR(mr) 	WIZCHIP_WRITE(MR,mr)
S
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get Mode Register
S * @return uint8_t. The value of Mode register.
S * @sa setMR()
S */
S#define getMR() \
S		WIZCHIP_READ(MR)
X#define getMR() 		WIZCHIP_READ(MR)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set gateway IP address
S * @param (uint8_t*)gar Pointer variable to set gateway IP address. It should be allocated 4 bytes.
S * @sa getGAR()
S */
S#define setGAR(gar) \
S		WIZCHIP_WRITE_BUF(GAR,gar,4)
X#define setGAR(gar) 		WIZCHIP_WRITE_BUF(GAR,gar,4)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get gateway IP address
S * @param (uint8_t*)gar Pointer variable to get gateway IP address. It should be allocated 4 bytes.
S * @sa setGAR()
S */
S#define getGAR(gar) \
S		WIZCHIP_READ_BUF(GAR,gar,4)
X#define getGAR(gar) 		WIZCHIP_READ_BUF(GAR,gar,4)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set subnet mask address
S * @param (uint8_t*)subr Pointer variable to set subnet mask address. It should be allocated 4 bytes.
S * @sa getSUBR()
S */
S#define setSUBR(subr) \
S		WIZCHIP_WRITE_BUF(SUBR, subr,4)
X#define setSUBR(subr) 		WIZCHIP_WRITE_BUF(SUBR, subr,4)
S
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get subnet mask address
S * @param (uint8_t*)subr Pointer variable to get subnet mask address. It should be allocated 4 bytes.
S * @sa setSUBR()
S */
S#define getSUBR(subr) \
S		WIZCHIP_READ_BUF(SUBR, subr, 4)
X#define getSUBR(subr) 		WIZCHIP_READ_BUF(SUBR, subr, 4)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set local MAC address
S * @param (uint8_t*)shar Pointer variable to set local MAC address. It should be allocated 6 bytes.
S * @sa getSHAR()
S */
S#define setSHAR(shar) \
S		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
X#define setSHAR(shar) 		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get local MAC address
S * @param (uint8_t*)shar Pointer variable to get local MAC address. It should be allocated 6 bytes.
S * @sa setSHAR()
S */
S#define getSHAR(shar) \
S		WIZCHIP_READ_BUF(SHAR, shar, 6)
X#define getSHAR(shar) 		WIZCHIP_READ_BUF(SHAR, shar, 6)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set local IP address
S * @param (uint8_t*)sipr Pointer variable to set local IP address. It should be allocated 4 bytes.
S * @sa getSIPR()
S */
S#define setSIPR(sipr) \
S		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
X#define setSIPR(sipr) 		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get local IP address
S * @param (uint8_t*)sipr Pointer variable to get local IP address. It should be allocated 4 bytes.
S * @sa setSIPR()
S */
S#define getSIPR(sipr) \
S		WIZCHIP_READ_BUF(SIPR, sipr, 4)
X#define getSIPR(sipr) 		WIZCHIP_READ_BUF(SIPR, sipr, 4)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set INTLEVEL register
S * @param (uint16_t)intlevel Value to set @ref INTLEVEL register.
S * @sa getINTLEVEL()
S */
S#define setINTLEVEL(intlevel)  {\
S		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); \
S	}
X#define setINTLEVEL(intlevel)  {		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); 	}
S
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get INTLEVEL register
S * @return uint16_t. Value of @ref INTLEVEL register.
S * @sa setINTLEVEL()
S */
S#define getINTLEVEL() \
S		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
X#define getINTLEVEL() 		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref IR register
S * @param (uint8_t)ir Value to set @ref IR register.
S * @sa getIR()
S */
S#define setIR(ir) \
S		WIZCHIP_WRITE(IR, (ir & 0xF0))
X#define setIR(ir) 		WIZCHIP_WRITE(IR, (ir & 0xF0))
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref IR register
S * @return uint8_t. Value of @ref IR register.
S * @sa setIR()
S */
S#define getIR() \
S		(WIZCHIP_READ(IR) & 0xF0)
X#define getIR() 		(WIZCHIP_READ(IR) & 0xF0)
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref IMR register
S * @param (uint8_t)imr Value to set @ref IMR register.
S * @sa getIMR()
S */
S#define setIMR(imr) \
S		WIZCHIP_WRITE(IMR, imr)
X#define setIMR(imr) 		WIZCHIP_WRITE(IMR, imr)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref IMR register
S * @return uint8_t. Value of @ref IMR register.
S * @sa setIMR()
S */
S#define getIMR() \
S		WIZCHIP_READ(IMR)
X#define getIMR() 		WIZCHIP_READ(IMR)
S
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref SIR register
S * @param (uint8_t)sir Value to set @ref SIR register.
S * @sa getSIR()
S */
S#define setSIR(sir) \
S		WIZCHIP_WRITE(SIR, sir)
X#define setSIR(sir) 		WIZCHIP_WRITE(SIR, sir)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref SIR register
S * @return uint8_t. Value of @ref SIR register.
S * @sa setSIR()
S */
S#define getSIR() \
S		WIZCHIP_READ(SIR)
X#define getSIR() 		WIZCHIP_READ(SIR)
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref SIMR register
S * @param (uint8_t)simr Value to set @ref SIMR register.
S * @sa getSIMR()
S */
S#define setSIMR(simr) \
S		WIZCHIP_WRITE(SIMR, simr)
X#define setSIMR(simr) 		WIZCHIP_WRITE(SIMR, simr)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref SIMR register
S * @return uint8_t. Value of @ref SIMR register.
S * @sa setSIMR()
S */
S#define getSIMR() \
S		WIZCHIP_READ(SIMR)
X#define getSIMR() 		WIZCHIP_READ(SIMR)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref RTR register
S * @param (uint16_t)rtr Value to set @ref RTR register.
S * @sa getRTR()
S */
S#define setRTR(rtr)   {\
S		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); \
S	}
X#define setRTR(rtr)   {		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); 	}
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref RTR register
S * @return uint16_t. Value of @ref RTR register.
S * @sa setRTR()
S */
S#define getRTR() \
S		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
X#define getRTR() 		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref RCR register
S * @param (uint8_t)rcr Value to set @ref RCR register.
S * @sa getRCR()
S */
S#define setRCR(rcr) \
S		WIZCHIP_WRITE(RCR, rcr)
X#define setRCR(rcr) 		WIZCHIP_WRITE(RCR, rcr)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref RCR register
S * @return uint8_t. Value of @ref RCR register.
S * @sa setRCR()
S */
S#define getRCR() \
S		WIZCHIP_READ(RCR)
X#define getRCR() 		WIZCHIP_READ(RCR)
S
S//================================================== test done ===========================================================
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref PTIMER register
S * @param (uint8_t)ptimer Value to set @ref PTIMER register.
S * @sa getPTIMER()
S */
S#define setPTIMER(ptimer) \
S		WIZCHIP_WRITE(PTIMER, ptimer)
X#define setPTIMER(ptimer) 		WIZCHIP_WRITE(PTIMER, ptimer)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref PTIMER register
S * @return uint8_t. Value of @ref PTIMER register.
S * @sa setPTIMER()
S */
S#define getPTIMER() \
S		WIZCHIP_READ(PTIMER)
X#define getPTIMER() 		WIZCHIP_READ(PTIMER)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref PMAGIC register
S * @param (uint8_t)pmagic Value to set @ref PMAGIC register.
S * @sa getPMAGIC()
S */
S#define setPMAGIC(pmagic) \
S		WIZCHIP_WRITE(PMAGIC, pmagic)
X#define setPMAGIC(pmagic) 		WIZCHIP_WRITE(PMAGIC, pmagic)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref PMAGIC register
S * @return uint8_t. Value of @ref PMAGIC register.
S * @sa setPMAGIC()
S */
S#define getPMAGIC() \
S		WIZCHIP_READ(PMAGIC)
X#define getPMAGIC() 		WIZCHIP_READ(PMAGIC)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set PHAR address
S * @param (uint8_t*)phar Pointer variable to set PPP destination MAC register address. It should be allocated 6 bytes.
S * @sa getPHAR()
S */
S#define setPHAR(phar) \
S		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
X#define setPHAR(phar) 		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get local IP address
S * @param (uint8_t*)phar Pointer variable to PPP destination MAC register address. It should be allocated 6 bytes.
S * @sa setPHAR()
S */
S#define getPHAR(phar) \
S		WIZCHIP_READ_BUF(PHAR, phar, 6)
X#define getPHAR(phar) 		WIZCHIP_READ_BUF(PHAR, phar, 6)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref PSID register
S * @param (uint16_t)psid Value to set @ref PSID register.
S * @sa getPSID()
S */
S#define setPSID(psid)  {\
S		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); \
S	}
X#define setPSID(psid)  {		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); 	}
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref PSID register
S * @return uint16_t. Value of @ref PSID register.
S * @sa setPSID()
S */
S//uint16_t getPSID(void);
S#define getPSID() \
S		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
X#define getPSID() 		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref PMRU register
S * @param (uint16_t)pmru Value to set @ref PMRU register.
S * @sa getPMRU()
S */
S#define setPMRU(pmru) { \
S		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); \
S	}
X#define setPMRU(pmru) { 		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); 	}
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref PMRU register
S * @return uint16_t. Value of @ref PMRU register.
S * @sa setPMRU()
S */
S#define getPMRU() \
S		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
X#define getPMRU() 		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get unreachable IP address
S * @param (uint8_t*)uipr Pointer variable to get unreachable IP address. It should be allocated 4 bytes.
S */
S#define getUIPR(uipr) \
S		WIZCHIP_READ_BUF(UIPR,uipr,6)
X#define getUIPR(uipr) 		WIZCHIP_READ_BUF(UIPR,uipr,6)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref UPORTR register
S * @return uint16_t. Value of @ref UPORTR register.
S */
S#define getUPORTR() \
S	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
X#define getUPORTR() 	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
S
S/**
S * @ingroup Common_register_access_function
S * @brief Set @ref PHYCFGR register
S * @param (uint8_t)phycfgr Value to set @ref PHYCFGR register.
S * @sa getPHYCFGR()
S */
S#define setPHYCFGR(phycfgr) \
S		WIZCHIP_WRITE(PHYCFGR, phycfgr)
X#define setPHYCFGR(phycfgr) 		WIZCHIP_WRITE(PHYCFGR, phycfgr)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref PHYCFGR register
S * @return uint8_t. Value of @ref PHYCFGR register.
S * @sa setPHYCFGR()
S */
S#define getPHYCFGR() \
S		WIZCHIP_READ(PHYCFGR)
X#define getPHYCFGR() 		WIZCHIP_READ(PHYCFGR)
S
S/**
S * @ingroup Common_register_access_function
S * @brief Get @ref VERSIONR register
S * @return uint8_t. Value of @ref VERSIONR register.
S */
S#define getVERSIONR() \
S		WIZCHIP_READ(VERSIONR)
X#define getVERSIONR() 		WIZCHIP_READ(VERSIONR)
S
S/////////////////////////////////////
S
S///////////////////////////////////
S// Socket N register I/O function //
S///////////////////////////////////
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_MR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)mr Value to set @ref Sn_MR
S * @sa getSn_MR()
S */
S#define setSn_MR(sn, mr) \
S		WIZCHIP_WRITE(Sn_MR(sn),mr)
X#define setSn_MR(sn, mr) 		WIZCHIP_WRITE(Sn_MR(sn),mr)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_MR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_MR.
S * @sa setSn_MR()
S */
S#define getSn_MR(sn) \
S	WIZCHIP_READ(Sn_MR(sn))
X#define getSn_MR(sn) 	WIZCHIP_READ(Sn_MR(sn))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_CR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)cr Value to set @ref Sn_CR
S * @sa getSn_CR()
S */
S#define setSn_CR(sn, cr) \
S		WIZCHIP_WRITE(Sn_CR(sn), cr)
X#define setSn_CR(sn, cr) 		WIZCHIP_WRITE(Sn_CR(sn), cr)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_CR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_CR.
S * @sa setSn_CR()
S */
S#define getSn_CR(sn) \
S		WIZCHIP_READ(Sn_CR(sn))
X#define getSn_CR(sn) 		WIZCHIP_READ(Sn_CR(sn))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_IR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)ir Value to set @ref Sn_IR
S * @sa getSn_IR()
S */
S#define setSn_IR(sn, ir) \
S		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
X#define setSn_IR(sn, ir) 		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_IR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_IR.
S * @sa setSn_IR()
S */
S#define getSn_IR(sn) \
S		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
X#define getSn_IR(sn) 		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_IMR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)imr Value to set @ref Sn_IMR
S * @sa getSn_IMR()
S */
S#define setSn_IMR(sn, imr) \
S		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
X#define setSn_IMR(sn, imr) 		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_IMR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_IMR.
S * @sa setSn_IMR()
S */
S#define getSn_IMR(sn) \
S		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
X#define getSn_IMR(sn) 		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_SR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_SR.
S */
S#define getSn_SR(sn) \
S		WIZCHIP_READ(Sn_SR(sn))
X#define getSn_SR(sn) 		WIZCHIP_READ(Sn_SR(sn))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_PORT register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint16_t)port Value to set @ref Sn_PORT.
S * @sa getSn_PORT()
S */
S#define setSn_PORT(sn, port)  { \
S		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); \
S	}
X#define setSn_PORT(sn, port)  { 		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); 	}
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_PORT register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_PORT.
S * @sa setSn_PORT()
S */
S#define getSn_PORT(sn) \
S		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
X#define getSn_PORT(sn) 		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_DHAR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t*)dhar Pointer variable to set socket n destination hardware address. It should be allocated 6 bytes.
S * @sa getSn_DHAR()
S */
S#define setSn_DHAR(sn, dhar) \
S		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
X#define setSn_DHAR(sn, dhar) 		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_MR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t*)dhar Pointer variable to get socket n destination hardware address. It should be allocated 6 bytes.
S * @sa setSn_DHAR()
S */
S#define getSn_DHAR(sn, dhar) \
S		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
X#define getSn_DHAR(sn, dhar) 		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_DIPR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t*)dipr Pointer variable to set socket n destination IP address. It should be allocated 4 bytes.
S * @sa getSn_DIPR()
S */
S#define setSn_DIPR(sn, dipr) \
S		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
X#define setSn_DIPR(sn, dipr) 		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_DIPR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t*)dipr Pointer variable to get socket n destination IP address. It should be allocated 4 bytes.
S * @sa SetSn_DIPR()
S */
S#define getSn_DIPR(sn, dipr) \
S		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
X#define getSn_DIPR(sn, dipr) 		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_DPORT register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint16_t)dport Value to set @ref Sn_DPORT
S * @sa getSn_DPORT()
S */
S#define setSn_DPORT(sn, dport) { \
S		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); \
S	}
X#define setSn_DPORT(sn, dport) { 		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); 	}
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_DPORT register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_DPORT.
S * @sa setSn_DPORT()
S */
S#define getSn_DPORT(sn) \
S		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
X#define getSn_DPORT(sn) 		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_MSSR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint16_t)mss Value to set @ref Sn_MSSR
S * @sa setSn_MSSR()
S */
S#define setSn_MSSR(sn, mss) { \
S		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); \
S	}
X#define setSn_MSSR(sn, mss) { 		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); 	}
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_MSSR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_MSSR.
S * @sa setSn_MSSR()
S */
S#define getSn_MSSR(sn) \
S		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
X#define getSn_MSSR(sn) 		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_TOS register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)tos Value to set @ref Sn_TOS
S * @sa getSn_TOS()
S */
S#define setSn_TOS(sn, tos) \
S		WIZCHIP_WRITE(Sn_TOS(sn), tos)
X#define setSn_TOS(sn, tos) 		WIZCHIP_WRITE(Sn_TOS(sn), tos)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_TOS register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of Sn_TOS.
S * @sa setSn_TOS()
S */
S#define getSn_TOS(sn) \
S		WIZCHIP_READ(Sn_TOS(sn))
X#define getSn_TOS(sn) 		WIZCHIP_READ(Sn_TOS(sn))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_TTL register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)ttl Value to set @ref Sn_TTL
S * @sa getSn_TTL()
S */
S#define setSn_TTL(sn, ttl) \
S		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
X#define setSn_TTL(sn, ttl) 		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
S
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_TTL register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_TTL.
S * @sa setSn_TTL()
S */
S#define getSn_TTL(sn) \
S		WIZCHIP_READ(Sn_TTL(sn))
X#define getSn_TTL(sn) 		WIZCHIP_READ(Sn_TTL(sn))
S
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_RXBUF_SIZE register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)rxbufsize Value to set @ref Sn_RXBUF_SIZE
S * @sa getSn_RXBUF_SIZE()
S */
S#define setSn_RXBUF_SIZE(sn, rxbufsize) \
S		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
X#define setSn_RXBUF_SIZE(sn, rxbufsize) 		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
S
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_RXBUF_SIZE register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_RXBUF_SIZE.
S * @sa setSn_RXBUF_SIZE()
S */
S#define getSn_RXBUF_SIZE(sn) \
S		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
X#define getSn_RXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_TXBUF_SIZE register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)txbufsize Value to set @ref Sn_TXBUF_SIZE
S * @sa getSn_TXBUF_SIZE()
S */
S#define setSn_TXBUF_SIZE(sn, txbufsize) \
S		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
X#define setSn_TXBUF_SIZE(sn, txbufsize) 		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_TXBUF_SIZE register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_TXBUF_SIZE.
S * @sa setSn_TXBUF_SIZE()
S */
S#define getSn_TXBUF_SIZE(sn) \
S		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
X#define getSn_TXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_TX_FSR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_TX_FSR.
S */
Suint16_t getSn_TX_FSR(uint8_t sn);
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_TX_RD register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_TX_RD.
S */
S#define getSn_TX_RD(sn) \
S		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
X#define getSn_TX_RD(sn) 		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_TX_WR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint16_t)txwr Value to set @ref Sn_TX_WR
S * @sa GetSn_TX_WR()
S */
S#define setSn_TX_WR(sn, txwr) { \
S		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); \
S		}
X#define setSn_TX_WR(sn, txwr) { 		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); 		}
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_TX_WR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_TX_WR.
S * @sa setSn_TX_WR()
S */
S#define getSn_TX_WR(sn) \
S		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
X#define getSn_TX_WR(sn) 		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
S
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_RX_RSR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_RX_RSR.
S */
Suint16_t getSn_RX_RSR(uint8_t sn);
S
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_RX_RD register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint16_t)rxrd Value to set @ref Sn_RX_RD
S * @sa getSn_RX_RD()
S */
S#define setSn_RX_RD(sn, rxrd) { \
S		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); \
S	}
X#define setSn_RX_RD(sn, rxrd) { 		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); 	}
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_RX_RD register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @regurn uint16_t. Value of @ref Sn_RX_RD.
S * @sa setSn_RX_RD()
S */
S#define getSn_RX_RD(sn) \
S		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
X#define getSn_RX_RD(sn) 		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_RX_WR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_RX_WR.
S */
S#define getSn_RX_WR(sn) \
S		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
X#define getSn_RX_WR(sn) 		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
S
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_FRAG register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint16_t)frag Value to set @ref Sn_FRAG
S * @sa getSn_FRAD()
S */
S#define setSn_FRAG(sn, frag) { \
S		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); \
S		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); \
S	}
X#define setSn_FRAG(sn, frag) { 		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); 	}
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_FRAG register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of @ref Sn_FRAG.
S * @sa setSn_FRAG()
S */
S#define getSn_FRAG(sn) \
S		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
X#define getSn_FRAG(sn) 		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Set @ref Sn_KPALVTR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param (uint8_t)kpalvt Value to set @ref Sn_KPALVTR
S * @sa getSn_KPALVTR()
S */
S#define setSn_KPALVTR(sn, kpalvt) \
S		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
X#define setSn_KPALVTR(sn, kpalvt) 		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
S
S/**
S * @ingroup Socket_register_access_function
S * @brief Get @ref Sn_KPALVTR register
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint8_t. Value of @ref Sn_KPALVTR.
S * @sa setSn_KPALVTR()
S */
S#define getSn_KPALVTR(sn) \
S		WIZCHIP_READ(Sn_KPALVTR(sn))
X#define getSn_KPALVTR(sn) 		WIZCHIP_READ(Sn_KPALVTR(sn))
S
S//////////////////////////////////////
S
S/////////////////////////////////////
S// Sn_TXBUF & Sn_RXBUF IO function //
S/////////////////////////////////////
S/**  
S * @brief Gets the max buffer size of socket sn passed as parameter.
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of Socket n RX max buffer size.
S */
S#define getSn_RxMAX(sn) \
S		(getSn_RXBUF_SIZE(sn) << 10)
X#define getSn_RxMAX(sn) 		(getSn_RXBUF_SIZE(sn) << 10)
S
S/**  
S * @brief Gets the max buffer size of socket sn passed as parameters.
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @return uint16_t. Value of Socket n TX max buffer size.
S */
S//uint16_t getSn_TxMAX(uint8_t sn);
S#define getSn_TxMAX(sn) \
S		(getSn_TXBUF_SIZE(sn) << 10)
X#define getSn_TxMAX(sn) 		(getSn_TXBUF_SIZE(sn) << 10)
S
S/**
S * @ingroup Basic_IO_function
S * @brief It copies data to internal TX memory
S *
S * @details This function reads the Tx write pointer register and after that,
S * it copies the <i>wizdata(pointer buffer)</i> of the length of <i>len(variable)</i> bytes to internal TX memory
S * and updates the Tx write pointer register.
S * This function is being called by send() and sendto() function also.
S *
S * @note User should read upper byte first and lower byte later to get proper value.
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param wizdata Pointer buffer to write data
S * @param len Data length
S * @sa wiz_recv_data()
S */
Svoid wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
S
S/**
S * @ingroup Basic_IO_function
S * @brief It copies data to your buffer from internal RX memory
S *
S * @details This function read the Rx read pointer register and after that,
S * it copies the received data from internal RX memory
S * to <i>wizdata(pointer variable)</i> of the length of <i>len(variable)</i> bytes.
S * This function is being called by recv() also.
S *
S * @note User should read upper byte first and lower byte later to get proper value.
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param wizdata Pointer buffer to read data
S * @param len Data length
S * @sa wiz_send_data()
S */
Svoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
S
S/**
S * @ingroup Basic_IO_function
S * @brief It discard the received data in RX memory.
S * @details It discards the data of the length of <i>len(variable)</i> bytes in internal RX memory.
S * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
S * @param len Data length
S */
Svoid wiz_recv_ignore(uint8_t sn, uint16_t len);
S
N#endif   // _W5500_H_
L 115 "..\..\Ethernet\wizchip_conf.h" 2
N#else 
S   #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
N#endif
N
N#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
N#endif
N
N/**
N * @brief Define I/O base address when BUS IF mode.
N * @todo Should re-define it to fit your system when BUS IF Mode (@ref \_WIZCHIP_IO_MODE_BUS_,
N *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
N *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
N */
N#define _WIZCHIP_IO_BASE_              0x00000000  // 
N
N#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
X#if (0x0200 + 1) & _WIZCHIP_IO_MODE_BUS
S   #ifndef _WIZCHIP_IO_BASE_
S      #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
S   #endif
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   #define _WIZCHIP_SOCK_NUM_   8   ///< The count of independant socket of @b WIZCHIP
N#else
S   #define _WIZCHIP_SOCK_NUM_   4   ///< The count of independant socket of @b WIZCHIP
N#endif      
N
N
N/********************************************************
N* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
N*********************************************************/
N/**
N * @ingroup DATA_TYPE
N * @brief The set of callback functions for W5500:@ref WIZCHIP_IO_Functions W5200:@ref WIZCHIP_IO_Functions_W5200
N */
Ntypedef struct __WIZCHIP
N{
N   uint16_t  if_mode;               ///< host interface mode
N   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
N   /**
N    * The set of critical section callback func.
N    */
N   struct _CRIS
N   {
N      void (*_enter)  (void);       ///< crtical section enter 
N      void (*_exit) (void);         ///< critial section exit  
N   }CRIS;  
N   /**
N    *  The set of @ref\_WIZCHIP_ select control callback func.
N    */
N   struct _CS
N   {
N      void (*_select)  (void);      ///< @ref \_WIZCHIP_ selected
N      void (*_deselect)(void);      ///< @ref \_WIZCHIP_ deselected
N   }CS;  
N   /**
N    * The set of interface IO callback func.
N    */
N   union _IF
N   {	 
N      /**
N       * For BUS interface IO
N       */  
N      struct
N      {
N         uint8_t  (*_read_byte)  (uint32_t AddrSel);
N         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
N      }BUS;      
N      /**
N       * For SPI interface IO
N       */
N      struct
N      {
N         uint8_t (*_read_byte)   (void);
N         void    (*_write_byte)  (uint8_t wb);
N      }SPI;
N      // To be added
N      //
N   }IF;
N}_WIZCHIP;
N
Nextern _WIZCHIP  WIZCHIP;
N
N/**
N * @ingroup DATA_TYPE
N *  WIZCHIP control type enumration used in @ref ctlwizchip().
N */
Ntypedef enum
N{
N   CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
N   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
N   CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
N   CW_CLR_INTERRUPT,   ///< Clears interrupt
N   CW_SET_INTRMASK,    ///< Masks interrupt
N   CW_GET_INTRMASK,    ///< Get interrupt mask
N   CW_SET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_ID,          ///< Gets WIZCHIP name.
N
N#if _WIZCHIP_ ==  5500
X#if 5500 ==  5500
N   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
N   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
N   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
N   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
N   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
N#endif
N   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
N   CW_GET_PHYLINK      ///< Get PHY Link status
N}ctlwizchip_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Network control type enumration used in @ref ctlnetwork().
N */
Ntypedef enum
N{
N   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
N   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
N   CN_SET_NETMODE,  ///< Set network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_GET_NETMODE,  ///< Get network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_SET_TIMEOUT,  ///< Set network timeout as retry count and time.
N   CN_GET_TIMEOUT,  ///< Get network timeout as retry count and time.
N}ctlnetwork_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Interrupt kind when CW_SET_INTRRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK
N *  and CW_GET_INTRMASK is used in @ref ctlnetwork().
N *  It can be used with OR operation.
N */
Ntypedef enum
N{
N#if _WIZCHIP_ > 5200
X#if 5500 > 5200
N   IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
N#endif   
N
N   IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
N
N#if _WIZCHIP_ != 5200
X#if 5500 != 5200
N   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
N#endif   
N
N   IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
N
N   IK_SOCK_0            = (1 << 8),   ///< Socket 0 interrupt
N   IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
N   IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
N   IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
N#if _WIZCHIP_ > 5100   
X#if 5500 > 5100   
N   IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
N   IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
N   IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
N   IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
N#else
S   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
N#endif      
N}intr_kind;
N
N#define PHY_CONFBY_HW            0     ///< Configured PHY operation mode by HW pin
N#define PHY_CONFBY_SW            1     ///< Configured PHY operation mode by SW register   
N#define PHY_MODE_MANUAL          0     ///< Configured PHY operation mode with user setting.
N#define PHY_MODE_AUTONEGO        1     ///< Configured PHY operation mode with auto-negotiation
N#define PHY_SPEED_10             0     ///< Link Speed 10
N#define PHY_SPEED_100            1     ///< Link Speed 100
N#define PHY_DUPLEX_HALF          0     ///< Link Half-Duplex
N#define PHY_DUPLEX_FULL          1     ///< Link Full-Duplex
N#define PHY_LINK_OFF             0     ///< Link Off
N#define PHY_LINK_ON              1     ///< Link On
N#define PHY_POWER_NORM           0     ///< PHY power normal mode
N#define PHY_POWER_DOWN           1     ///< PHY power down mode 
N
N
N#if _WIZCHIP_ == 5500 
X#if 5500 == 5500 
N/**
N * @ingroup DATA_TYPE
N *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
N *  and it indicates the real PHY status configured by HW or SW in all WIZCHIP. \n
N *  Valid only in W5500.
N */
Ntypedef struct wiz_PhyConf_t
N{
N      uint8_t by;       ///< set by @ref PHY_CONFBY_HW or @ref PHY_CONFBY_SW
N      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL or @ref PHY_MODE_AUTONEGO
N      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
N      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
N      //uint8_t power;  ///< set by @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N      //uint8_t link;   ///< Valid only in CW_GET_PHYSTATUS. set by @ref PHY_LINK_ON or PHY_DUPLEX_OFF 
N   }wiz_PhyConf;
N#endif   
N
N/**
N * @ingroup DATA_TYPE
N *  It used in setting dhcp_mode of @ref wiz_NetInfo.
N */
Ntypedef enum
N{
N   NETINFO_STATIC = 1,    ///< Static IP configuration by manually.
N   NETINFO_DHCP           ///< Dynamic IP configruation from a DHCP sever
N}dhcp_mode;
N
N/**
N * @ingroup DATA_TYPE
N *  Network Information for WIZCHIP
N */
Ntypedef struct wiz_NetInfo_t
N{
N   uint8_t mac[6];  ///< Source Mac Address
N   uint8_t ip[4];   ///< Source IP Address
N   uint8_t sn[4];   ///< Subnet Mask 
N   uint8_t gw[4];   ///< Gateway IP Address
N   uint8_t dns[4];  ///< DNS server IP Address
N   dhcp_mode dhcp;  ///< 1 - Static, 2 - DHCP
N}wiz_NetInfo;
N
N/**
N * @ingroup DATA_TYPE
N *  Network mode
N */
Ntypedef enum
N{
N#if _WIZCHIP_ == 5500   
X#if 5500 == 5500   
N   NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
N#endif   
N   NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
N   NM_PINGBLOCK   = (1<<4),  ///< Block ping-request
N   NM_PPPOE       = (1<<3),  ///< PPPoE mode
N}netmode_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Used in CN_SET_TIMEOUT or CN_GET_TIMEOUT of @ref ctlwizchip() for timeout configruation.
N */
Ntypedef struct wiz_NetTimeout_t
N{
N   uint8_t  retry_cnt;     ///< retry count 
N   uint16_t time_100us;    ///< time unit 100us
N}wiz_NetTimeout;
N
N/**
N *@brief Registers call back function for critical section of I/O functions such as
N *\ref WIZCHIP_READ, @ref WIZCHIP_WRITE, @ref WIZCHIP_READ_BUF and @ref WIZCHIP_WRITE_BUF.
N *@param cris_en : callback function for critical section enter.
N *@param cris_ex : callback function for critical section exit.
N *@todo Describe @ref WIZCHIP_CRITICAL_ENTER and @ref WIZCHIP_CRITICAL_EXIT marco or register your functions.
N *@note If you do not describe or register, default functions(@ref wizchip_cris_enter & @ref wizchip_cris_exit) is called.
N */
Nvoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
N
N
N/**
N *@brief Registers call back function for WIZCHIP select & deselect.
N *@param cs_sel : callback function for WIZCHIP select
N *@param cs_desel : callback fucntion for WIZCHIP deselect
N *@todo Describe @ref wizchip_cs_select and @ref wizchip_cs_deselect function or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
N
N/**
N *@brief Registers call back function for bus interface.
N *@param bus_rb   : callback function to read byte data using system bus
N *@param bus_wb   : callback function to write byte data using system bus
N *@todo Describe @ref wizchip_bus_readbyte and @ref wizchip_bus_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
N
N/**
N *@brief Registers call back function for SPI interface.
N *@param spi_rb : callback function to read byte usig SPI 
N *@param spi_wb : callback function to write byte usig SPI 
N *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb));
N
N/**
N * @ingroup extra_functions
N * @brief Controls to the WIZCHIP.
N * @details Resets WIZCHIP & internal PHY, Configures PHY mode, Monitor PHY(Link,Speed,Half/Full/Auto),
N * controls interrupt & mask and so on.
N * @param cwtype : Decides to the control type
N * @param arg : arg type is dependent on cwtype.
N * @return  0 : Success \n
N *         -1 : Fail because of invalid \ref ctlwizchip_type or unsupported \ref ctlwizchip_type in WIZCHIP 
N */          
Nint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network.
N * @details Controls to network environment, mode, timeout and so on.
N * @param cntype : Input. Decides to the control type
N * @param arg : Inout. arg type is dependent on cntype.
N * @return -1 : Fail because of invalid \ref ctlnetwork_type or unsupported \ref ctlnetwork_type in WIZCHIP \n
N *          0 : Success      
N */          
Nint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
N
N
N/* 
N * The following functions are implemented for internal use. 
N * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
N */
N 
N/**
N * @ingroup extra_functions
N * @brief Reset WIZCHIP by softly.
N */ 
Nvoid   wizchip_sw_reset(void);
N
N/**
N * @ingroup extra_functions
N * @brief Initializes WIZCHIP with socket buffer size
N * @param txsize Socket tx buffer sizes. If null, initialized the default size 2KB.
N * @param rxsize Socket rx buffer sizes. If null, initialized the default size 2KB.
N * @return 0 : succcess \n
N *        -1 : fail. Invalid buffer size
N */
Nint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
N
N/** 
N * @ingroup extra_functions
N * @brief Clear Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_clrinterrupt(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt of WIZCHIP.
N * @return @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterrupt(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Mask or Unmask Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_setinterruptmask(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt mask of WIZCHIP.
N * @return : The operated OR vaule of @ref intr_kind. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterruptmask(void);
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
N   int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
N#endif
N
N#if _WIZCHIP_ == 5500
X#if 5500 == 5500
N   void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
N/**
N * @ingroup extra_functions
N * @brief Set the phy information for WIZCHIP without power mode
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_setphyconf(wiz_PhyConf* phyconf);  
N /**
N * @ingroup extra_functions
N * @brief Get phy configuration information.
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_getphyconf(wiz_PhyConf* phyconf); 
N /**
N * @ingroup extra_functions
N * @brief Get phy status.
N * @param phyconf : @ref wiz_PhyConf
N */ 
N   void   wizphy_getphystat(wiz_PhyConf* phyconf);
N /**
N * @ingroup extra_functions
N * @brief set the power mode of phy inside WIZCHIP. Refer to @ref PHYCFGR in W5500, @ref PHYSTATUS in W5200
N * @param pmode Settig value of power down mode.
N */   
N   int8_t wizphy_setphypmode(uint8_t pmode);    
N#endif
N
N/**
N* @ingroup extra_functions
N * @brief Set the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @param pnetinfo Value of network mode. Refer to @ref netmode_type.
N */
Nint8_t wizchip_setnetmode(netmode_type netmode);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @return Value of network mode. Refer to @ref netmode_type.
N */
Nnetmode_type wizchip_getnetmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_settimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_gettimeout(wiz_NetTimeout* nettime);
N
N#endif   // _WIZCHIP_CONF_H_
L 47 "..\..\Ethernet\W5500\w5500.h" 2
N
N#define _W5500_IO_BASE_              0x00000000
N
N#define _W5500_SPI_READ_			   (0x00 << 2) //< SPI interface Read operation in Control Phase
N#define _W5500_SPI_WRITE_			   (0x01 << 2) //< SPI interface Write operation in Control Phase
N
N#define WIZCHIP_CREG_BLOCK          0x00 	//< Common register block
N#define WIZCHIP_SREG_BLOCK(N)       (1+4*N) //< Socket N register block
N#define WIZCHIP_TXBUF_BLOCK(N)      (2+4*N) //< Socket N Tx buffer address block
N#define WIZCHIP_RXBUF_BLOCK(N)      (3+4*N) //< Socket N Rx buffer address block
N
N#define WIZCHIP_OFFSET_INC(ADDR, N)    (ADDR + (N<<8)) //< Increase offset address
N
N
N///////////////////////////////////////
N// Definition For Legacy Chip Driver //
N///////////////////////////////////////
N#define IINCHIP_READ(ADDR)                WIZCHIP_READ(ADDR)               ///< The defined for legacy chip driver
N#define IINCHIP_WRITE(ADDR,VAL)           WIZCHIP_WRITE(ADDR,VAL)          ///< The defined for legacy chip driver
N#define IINCHIP_READ_BUF(ADDR,BUF,LEN)    WIZCHIP_READ_BUF(ADDR,BUF,LEN)   ///< The defined for legacy chip driver
N#define IINCHIP_WRITE_BUF(ADDR,BUF,LEN)   WIZCHIP_WRITE(ADDR,BUF,LEN)      ///< The defined for legacy chip driver
N
N//////////////////////////////
N//--------------------------  defgroup ---------------------------------
N/**
N * @defgroup W5500 W5500
N *
N * @brief WHIZCHIP register defines and I/O functions of @b W5500.
N *
N * - @ref WIZCHIP_register : @ref Common_register_group and @ref Socket_register_group
N * - @ref WIZCHIP_IO_Functions : @ref Basic_IO_function, @ref Common_register_access_function and @ref Socket_register_access_function
N */
N 
N 
N/**
N * @defgroup WIZCHIP_register WIZCHIP register
N * @ingroup W5500
N *
N * @brief WHIZCHIP register defines register group of @b W5500.
N *
N * - @ref Common_register_group : Common register group
N * - @ref Socket_register_group : \c SOCKET n register group
N */
N
N
N/**
N * @defgroup WIZCHIP_IO_Functions WIZCHIP I/O functions
N * @ingroup W5500
N *
N * @brief This supports the basic I/O functions for @ref WIZCHIP_register.
N *
N * - <b> Basic I/O function </b> \n
N *   WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF() \n\n
N *
N * - @ref Common_register_group <b>access functions</b> \n
N * 	-# @b Mode \n
N *    getMR(), setMR()
N * 	-# @b Interrupt \n
N *    getIR(), setIR(), getIMR(), setIMR(), getSIR(), setSIR(), getSIMR(), setSIMR(), getINTLEVEL(), setINTLEVEL()
N * 	-# <b> Network Information </b> \n
N *    getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR()
N * 	-# @b Retransmission \n
N *    getRCR(), setRCR(), getRTR(), setRTR()
N * 	-# @b PPPoE \n
N *    getPTIMER(), setPTIMER(), getPMAGIC(), getPMAGIC(), getPSID(), setPSID(), getPHAR(), setPHAR(), getPMRU(), setPMRU()
N * 	-# <b> ICMP packet </b>\n
N *    getUIPR(), getUPORTR()
N * 	-# @b etc. \n
N *    getPHYCFGR(), setPHYCFGR(), getVERSIONR() \n\n
N *
N * - \ref Socket_register_group <b>access functions</b> \n
N *   -# <b> SOCKET control</b> \n
N *      getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IR()
N *   -# <b> SOCKET information</b> \n
N *      getSn_SR(), getSn_DHAR(), setSn_DHAR(), getSn_PORT(), setSn_PORT(), getSn_DIPR(), setSn_DIPR(), getSn_DPORT(), setSn_DPORT()
N *      getSn_MSSR(), setSn_MSSR()
N *   -# <b> SOCKET communication </b> \n
N *      getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE() \n
N *      getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
N *      getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
N *      getSn_TX_FSR(), getSn_RX_RSR(), getSn_KPALVTR(), setSn_KPALVTR()
N *   -# <b> IP header field </b> \n
N *      getSn_FRAG(), setSn_FRAG(),  getSn_TOS(), setSn_TOS() \n
N *      getSn_TTL(), setSn_TTL()
N */
N
N
N
N/**
N * @defgroup Common_register_group Common register
N * @ingroup WIZCHIP_register
N *
N * @brief Common register group\n
N * It set the basic for the networking\n
N * It set the configuration such as interrupt, network information, ICMP, etc.
N * @details
N * @sa MR : Mode register.
N * @sa GAR, SUBR, SHAR, SIPR
N * @sa INTLEVEL, IR, IMR, SIR, SIMR : Interrupt.
N * @sa RTR, RCR : Data retransmission.
N * @sa PTIMER, PMAGIC, PHAR, PSID, PMRU : PPPoE.
N * @sa UIPR, UPORTR : ICMP message.
N * @sa PHYCFGR, VERSIONR : etc.
N */
N 
N  
N 
N/**
N * @defgroup Socket_register_group Socket register
N * @ingroup WIZCHIP_register
N *
N * @brief Socket register group.\n
N * Socket register configures and control SOCKETn which is necessary to data communication.
N * @details
N * @sa Sn_MR, Sn_CR, Sn_IR, Sn_IMR : SOCKETn Control
N * @sa Sn_SR, Sn_PORT, Sn_DHAR, Sn_DIPR, Sn_DPORT : SOCKETn Information
N * @sa Sn_MSSR, Sn_TOS, Sn_TTL, Sn_KPALVTR, Sn_FRAG : Internet protocol.
N * @sa Sn_RXBUF_SIZE, Sn_TXBUF_SIZE, Sn_TX_FSR, Sn_TX_RD, Sn_TX_WR, Sn_RX_RSR, Sn_RX_RD, Sn_RX_WR : Data communication
N */
N 
N 
N 
N /**
N * @defgroup Basic_IO_function Basic I/O function
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are basic input/output functions to read values from register or write values to register.
N */
N
N/**
N * @defgroup Common_register_access_function Common register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>common registers</b>.
N */
N
N/**
N * @defgroup Socket_register_access_function Socket register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>socket registers</b>.
N */
N 
N//------------------------------- defgroup end --------------------------------------------
N//----------------------------- W5500 Common Registers IOMAP -----------------------------
N/**
N * @ingroup Common_register_group
N * @brief Mode Register address(R/W)\n
N * @ref MR is used for S/W reset, ping block mode, PPPoE mode and etc.
N * @details Each bit of @ref MR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>RST</td> <td>Reserved</td> <td>WOL</td> <td>PB</td> <td>PPPoE</td> <td>Reserved</td> <td>FARP</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref MR_RST		 	: Reset
N * - \ref MR_WOL       		: Wake on LAN
N * - \ref MR_PB         	: Ping block
N * - \ref MR_PPPOE      	: PPPoE mode
N * - \ref MR_FARP			: Force ARP mode
N */
N#define MR                 (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Gateway IP Register address(R/W)
N * @details @ref GAR configures the default gateway address.
N */
N#define GAR                (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Subnet mask Register address(R/W)
N * @details @ref SUBR configures the subnet mask address.
N */
N#define SUBR               (_W5500_IO_BASE_ + (0x0005 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source MAC Register address(R/W)
N * @details @ref SHAR configures the source hardware address.
N */
N#define SHAR               (_W5500_IO_BASE_ + (0x0009 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source IP Register address(R/W)
N * @details @ref SIPR configures the source IP address.
N */
N#define SIPR               (_W5500_IO_BASE_ + (0x000F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Set Interrupt low level timer register address(R/W)
N * @details @ref INTLEVEL configures the Interrupt Assert Time.
N */
N#define INTLEVEL           (_W5500_IO_BASE_ + (0x0013 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt Register(R/W)
N * @details @ref IR indicates the interrupt status. Each bit of @ref IR will be still until the bit will be written to by the host.
N * If @ref IR is not equal to x00 INTn PIN is asserted to low until it is x00\n\n
N * Each bit of @ref IR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>CONFLICT</td> <td>UNREACH</td> <td>PPPoE</td> <td>MP</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IR_CONFLICT : IP conflict
N * - \ref IR_UNREACH  : Destination unreachable
N * - \ref IR_PPPoE	  : PPPoE connection close
N * - \ref IR_MP		  : Magic packet
N */
N#define IR                 (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt mask register(R/W)
N * @details @ref IMR is used to mask interrupts. Each bit of @ref IMR corresponds to each bit of @ref IR.
N * When a bit of @ref IMR is and the corresponding bit of @ref IR is  an interrupt will be issued. In other words,
N * if a bit of @ref IMR is  an interrupt will not be issued even if the corresponding bit of @ref IR is \n\n
N * Each bit of @ref IMR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>IM_IR7</td> <td>IM_IR6</td> <td>IM_IR5</td> <td>IM_IR4</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IM_IR7 : IP Conflict Interrupt Mask
N * - \ref IM_IR6 : Destination unreachable Interrupt Mask
N * - \ref IM_IR5 : PPPoE Close Interrupt Mask
N * - \ref IM_IR4 : Magic Packet Interrupt Mask
N */
N#define IMR                (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Register(R/W)
N * @details @ref SIR indicates the interrupt status of Socket.\n
N * Each bit of @ref SIR be still until @ref Sn_IR is cleared by the host.\n
N * If @ref Sn_IR is not equal to x00 the n-th bit of @ref SIR is and INTn PIN is asserted until @ref SIR is x00 */
N#define SIR                (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Mask Register(R/W)
N * @details Each bit of @ref SIMR corresponds to each bit of @ref SIR.
N * When a bit of @ref SIMR is and the corresponding bit of @ref SIR is  Interrupt will be issued.
N * In other words, if a bit of @ref SIMR is  an interrupt will be not issued even if the corresponding bit of @ref SIR is 
N */
N#define SIMR               (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Timeout register address( 1 is 100us )(R/W)
N * @details @ref RTR configures the retransmission timeout period. The unit of timeout period is 100us and the default of @ref RTR is x07D0or 000
N * And so the default timeout period is 200ms(100us X 2000). During the time configured by @ref RTR, W5500 waits for the peer response
N * to the packet that is transmitted by \ref Sn_CR (CONNECT, DISCON, CLOSE, SEND, SEND_MAC, SEND_KEEP command).
N * If the peer does not respond within the @ref RTR time, W5500 retransmits the packet or issues timeout.
N */
N#define RTR                (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Retry count register(R/W)
N * @details @ref RCR configures the number of time of retransmission.
N * When retransmission occurs as many as ref RCR+1 Timeout interrupt is issued (@ref Sn_IR[TIMEOUT] = .
N */
N#define RCR                (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Request Timer register  in PPPoE mode(R/W)
N * @details @ref PTIMER configures the time for sending LCP echo request. The unit of time is 25ms.
N */
N#define PTIMER             (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Magic number register  in PPPoE mode(R/W)
N * @details @ref PMAGIC configures the 4bytes magic number to be used in LCP negotiation.
N */
N#define PMAGIC             (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Destination MAC Register address(R/W)
N * @details @ref PHAR configures the PPPoE server hardware address that is acquired during PPPoE connection process.
N */
N#define PHAR                (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Session Identification Register(R/W)
N * @details @ref PSID configures the PPPoE sever session ID acquired during PPPoE connection process.
N */
N#define PSID               (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Maximum Segment Size(MSS) register(R/W)
N * @details @ref PMRU configures the maximum receive unit of PPPoE.
N */
N#define PMRU               (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable IP register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR indicates
N * the destination IP address & port number respectively.
N */
N#define UIPR               (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable Port register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR
N * indicates the destination IP address & port number respectively.
N */
N#define UPORTR              (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PHY Status Register(R/W)
N * @details @ref PHYCFGR configures PHY operation mode and resets PHY. In addition, @ref PHYCFGR indicates the status of PHY such as duplex, Speed, Link.
N */
N#define PHYCFGR            (_W5500_IO_BASE_ + (0x002E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0031 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0032 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0033 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0034 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0035 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0036 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0037 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0038 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief chip version register address(R)
N * @details @ref VERSIONR always indicates the W5500 version as @b 0x04.
N */
N#define VERSIONR           (_W5500_IO_BASE_ + (0x0039 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N
N//----------------------------- W5500 Socket Registers IOMAP -----------------------------
N/**
N * @ingroup Socket_register_group
N * @brief socket Mode register(R/W)
N * @details @ref Sn_MR configures the option or protocol type of Socket n.\n\n
N * Each bit of @ref Sn_MR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>MULTI/MFEN</td> <td>BCASTB</td> <td>ND/MC/MMB</td> <td>UCASTB/MIP6B</td> <td>Protocol[3]</td> <td>Protocol[2]</td> <td>Protocol[1]</td> <td>Protocol[0]</td> </tr>
N * </table>
N * - @ref Sn_MR_MULTI	: Support UDP Multicasting
N * - @ref Sn_MR_BCASTB	: Broadcast block <b>in UDP Multicasting</b>
N * - @ref Sn_MR_ND		: No Delayed Ack(TCP) flag
N * - @ref Sn_MR_MC   	: IGMP version used <b>in UDP mulitcasting</b>
N * - @ref Sn_MR_MMB    	: Multicast Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - @ref Sn_MR_UCASTB	: Unicast Block <b>in UDP Multicating</b>
N * - @ref Sn_MR_MIP6B   : IPv6 packet Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - <b>Protocol</b>
N * <table>
N * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>Closed</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>TCP</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>UDP</td>   </tr>
N * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
N * </table>
N *	- @ref Sn_MR_MACRAW	: MAC LAYER RAW SOCK \n
N *  - @ref Sn_MR_UDP		: UDP
N *  - @ref Sn_MR_TCP		: TCP
N *  - @ref Sn_MR_CLOSE	: Unused socket
N *  @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR(N)           (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket command register(R/W)
N * @details This is used to set the command for Socket n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
N * After W5500 accepts the command, the @ref Sn_CR register is automatically cleared to 0x00.
N * Even though @ref Sn_CR is cleared to 0x00, the command is still being processed.\n
N * To check whether the command is completed or not, please check the @ref Sn_IR or @ref Sn_SR.
N * - @ref Sn_CR_OPEN 		: Initialize or open socket.
N * - @ref Sn_CR_LISTEN 		: Wait connection request in TCP mode(<b>Server mode</b>)
N * - @ref Sn_CR_CONNECT 	: Send connection request in TCP mode(<b>Client mode</b>)
N * - @ref Sn_CR_DISCON 		: Send closing request in TCP mode.
N * - @ref Sn_CR_CLOSE   	: Close socket.
N * - @ref Sn_CR_SEND    	: Update TX buffer pointer and send data.
N * - @ref Sn_CR_SEND_MAC	: Send data with MAC address, so without ARP process.
N * - @ref Sn_CR_SEND_KEEP 	: Send keep alive message.
N * - @ref Sn_CR_RECV		: Update RX buffer pointer and receive data.
N */
N#define Sn_CR(N)           (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket interrupt register(R)
N * @details @ref Sn_IR indicates the status of Socket Interrupt such as establishment, termination, receiving data, timeout).\n
N * When an interrupt occurs and the corresponding bit of @ref Sn_IMR is  the corresponding bit of @ref Sn_IR becomes \n
N * In order to clear the @ref Sn_IR bit, the host should write the bit to \n
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>SEND_OK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
N * </table>
N * - \ref Sn_IR_SENDOK : <b>SEND_OK Interrupt</b>
N * - \ref Sn_IR_TIMEOUT : <b>TIMEOUT Interrupt</b>
N * - \ref Sn_IR_RECV : <b>RECV Interrupt</b>
N * - \ref Sn_IR_DISCON : <b>DISCON Interrupt</b>
N * - \ref Sn_IR_CON : <b>CON Interrupt</b>
N */
N#define Sn_IR(N)           (_W5500_IO_BASE_ + (0x0002 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket status register(R)
N * @details @ref Sn_SR indicates the status of Socket n.\n
N * The status of Socket n is changed by @ref Sn_CR or some special control packet as SYN, FIN packet in TCP.
N * @par Normal status
N * - @ref SOCK_CLOSED 		: Closed
N * - @ref SOCK_INIT   		: Initiate state
N * - @ref SOCK_LISTEN    	: Listen state
N * - @ref SOCK_ESTABLISHED 	: Success to connect
N * - @ref SOCK_CLOSE_WAIT   : Closing state
N * - @ref SOCK_UDP   		: UDP socket
N * - @ref SOCK_MACRAW  		: MAC raw mode socket
N *@par Temporary status during changing the status of Socket n.
N * - @ref SOCK_SYNSENT   	: This indicates Socket n sent the connect-request packet (SYN packet) to a peer.
N * - @ref SOCK_SYNRECV    	: It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.
N * - @ref SOCK_FIN_WAIT		: Connection state
N * - @ref SOCK_CLOSING		: Closing state
N * - @ref SOCK_TIME_WAIT	: Closing state
N * - @ref SOCK_LAST_ACK 	: Closing state
N */
N#define Sn_SR(N)           (_W5500_IO_BASE_ + (0x0003 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief source port register(R/W)
N * @details @ref Sn_PORT configures the source port number of Socket n.
N * It is valid when Socket n is used in TCP/UPD mode. It should be set before OPEN command is ordered.
N */
N#define Sn_PORT(N)         (_W5500_IO_BASE_ + (0x0004 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer MAC register address(R/W)
N * @details @ref Sn_DHAR configures the destination hardware address of Socket n when using SEND_MAC command in UDP mode or
N * it indicates that it is acquired in ARP-process by CONNECT/SEND command.
N */
N#define Sn_DHAR(N)         (_W5500_IO_BASE_ + (0x0006 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer IP register address(R/W)
N * @details @ref Sn_DIPR configures or indicates the destination IP address of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In TCP client mode, it configures an IP address of �TCP serverbefore CONNECT command.
N * In TCP server mode, it indicates an IP address of �TCP clientafter successfully establishing connection.
N * In UDP mode, it configures an IP address of peer to be received the UDP packet by SEND or SEND_MAC command.
N */
N#define Sn_DIPR(N)         (_W5500_IO_BASE_ + (0x000C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer port register address(R/W)
N * @details @ref Sn_DPORT configures or indicates the destination port number of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In �TCP clientmode, it configures the listen port number of �TCP serverbefore CONNECT command.
N * In �TCP Servermode, it indicates the port number of TCP client after successfully establishing connection.
N * In UDP mode, it configures the port number of peer to be transmitted the UDP packet by SEND/SEND_MAC command.
N */
N#define Sn_DPORT(N)        (_W5500_IO_BASE_ + (0x0010 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Maximum Segment Size(Sn_MSSR0) register address(R/W)
N * @details @ref Sn_MSSR configures or indicates the MTU(Maximum Transfer Unit) of Socket n.
N */
N#define Sn_MSSR(N)         (_W5500_IO_BASE_ + (0x0012 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x0014 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief IP Type of Service(TOS) Register(R/W)
N * @details @ref Sn_TOS configures the TOS(Type Of Service field in IP Header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TOS(N)          (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N/**
N * @ingroup Socket_register_group
N * @brief IP Time to live(TTL) Register(R/W)
N * @details @ref Sn_TTL configures the TTL(Time To Live field in IP header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TTL(N)          (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3)) 
N// Reserved			         (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Receive memory size register(R/W)
N * @details @ref Sn_RXBUF_SIZE configures the RX buffer block size of Socket n.
N * Socket n RX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data cannot be normally received from a peer.
N * Although Socket n RX Buffer Block size is initially configured to 2Kbytes,
N * user can re-configure its size using @ref Sn_RXBUF_SIZE. The total sum of @ref Sn_RXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data reception error is occurred.
N */
N#define Sn_RXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory size register(R/W)
N * @details @ref Sn_TXBUF_SIZE configures the TX buffer block size of Socket n. Socket n TX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data can�t be normally transmitted to a peer.
N * Although Socket n TX Buffer Block size is initially configured to 2Kbytes,
N * user can be re-configure its size using @ref Sn_TXBUF_SIZE. The total sum of @ref Sn_TXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data transmission error is occurred.
N */
N#define Sn_TXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit free memory size register(R)
N * @details @ref Sn_TX_FSR indicates the free size of Socket n TX Buffer Block. It is initialized to the configured size by @ref Sn_TXBUF_SIZE.
N * Data bigger than @ref Sn_TX_FSR should not be saved in the Socket n TX Buffer because the bigger data overwrites the previous saved data not yet sent.
N * Therefore, check before saving the data to the Socket n TX Buffer, and if data is equal or smaller than its checked size,
N * transmit the data with SEND/SEND_MAC command after saving the data in Socket n TX buffer. But, if data is bigger than its checked size,
N * transmit the data after dividing into the checked size and saving in the Socket n TX buffer.
N */
N#define Sn_TX_FSR(N)       (_W5500_IO_BASE_ + (0x0020 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory read pointer register address(R)
N * @details @ref Sn_TX_RD is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.
N * After its initialization, it is auto-increased by SEND command.
N * SEND command transmits the saved data from the current @ref Sn_TX_RD to the @ref Sn_TX_WR in the Socket n TX Buffer.
N * After transmitting the saved data, the SEND command increases the @ref Sn_TX_RD as same as the @ref Sn_TX_WR.
N * If its increment value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_TX_RD(N)        (_W5500_IO_BASE_ + (0x0022 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory write pointer register address(R/W)
N * @details @ref Sn_TX_WR is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.\n
N * It should be read or be updated like as follows.\n
N * 1. Read the starting address for saving the transmitting data.\n
N * 2. Save the transmitting data from the starting address of Socket n TX buffer.\n
N * 3. After saving the transmitting data, update @ref Sn_TX_WR to the increased value as many as transmitting data size.
N * If the increment value exceeds the maximum value 0xFFFF(greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.\n
N * 4. Transmit the saved data in Socket n TX Buffer by using SEND/SEND command
N */
N#define Sn_TX_WR(N)        (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Received data size register(R)
N * @details @ref Sn_RX_RSR indicates the data size received and saved in Socket n RX Buffer.
N * @ref Sn_RX_RSR does not exceed the @ref Sn_RXBUF_SIZE and is calculated as the difference between
N * �Socket n RX Write Pointer (@ref Sn_RX_WR)and �Socket n RX Read Pointer (@ref Sn_RX_RD)
N */
N#define Sn_RX_RSR(N)       (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Read point of Receive memory(R/W)
N * @details @ref Sn_RX_RD is initialized by OPEN command. Make sure to be read or updated as follows.\n
N * 1. Read the starting save address of the received data.\n
N * 2. Read data from the starting address of Socket n RX Buffer.\n
N * 3. After reading the received data, Update @ref Sn_RX_RD to the increased value as many as the reading size.
N * If the increment value exceeds the maximum value 0xFFFF, that is, is greater than 0x10000 and the carry bit occurs,
N * update with the lower 16bits value ignored the carry bit.\n
N * 4. Order RECV command is for notifying the updated @ref Sn_RX_RD to W5500.
N */
N#define Sn_RX_RD(N)        (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Write point of Receive memory(R)
N * @details @ref Sn_RX_WR is initialized by OPEN command and it is auto-increased by the data reception.
N * If the increased value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_RX_WR(N)        (_W5500_IO_BASE_ + (0x002A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief socket interrupt mask register(R)
N * @details @ref Sn_IMR masks the interrupt of Socket n.
N * Each bit corresponds to each bit of @ref Sn_IR. When a Socket n Interrupt is occurred and the corresponding bit of @ref Sn_IMR is 
N * the corresponding bit of @ref Sn_IR becomes  When both the corresponding bit of @ref Sn_IMR and @ref Sn_IR are and the n-th bit of @ref IR is 
N * Host is interrupted by asserted INTn PIN to low.
N */
N#define Sn_IMR(N)          (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Fragment field value in IP header register(R/W)
N * @details @ref Sn_FRAG configures the FRAG(Fragment field in IP header).
N */
N#define Sn_FRAG(N)         (_W5500_IO_BASE_ + (0x002D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Keep Alive Timer register(R/W)
N * @details @ref Sn_KPALVTR configures the transmitting timer of �KEEP ALIVE(KA)packet of SOCKETn. It is valid only in TCP mode,
N * and ignored in other modes. The time unit is 5s.
N * KA packet is transmittable after @ref Sn_SR is changed to SOCK_ESTABLISHED and after the data is transmitted or received to/from a peer at least once.
N * In case of '@ref Sn_KPALVTR > 0', W5500 automatically transmits KA packet after time-period for checking the TCP connection (Auto-keepalive-process).
N * In case of '@ref Sn_KPALVTR = 0', Auto-keep-alive-process will not operate,
N * and KA packet can be transmitted by SEND_KEEP command by the host (Manual-keep-alive-process).
N * Manual-keep-alive-process is ignored in case of '@ref Sn_KPALVTR > 0'.
N */
N#define Sn_KPALVTR(N)      (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N//#define Sn_TSR(N)          (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N
N//----------------------------- W5500 Register values  -----------------------------
N
N/* MODE register values */
N/**
N * @brief Reset
N * @details If this bit is  All internal registers will be initialized. It will be automatically cleared as after S/W reset.
N */
N#define MR_RST                       0x80
N
N/**
N * @brief Wake on LAN
N * @details 0 : Disable WOL mode\n
N * 1 : Enable WOL mode\n
N * If WOL mode is enabled and the received magic packet over UDP has been normally processed, the Interrupt PIN (INTn) asserts to low.
N * When using WOL mode, the UDP Socket should be opened with any source port number. (Refer to Socket n Mode Register (@ref Sn_MR) for opening Socket.)
N * @note The magic packet over UDP supported by W5500 consists of 6 bytes synchronization stream (xFFFFFFFFFFFF and
N * 16 times Target MAC address stream in UDP payload. The options such like password are ignored. You can use any UDP source port number for WOL mode.
N */
N#define MR_WOL                       0x20
N
N/**
N * @brief Ping block
N * @details 0 : Disable Ping block\n
N * 1 : Enable Ping block\n
N * If the bit is  it blocks the response to a ping request.
N */
N#define MR_PB                        0x10
N
N/**
N * @brief Enable PPPoE
N * @details 0 : DisablePPPoE mode\n
N * 1 : EnablePPPoE mode\n
N * If you use ADSL, this bit should be 
N */
N#define MR_PPPOE                     0x08
N
N/**
N * @brief Enable UDP_FORCE_ARP CHECHK
N * @details 0 : Disable Force ARP mode\n
N * 1 : Enable Force ARP mode\n
N * In Force ARP mode, It forces on sending ARP Request whenever data is sent.
N */
N#define MR_FARP                      0x02
N
N/* IR register values */
N/**
N * @brief Check IP conflict.
N * @details Bit is set as when own source IP address is same with the sender IP address in the received ARP request.
N */
N#define IR_CONFLICT                  0x80
N
N/**
N * @brief Get the destination unreachable message in UDP sending.
N * @details When receiving the ICMP (Destination port unreachable) packet, this bit is set as 
N * When this bit is  Destination Information such as IP address and Port number may be checked with the corresponding @ref UIPR & @ref UPORTR.
N */
N#define IR_UNREACH                   0x40
N
N/**
N * @brief Get the PPPoE close message.
N * @details When PPPoE is disconnected during PPPoE mode, this bit is set.
N */
N#define IR_PPPoE                     0x20
N
N/**
N * @brief Get the magic packet interrupt.
N * @details When WOL mode is enabled and receives the magic packet over UDP, this bit is set.
N */
N#define IR_MP                        0x10
N
N
N/* PHYCFGR register value */
N#define PHYCFGR_RST                  ~(1<<7)  //< For PHY reset, must operate AND mask.
N#define PHYCFGR_OPMD                 (1<<6)   // Configre PHY with OPMDC value
N#define PHYCFGR_OPMDC_ALLA           (7<<3)
N#define PHYCFGR_OPMDC_PDOWN          (6<<3)
N#define PHYCFGR_OPMDC_NA             (5<<3)
N#define PHYCFGR_OPMDC_100FA          (4<<3)
N#define PHYCFGR_OPMDC_100F           (3<<3)
N#define PHYCFGR_OPMDC_100H           (2<<3)
N#define PHYCFGR_OPMDC_10F            (1<<3)
N#define PHYCFGR_OPMDC_10H            (0<<3)           
N#define PHYCFGR_DPX_FULL             (1<<2)
N#define PHYCFGR_DPX_HALF             (0<<2)
N#define PHYCFGR_SPD_100              (1<<1)
N#define PHYCFGR_SPD_10               (0<<1)
N#define PHYCFGR_LNK_ON               (1<<0)
N#define PHYCFGR_LNK_OFF              (0<<0)
N
N/* IMR register values */
N/**
N * @brief IP Conflict Interrupt Mask.
N * @details 0: Disable IP Conflict Interrupt\n
N * 1: Enable IP Conflict Interrupt
N */
N#define IM_IR7                  	 0x80
N
N/**
N * @brief Destination unreachable Interrupt Mask.
N * @details 0: Disable Destination unreachable Interrupt\n
N * 1: Enable Destination unreachable Interrupt
N */
N#define IM_IR6                  	 0x40
N
N/**
N * @brief PPPoE Close Interrupt Mask.
N * @details 0: Disable PPPoE Close Interrupt\n
N * 1: Enable PPPoE Close Interrupt
N */
N#define IM_IR5                  	 0x20
N
N/**
N * @brief Magic Packet Interrupt Mask.
N * @details 0: Disable Magic Packet Interrupt\n
N * 1: Enable Magic Packet Interrupt
N */
N#define IM_IR4                  	 0x10
N
N/* Sn_MR Default values */
N/**
N * @brief Support UDP Multicasting
N * @details 0 : disable Multicasting\n
N * 1 : enable Multicasting\n
N * This bit is applied only during UDP mode(P[3:0] = 010.\n
N * To use multicasting, @ref Sn_DIPR & @ref Sn_DPORT should be respectively configured with the multicast group IP address & port number
N * before Socket n is opened by OPEN command of @ref Sn_CR.
N */
N#define Sn_MR_MULTI                  0x80
N
N/**
N * @brief Broadcast block in UDP Multicasting.
N * @details 0 : disable Broadcast Blocking\n
N * 1 : enable Broadcast Blocking\n
N * This bit blocks to receive broadcasting packet during UDP mode(P[3:0] = 010.\m
N * In addition, This bit does when MACRAW mode(P[3:0] = 100
N */
N#define Sn_MR_BCASTB                 0x40
N
N/**
N * @brief No Delayed Ack(TCP), Multicast flag
N * @details 0 : Disable No Delayed ACK option\n
N * 1 : Enable No Delayed ACK option\n
N * This bit is applied only during TCP mode (P[3:0] = 001.\n
N * When this bit is  It sends the ACK packet without delay as soon as a Data packet is received from a peer.\n
N * When this bit is  It sends the ACK packet after waiting for the timeout time configured by @ref RTR.
N */
N#define Sn_MR_ND                     0x20
N
N/**
N * @brief Unicast Block in UDP Multicasting
N * @details 0 : disable Unicast Blocking\n
N * 1 : enable Unicast Blocking\n
N * This bit blocks receiving the unicast packet during UDP mode(P[3:0] = 010 and MULTI = 
N */
N#define Sn_MR_UCASTB                 0x10
N
N/**
N * @brief MAC LAYER RAW SOCK
N * @details This configures the protocol mode of Socket n.
N * @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR_MACRAW                 0x04
N
N//#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
N
N/**
N * @brief UDP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_UDP                    0x02
N
N/**
N * @brief TCP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_TCP                    0x01
N
N/**
N * @brief Unused socket
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_CLOSE                  0x00
N
N/* Sn_MR values used with Sn_MR_MACRAW */
N/**
N * @brief MAC filter enable in @ref Sn_MR_MACRAW mode
N * @details 0 : disable MAC Filtering\n
N * 1 : enable MAC Filtering\n
N * This bit is applied only during MACRAW mode(P[3:0] = 100.\n
N * When set as  W5500 can only receive broadcasting packet or packet sent to itself.
N * When this bit is  W5500 can receive all packets on Ethernet.
N * If user wants to implement Hybrid TCP/IP stack,
N * it is recommended that this bit is set as for reducing host overhead to process the all received packets.
N */
N#define Sn_MR_MFEN                   Sn_MR_MULTI
N
N/**
N * @brief Multicast Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : using IGMP version 2\n
N * 1 : using IGMP version 1\n
N * This bit is applied only during UDP mode(P[3:0] = 010 and MULTI = 
N * It configures the version for IGMP messages (Join/Leave/Report).
N */
N#define Sn_MR_MMB                    Sn_MR_ND
N
N/**
N * @brief IPv6 packet Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : disable IPv6 Blocking\n
N * 1 : enable IPv6 Blocking\n
N * This bit is applied only during MACRAW mode (P[3:0] = 100. It blocks to receiving the IPv6 packet.
N */
N#define Sn_MR_MIP6B                  Sn_MR_UCASTB
N
N/* Sn_MR value used with Sn_MR_UDP & Sn_MR_MULTI */
N/**
N * @brief IGMP version used in UDP mulitcasting
N * @details 0 : disable Multicast Blocking\n
N * 1 : enable Multicast Blocking\n
N * This bit is applied only when MACRAW mode(P[3:0] = 100. It blocks to receive the packet with multicast MAC address.
N */
N#define Sn_MR_MC                     Sn_MR_ND
N
N/* Sn_MR alternate values */
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_STREAM                  Sn_MR_TCP
N
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_DGRAM                   Sn_MR_UDP
N
N
N/* Sn_CR values */
N/**
N * @brief Initialize or open socket
N * @details Socket n is initialized and opened according to the protocol selected in Sn_MR(P3:P0).
N * The table below shows the value of @ref Sn_SR corresponding to @ref Sn_MR.\n
N * <table>
N *   <tr>  <td>\b Sn_MR (P[3:0])</td> <td>\b Sn_SR</td>            		 </tr>
N *   <tr>  <td>Sn_MR_CLOSE  (000</td> <td></td>         	   		 </tr>
N *   <tr>  <td>Sn_MR_TCP  (001</td> <td>SOCK_INIT (0x13)</td>  		 </tr>
N *   <tr>  <td>Sn_MR_UDP  (010</td>  <td>SOCK_UDP (0x22)</td>  		 </tr>
N *   <tr>  <td>S0_MR_MACRAW  (100</td>  <td>SOCK_MACRAW (0x02)</td>  </tr>
N * </table>
N */
N#define Sn_CR_OPEN                   0x01
N
N/**
N * @brief Wait connection request in TCP mode(Server mode)
N * @details This is valid only in TCP mode (Sn_MR(P3:P0) = Sn_MR_TCP).
N * In this mode, Socket n operates as a �TCP serverand waits for  connection-request (SYN packet) from any �TCP client
N * The @ref Sn_SR changes the state from SOCK_INIT to SOCKET_LISTEN.
N * When a �TCP clientconnection request is successfully established,
N * the @ref Sn_SR changes from SOCK_LISTEN to SOCK_ESTABLISHED and the Sn_IR(0) becomes 
N * But when a �TCP clientconnection request is failed, Sn_IR(3) becomes and the status of @ref Sn_SR changes to SOCK_CLOSED.
N */
N#define Sn_CR_LISTEN                 0x02
N
N/**
N * @brief Send connection request in TCP mode(Client mode)
N * @details  To connect, a connect-request (SYN packet) is sent to b>TCP server</b>configured by @ref Sn_DIPR & Sn_DPORT(destination address & port).
N * If the connect-request is successful, the @ref Sn_SR is changed to @ref SOCK_ESTABLISHED and the Sn_IR(0) becomes \n\n
N * The connect-request fails in the following three cases.\n
N * 1. When a @b ARPTO occurs (@ref Sn_IR[3] =  ) because destination hardware address is not acquired through the ARP-process.\n
N * 2. When a @b SYN/ACK packet is not received and @b TCPTO (Sn_IR(3) =  )\n
N * 3. When a @b RST packet is received instead of a @b SYN/ACK packet. In these cases, @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note This is valid only in TCP mode and operates when Socket n acts as b>TCP client</b>
N */
N#define Sn_CR_CONNECT                0x04
N
N/**
N * @brief Send closing request in TCP mode
N * @details Regardless of b>TCP server</b>or b>TCP client</b> the DISCON command processes the disconnect-process (b>Active close</b>or b>Passive close</b>.\n
N * @par Active close
N * it transmits disconnect-request(FIN packet) to the connected peer\n
N * @par Passive close
N * When FIN packet is received from peer, a FIN packet is replied back to the peer.\n
N * @details When the disconnect-process is successful (that is, FIN/ACK packet is received successfully), @ref Sn_SR is changed to @ref SOCK_CLOSED.\n
N * Otherwise, TCPTO occurs (Sn_IR(3)=)= and then @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_DISCON                 0x08
N
N/**
N * @brief Close socket
N * @details Sn_SR is changed to @ref SOCK_CLOSED.
N */
N#define Sn_CR_CLOSE                  0x10
N
N/**
N * @brief Update TX buffer pointer and send data
N * @details SEND transmits all the data in the Socket n TX buffer.\n
N * For more details, please refer to Socket n TX Free Size Register (@ref Sn_TX_FSR), Socket n,
N * TX Write Pointer Register(@ref Sn_TX_WR), and Socket n TX Read Pointer Register(@ref Sn_TX_RD).
N */
N#define Sn_CR_SEND                   0x20
N
N/**
N * @brief Send data with MAC address, so without ARP process
N * @details The basic operation is same as SEND.\n
N * Normally SEND transmits data after destination hardware address is acquired by the automatic ARP-process(Address Resolution Protocol).\n
N * But SEND_MAC transmits data without the automatic ARP-process.\n
N * In this case, the destination hardware address is acquired from @ref Sn_DHAR configured by host, instead of APR-process.
N * @note Valid only in UDP mode.
N */
N#define Sn_CR_SEND_MAC               0x21
N
N/**
N * @brief Send keep alive message
N * @details It checks the connection status by sending 1byte keep-alive packet.\n
N * If the peer can not respond to the keep-alive packet during timeout time, the connection is terminated and the timeout interrupt will occur.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_SEND_KEEP              0x22
N
N/**
N * @brief Update RX buffer pointer and receive data
N * @details RECV completes the processing of the received data in Socket n RX Buffer by using a RX read pointer register (@ref Sn_RX_RD).\n
N * For more details, refer to Socket n RX Received Size Register (@ref Sn_RX_RSR), Socket n RX Write Pointer Register (@ref Sn_RX_WR),
N * and Socket n RX Read Pointer Register (@ref Sn_RX_RD).
N */
N#define Sn_CR_RECV                   0x40
N
N/* Sn_IR values */
N/**
N * @brief SEND_OK Interrupt
N * @details This is issued when SEND command is completed.
N */
N#define Sn_IR_SENDOK                 0x10
N
N/**
N * @brief TIMEOUT Interrupt
N * @details This is issued when ARPTO or TCPTO occurs.
N */
N#define Sn_IR_TIMEOUT                0x08
N
N/**
N * @brief RECV Interrupt
N * @details This is issued whenever data is received from a peer.
N */
N#define Sn_IR_RECV                   0x04
N
N/**
N * @brief DISCON Interrupt
N * @details This is issued when FIN or FIN/ACK packet is received from a peer.
N */
N#define Sn_IR_DISCON                 0x02
N
N/**
N * @brief CON Interrupt
N * @details This is issued one time when the connection with peer is successful and then @ref Sn_SR is changed to @ref SOCK_ESTABLISHED.
N */
N#define Sn_IR_CON                    0x01
N
N/* Sn_SR values */
N/**
N * @brief Closed
N * @details This indicates that Socket n is released.\N
N * When DICON, CLOSE command is ordered, or when a timeout occurs, it is changed to @ref SOCK_CLOSED regardless of previous status.
N */
N#define SOCK_CLOSED                  0x00
N
N/**
N * @brief Initiate state
N * @details This indicates Socket n is opened with TCP mode.\N
N * It is changed to @ref SOCK_INIT when Sn_MR(P[3:0]) = 001and OPEN command is ordered.\N
N * After @ref SOCK_INIT, user can use LISTEN /CONNECT command.
N */
N#define SOCK_INIT                    0x13
N
N/**
N * @brief Listen state
N * @details This indicates Socket n is operating as b>TCP server</b>mode and waiting for connection-request (SYN packet) from a peer (b>TCP client</b>.\n
N * It will change to @ref SOCK_ESTALBLISHED when the connection-request is successfully accepted.\n
N * Otherwise it will change to @ref SOCK_CLOSED after TCPTO occurred (Sn_IR(TIMEOUT) = .
N */
N#define SOCK_LISTEN                  0x14
N
N/**
N * @brief Connection state
N * @details This indicates Socket n sent the connect-request packet (SYN packet) to a peer.\n
N * It is temporarily shown when @ref Sn_SR is changed from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by CONNECT command.\n
N * If connect-accept(SYN/ACK packet) is received from the peer at SOCK_SYNSENT, it changes to @ref SOCK_ESTABLISHED.\n
N * Otherwise, it changes to @ref SOCK_CLOSED after TCPTO (@ref Sn_IR[TIMEOUT] =  is occurred.
N */
N#define SOCK_SYNSENT                 0x15
N
N/**
N * @brief Connection state
N * @details It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.\n
N * If socket n sends the response (SYN/ACK  packet) to the peer successfully,  it changes to @ref SOCK_ESTABLISHED. \n
N * If not, it changes to @ref SOCK_CLOSED after timeout occurs (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_SYNRECV                 0x16
N
N/**
N * @brief Success to connect
N * @details This indicates the status of the connection of Socket n.\n
N * It changes to @ref SOCK_ESTABLISHED when the b>TCP SERVER</b>processed the SYN packet from the b>TCP CLIENT</b>during @ref SOCK_LISTEN, or
N * when the CONNECT command is successful.\n
N * During @ref SOCK_ESTABLISHED, DATA packet can be transferred using SEND or RECV command.
N */
N#define SOCK_ESTABLISHED             0x17
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_FIN_WAIT                0x18
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_CLOSING                 0x1A
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_TIME_WAIT               0x1B
N
N/**
N * @brief Closing state
N * @details This indicates Socket n received the disconnect-request (FIN packet) from the connected peer.\n
N * This is half-closing status, and data can be transferred.\n
N * For full-closing, DISCON command is used. But For just-closing, CLOSE command is used.
N */
N#define SOCK_CLOSE_WAIT              0x1C
N
N/**
N * @brief Closing state
N * @details This indicates Socket n is waiting for the response (FIN/ACK packet) to the disconnect-request (FIN packet) by passive-close.\n
N * It changes to @ref SOCK_CLOSED when Socket n received the response successfully, or when timeout occurs  (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_LAST_ACK                0x1D
N
N/**
N * @brief UDP socket
N * @details This indicates Socket n is opened in UDP mode(Sn_MR(P[3:0]) = 010.\n
N * It changes to SOCK_UPD when Sn_MR(P[3:0]) = 010 and OPEN command is ordered.\n
N * Unlike TCP mode, data can be transfered without the connection-process.
N */
N#define SOCK_UDP                     0x22
N
N//#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
N
N/**
N * @brief MAC raw mode socket
N * @details This indicates Socket 0 is opened in MACRAW mode (S0_MR(P[3:0]) = 100and is valid only in Socket 0.\n
N * It changes to SOCK_MACRAW when S0_MR(P[3:0] = 100and OPEN command is ordered.\n
N * Like UDP mode socket, MACRAW mode Socket 0 can transfer a MAC packet (Ethernet frame) without the connection-process.
N */
N#define SOCK_MACRAW                  0x42
N
N//#define SOCK_PPPOE                   0x5F
N
N/* IP PROTOCOL */
N#define IPPROTO_IP                   0        //< Dummy for IP 
N#define IPPROTO_ICMP                 1        //< Control message protocol
N#define IPPROTO_IGMP                 2        //< Internet group management protocol
N#define IPPROTO_GGP                  3        //< Gateway^2 (deprecated)
N#define IPPROTO_TCP                  6        //< TCP
N#define IPPROTO_PUP                  12       //< PUP
N#define IPPROTO_UDP                  17       //< UDP
N#define IPPROTO_IDP                  22       //< XNS idp
N#define IPPROTO_ND                   77       //< UNOFFICIAL net disk protocol
N#define IPPROTO_RAW                  255      //< Raw IP packet
N
N
N/**
N * @brief Enter a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n \n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt.\n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * \sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * \sa WIZCHIP_CRITICAL_EXIT()
N */
N#define WIZCHIP_CRITICAL_ENTER()    WIZCHIP.CRIS._enter()
N
N/**
N * @brief Exit a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n\n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt. \n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_ENTER()
N */
N#define WIZCHIP_CRITICAL_EXIT()     WIZCHIP.CRIS._exit()
N
N
N
N////////////////////////
N// Basic I/O Function //
N////////////////////////
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads 1 byte value from a register.
N * @param AddrSel Register address
N * @return The value of register
N */
Nuint8_t  WIZCHIP_READ (uint32_t AddrSel);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes 1 byte value to a register.
N * @param AddrSel Register address
N * @param wb Write data
N * @return void
N */
Nvoid     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads sequence data from registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to read data
N * @param len Data length
N */
Nvoid     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes sequence data to registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to write data
N * @param len Data length
N */
Nvoid     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/////////////////////////////////
N// Common Register I/O function //
N/////////////////////////////////
N/**
N * @ingroup Common_register_access_function
N * @brief Set Mode Register
N * @param (uint8_t)mr The value to be set.
N * @sa getMR()
N */
N#define setMR(mr) \
N	WIZCHIP_WRITE(MR,mr)
X#define setMR(mr) 	WIZCHIP_WRITE(MR,mr)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get Mode Register
N * @return uint8_t. The value of Mode register.
N * @sa setMR()
N */
N#define getMR() \
N		WIZCHIP_READ(MR)
X#define getMR() 		WIZCHIP_READ(MR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set gateway IP address
N * @param (uint8_t*)gar Pointer variable to set gateway IP address. It should be allocated 4 bytes.
N * @sa getGAR()
N */
N#define setGAR(gar) \
N		WIZCHIP_WRITE_BUF(GAR,gar,4)
X#define setGAR(gar) 		WIZCHIP_WRITE_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get gateway IP address
N * @param (uint8_t*)gar Pointer variable to get gateway IP address. It should be allocated 4 bytes.
N * @sa setGAR()
N */
N#define getGAR(gar) \
N		WIZCHIP_READ_BUF(GAR,gar,4)
X#define getGAR(gar) 		WIZCHIP_READ_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set subnet mask address
N * @param (uint8_t*)subr Pointer variable to set subnet mask address. It should be allocated 4 bytes.
N * @sa getSUBR()
N */
N#define setSUBR(subr) \
N		WIZCHIP_WRITE_BUF(SUBR, subr,4)
X#define setSUBR(subr) 		WIZCHIP_WRITE_BUF(SUBR, subr,4)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get subnet mask address
N * @param (uint8_t*)subr Pointer variable to get subnet mask address. It should be allocated 4 bytes.
N * @sa setSUBR()
N */
N#define getSUBR(subr) \
N		WIZCHIP_READ_BUF(SUBR, subr, 4)
X#define getSUBR(subr) 		WIZCHIP_READ_BUF(SUBR, subr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local MAC address
N * @param (uint8_t*)shar Pointer variable to set local MAC address. It should be allocated 6 bytes.
N * @sa getSHAR()
N */
N#define setSHAR(shar) \
N		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
X#define setSHAR(shar) 		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local MAC address
N * @param (uint8_t*)shar Pointer variable to get local MAC address. It should be allocated 6 bytes.
N * @sa setSHAR()
N */
N#define getSHAR(shar) \
N		WIZCHIP_READ_BUF(SHAR, shar, 6)
X#define getSHAR(shar) 		WIZCHIP_READ_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local IP address
N * @param (uint8_t*)sipr Pointer variable to set local IP address. It should be allocated 4 bytes.
N * @sa getSIPR()
N */
N#define setSIPR(sipr) \
N		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
X#define setSIPR(sipr) 		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)sipr Pointer variable to get local IP address. It should be allocated 4 bytes.
N * @sa setSIPR()
N */
N#define getSIPR(sipr) \
N		WIZCHIP_READ_BUF(SIPR, sipr, 4)
X#define getSIPR(sipr) 		WIZCHIP_READ_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set INTLEVEL register
N * @param (uint16_t)intlevel Value to set @ref INTLEVEL register.
N * @sa getINTLEVEL()
N */
N#define setINTLEVEL(intlevel)  {\
N		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); \
N	}
X#define setINTLEVEL(intlevel)  {		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); 	}
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get INTLEVEL register
N * @return uint16_t. Value of @ref INTLEVEL register.
N * @sa setINTLEVEL()
N */
N#define getINTLEVEL() \
N		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
X#define getINTLEVEL() 		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IR register
N * @param (uint8_t)ir Value to set @ref IR register.
N * @sa getIR()
N */
N#define setIR(ir) \
N		WIZCHIP_WRITE(IR, (ir & 0xF0))
X#define setIR(ir) 		WIZCHIP_WRITE(IR, (ir & 0xF0))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IR register
N * @return uint8_t. Value of @ref IR register.
N * @sa setIR()
N */
N#define getIR() \
N		(WIZCHIP_READ(IR) & 0xF0)
X#define getIR() 		(WIZCHIP_READ(IR) & 0xF0)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IMR register
N * @param (uint8_t)imr Value to set @ref IMR register.
N * @sa getIMR()
N */
N#define setIMR(imr) \
N		WIZCHIP_WRITE(IMR, imr)
X#define setIMR(imr) 		WIZCHIP_WRITE(IMR, imr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IMR register
N * @return uint8_t. Value of @ref IMR register.
N * @sa setIMR()
N */
N#define getIMR() \
N		WIZCHIP_READ(IMR)
X#define getIMR() 		WIZCHIP_READ(IMR)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIR register
N * @param (uint8_t)sir Value to set @ref SIR register.
N * @sa getSIR()
N */
N#define setSIR(sir) \
N		WIZCHIP_WRITE(SIR, sir)
X#define setSIR(sir) 		WIZCHIP_WRITE(SIR, sir)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIR register
N * @return uint8_t. Value of @ref SIR register.
N * @sa setSIR()
N */
N#define getSIR() \
N		WIZCHIP_READ(SIR)
X#define getSIR() 		WIZCHIP_READ(SIR)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIMR register
N * @param (uint8_t)simr Value to set @ref SIMR register.
N * @sa getSIMR()
N */
N#define setSIMR(simr) \
N		WIZCHIP_WRITE(SIMR, simr)
X#define setSIMR(simr) 		WIZCHIP_WRITE(SIMR, simr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIMR register
N * @return uint8_t. Value of @ref SIMR register.
N * @sa setSIMR()
N */
N#define getSIMR() \
N		WIZCHIP_READ(SIMR)
X#define getSIMR() 		WIZCHIP_READ(SIMR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RTR register
N * @param (uint16_t)rtr Value to set @ref RTR register.
N * @sa getRTR()
N */
N#define setRTR(rtr)   {\
N		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); \
N	}
X#define setRTR(rtr)   {		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RTR register
N * @return uint16_t. Value of @ref RTR register.
N * @sa setRTR()
N */
N#define getRTR() \
N		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
X#define getRTR() 		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RCR register
N * @param (uint8_t)rcr Value to set @ref RCR register.
N * @sa getRCR()
N */
N#define setRCR(rcr) \
N		WIZCHIP_WRITE(RCR, rcr)
X#define setRCR(rcr) 		WIZCHIP_WRITE(RCR, rcr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RCR register
N * @return uint8_t. Value of @ref RCR register.
N * @sa setRCR()
N */
N#define getRCR() \
N		WIZCHIP_READ(RCR)
X#define getRCR() 		WIZCHIP_READ(RCR)
N
N//================================================== test done ===========================================================
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PTIMER register
N * @param (uint8_t)ptimer Value to set @ref PTIMER register.
N * @sa getPTIMER()
N */
N#define setPTIMER(ptimer) \
N		WIZCHIP_WRITE(PTIMER, ptimer)
X#define setPTIMER(ptimer) 		WIZCHIP_WRITE(PTIMER, ptimer)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PTIMER register
N * @return uint8_t. Value of @ref PTIMER register.
N * @sa setPTIMER()
N */
N#define getPTIMER() \
N		WIZCHIP_READ(PTIMER)
X#define getPTIMER() 		WIZCHIP_READ(PTIMER)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMAGIC register
N * @param (uint8_t)pmagic Value to set @ref PMAGIC register.
N * @sa getPMAGIC()
N */
N#define setPMAGIC(pmagic) \
N		WIZCHIP_WRITE(PMAGIC, pmagic)
X#define setPMAGIC(pmagic) 		WIZCHIP_WRITE(PMAGIC, pmagic)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMAGIC register
N * @return uint8_t. Value of @ref PMAGIC register.
N * @sa setPMAGIC()
N */
N#define getPMAGIC() \
N		WIZCHIP_READ(PMAGIC)
X#define getPMAGIC() 		WIZCHIP_READ(PMAGIC)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set PHAR address
N * @param (uint8_t*)phar Pointer variable to set PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa getPHAR()
N */
N#define setPHAR(phar) \
N		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
X#define setPHAR(phar) 		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)phar Pointer variable to PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa setPHAR()
N */
N#define getPHAR(phar) \
N		WIZCHIP_READ_BUF(PHAR, phar, 6)
X#define getPHAR(phar) 		WIZCHIP_READ_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PSID register
N * @param (uint16_t)psid Value to set @ref PSID register.
N * @sa getPSID()
N */
N#define setPSID(psid)  {\
N		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); \
N	}
X#define setPSID(psid)  {		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PSID register
N * @return uint16_t. Value of @ref PSID register.
N * @sa setPSID()
N */
N//uint16_t getPSID(void);
N#define getPSID() \
N		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
X#define getPSID() 		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMRU register
N * @param (uint16_t)pmru Value to set @ref PMRU register.
N * @sa getPMRU()
N */
N#define setPMRU(pmru) { \
N		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); \
N	}
X#define setPMRU(pmru) { 		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMRU register
N * @return uint16_t. Value of @ref PMRU register.
N * @sa setPMRU()
N */
N#define getPMRU() \
N		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
X#define getPMRU() 		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get unreachable IP address
N * @param (uint8_t*)uipr Pointer variable to get unreachable IP address. It should be allocated 4 bytes.
N */
N#define getUIPR(uipr) \
N		WIZCHIP_READ_BUF(UIPR,uipr,6)
X#define getUIPR(uipr) 		WIZCHIP_READ_BUF(UIPR,uipr,6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref UPORTR register
N * @return uint16_t. Value of @ref UPORTR register.
N */
N#define getUPORTR() \
N	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
X#define getUPORTR() 	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PHYCFGR register
N * @param (uint8_t)phycfgr Value to set @ref PHYCFGR register.
N * @sa getPHYCFGR()
N */
N#define setPHYCFGR(phycfgr) \
N		WIZCHIP_WRITE(PHYCFGR, phycfgr)
X#define setPHYCFGR(phycfgr) 		WIZCHIP_WRITE(PHYCFGR, phycfgr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PHYCFGR register
N * @return uint8_t. Value of @ref PHYCFGR register.
N * @sa setPHYCFGR()
N */
N#define getPHYCFGR() \
N		WIZCHIP_READ(PHYCFGR)
X#define getPHYCFGR() 		WIZCHIP_READ(PHYCFGR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref VERSIONR register
N * @return uint8_t. Value of @ref VERSIONR register.
N */
N#define getVERSIONR() \
N		WIZCHIP_READ(VERSIONR)
X#define getVERSIONR() 		WIZCHIP_READ(VERSIONR)
N
N/////////////////////////////////////
N
N///////////////////////////////////
N// Socket N register I/O function //
N///////////////////////////////////
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)mr Value to set @ref Sn_MR
N * @sa getSn_MR()
N */
N#define setSn_MR(sn, mr) \
N		WIZCHIP_WRITE(Sn_MR(sn),mr)
X#define setSn_MR(sn, mr) 		WIZCHIP_WRITE(Sn_MR(sn),mr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_MR.
N * @sa setSn_MR()
N */
N#define getSn_MR(sn) \
N	WIZCHIP_READ(Sn_MR(sn))
X#define getSn_MR(sn) 	WIZCHIP_READ(Sn_MR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)cr Value to set @ref Sn_CR
N * @sa getSn_CR()
N */
N#define setSn_CR(sn, cr) \
N		WIZCHIP_WRITE(Sn_CR(sn), cr)
X#define setSn_CR(sn, cr) 		WIZCHIP_WRITE(Sn_CR(sn), cr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_CR.
N * @sa setSn_CR()
N */
N#define getSn_CR(sn) \
N		WIZCHIP_READ(Sn_CR(sn))
X#define getSn_CR(sn) 		WIZCHIP_READ(Sn_CR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ir Value to set @ref Sn_IR
N * @sa getSn_IR()
N */
N#define setSn_IR(sn, ir) \
N		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
X#define setSn_IR(sn, ir) 		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IR.
N * @sa setSn_IR()
N */
N#define getSn_IR(sn) \
N		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
X#define getSn_IR(sn) 		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)imr Value to set @ref Sn_IMR
N * @sa getSn_IMR()
N */
N#define setSn_IMR(sn, imr) \
N		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
X#define setSn_IMR(sn, imr) 		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IMR.
N * @sa setSn_IMR()
N */
N#define getSn_IMR(sn) \
N		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
X#define getSn_IMR(sn) 		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_SR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_SR.
N */
N#define getSn_SR(sn) \
N		WIZCHIP_READ(Sn_SR(sn))
X#define getSn_SR(sn) 		WIZCHIP_READ(Sn_SR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)port Value to set @ref Sn_PORT.
N * @sa getSn_PORT()
N */
N#define setSn_PORT(sn, port)  { \
N		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); \
N	}
X#define setSn_PORT(sn, port)  { 		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_PORT.
N * @sa setSn_PORT()
N */
N#define getSn_PORT(sn) \
N		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
X#define getSn_PORT(sn) 		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DHAR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to set socket n destination hardware address. It should be allocated 6 bytes.
N * @sa getSn_DHAR()
N */
N#define setSn_DHAR(sn, dhar) \
N		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
X#define setSn_DHAR(sn, dhar) 		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to get socket n destination hardware address. It should be allocated 6 bytes.
N * @sa setSn_DHAR()
N */
N#define getSn_DHAR(sn, dhar) \
N		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
X#define getSn_DHAR(sn, dhar) 		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to set socket n destination IP address. It should be allocated 4 bytes.
N * @sa getSn_DIPR()
N */
N#define setSn_DIPR(sn, dipr) \
N		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
X#define setSn_DIPR(sn, dipr) 		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to get socket n destination IP address. It should be allocated 4 bytes.
N * @sa SetSn_DIPR()
N */
N#define getSn_DIPR(sn, dipr) \
N		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
X#define getSn_DIPR(sn, dipr) 		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)dport Value to set @ref Sn_DPORT
N * @sa getSn_DPORT()
N */
N#define setSn_DPORT(sn, dport) { \
N		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); \
N	}
X#define setSn_DPORT(sn, dport) { 		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_DPORT.
N * @sa setSn_DPORT()
N */
N#define getSn_DPORT(sn) \
N		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
X#define getSn_DPORT(sn) 		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)mss Value to set @ref Sn_MSSR
N * @sa setSn_MSSR()
N */
N#define setSn_MSSR(sn, mss) { \
N		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); \
N	}
X#define setSn_MSSR(sn, mss) { 		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_MSSR.
N * @sa setSn_MSSR()
N */
N#define getSn_MSSR(sn) \
N		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
X#define getSn_MSSR(sn) 		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)tos Value to set @ref Sn_TOS
N * @sa getSn_TOS()
N */
N#define setSn_TOS(sn, tos) \
N		WIZCHIP_WRITE(Sn_TOS(sn), tos)
X#define setSn_TOS(sn, tos) 		WIZCHIP_WRITE(Sn_TOS(sn), tos)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of Sn_TOS.
N * @sa setSn_TOS()
N */
N#define getSn_TOS(sn) \
N		WIZCHIP_READ(Sn_TOS(sn))
X#define getSn_TOS(sn) 		WIZCHIP_READ(Sn_TOS(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ttl Value to set @ref Sn_TTL
N * @sa getSn_TTL()
N */
N#define setSn_TTL(sn, ttl) \
N		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
X#define setSn_TTL(sn, ttl) 		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TTL.
N * @sa setSn_TTL()
N */
N#define getSn_TTL(sn) \
N		WIZCHIP_READ(Sn_TTL(sn))
X#define getSn_TTL(sn) 		WIZCHIP_READ(Sn_TTL(sn))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)rxbufsize Value to set @ref Sn_RXBUF_SIZE
N * @sa getSn_RXBUF_SIZE()
N */
N#define setSn_RXBUF_SIZE(sn, rxbufsize) \
N		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
X#define setSn_RXBUF_SIZE(sn, rxbufsize) 		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_RXBUF_SIZE.
N * @sa setSn_RXBUF_SIZE()
N */
N#define getSn_RXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
X#define getSn_RXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)txbufsize Value to set @ref Sn_TXBUF_SIZE
N * @sa getSn_TXBUF_SIZE()
N */
N#define setSn_TXBUF_SIZE(sn, txbufsize) \
N		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
X#define setSn_TXBUF_SIZE(sn, txbufsize) 		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TXBUF_SIZE.
N * @sa setSn_TXBUF_SIZE()
N */
N#define getSn_TXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
X#define getSn_TXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_FSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_FSR.
N */
Nuint16_t getSn_TX_FSR(uint8_t sn);
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_RD.
N */
N#define getSn_TX_RD(sn) \
N		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
X#define getSn_TX_RD(sn) 		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)txwr Value to set @ref Sn_TX_WR
N * @sa GetSn_TX_WR()
N */
N#define setSn_TX_WR(sn, txwr) { \
N		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); \
N		}
X#define setSn_TX_WR(sn, txwr) { 		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); 		}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_WR.
N * @sa setSn_TX_WR()
N */
N#define getSn_TX_WR(sn) \
N		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
X#define getSn_TX_WR(sn) 		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_RSR.
N */
Nuint16_t getSn_RX_RSR(uint8_t sn);
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)rxrd Value to set @ref Sn_RX_RD
N * @sa getSn_RX_RD()
N */
N#define setSn_RX_RD(sn, rxrd) { \
N		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); \
N	}
X#define setSn_RX_RD(sn, rxrd) { 		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @regurn uint16_t. Value of @ref Sn_RX_RD.
N * @sa setSn_RX_RD()
N */
N#define getSn_RX_RD(sn) \
N		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
X#define getSn_RX_RD(sn) 		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_WR.
N */
N#define getSn_RX_WR(sn) \
N		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
X#define getSn_RX_WR(sn) 		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)frag Value to set @ref Sn_FRAG
N * @sa getSn_FRAD()
N */
N#define setSn_FRAG(sn, frag) { \
N		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); \
N	}
X#define setSn_FRAG(sn, frag) { 		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_FRAG.
N * @sa setSn_FRAG()
N */
N#define getSn_FRAG(sn) \
N		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
X#define getSn_FRAG(sn) 		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)kpalvt Value to set @ref Sn_KPALVTR
N * @sa getSn_KPALVTR()
N */
N#define setSn_KPALVTR(sn, kpalvt) \
N		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
X#define setSn_KPALVTR(sn, kpalvt) 		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_KPALVTR.
N * @sa setSn_KPALVTR()
N */
N#define getSn_KPALVTR(sn) \
N		WIZCHIP_READ(Sn_KPALVTR(sn))
X#define getSn_KPALVTR(sn) 		WIZCHIP_READ(Sn_KPALVTR(sn))
N
N//////////////////////////////////////
N
N/////////////////////////////////////
N// Sn_TXBUF & Sn_RXBUF IO function //
N/////////////////////////////////////
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameter.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n RX max buffer size.
N */
N#define getSn_RxMAX(sn) \
N		(getSn_RXBUF_SIZE(sn) << 10)
X#define getSn_RxMAX(sn) 		(getSn_RXBUF_SIZE(sn) << 10)
N
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameters.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n TX max buffer size.
N */
N//uint16_t getSn_TxMAX(uint8_t sn);
N#define getSn_TxMAX(sn) \
N		(getSn_TXBUF_SIZE(sn) << 10)
X#define getSn_TxMAX(sn) 		(getSn_TXBUF_SIZE(sn) << 10)
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to internal TX memory
N *
N * @details This function reads the Tx write pointer register and after that,
N * it copies the <i>wizdata(pointer buffer)</i> of the length of <i>len(variable)</i> bytes to internal TX memory
N * and updates the Tx write pointer register.
N * This function is being called by send() and sendto() function also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to write data
N * @param len Data length
N * @sa wiz_recv_data()
N */
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to your buffer from internal RX memory
N *
N * @details This function read the Rx read pointer register and after that,
N * it copies the received data from internal RX memory
N * to <i>wizdata(pointer variable)</i> of the length of <i>len(variable)</i> bytes.
N * This function is being called by recv() also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to read data
N * @param len Data length
N * @sa wiz_send_data()
N */
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It discard the received data in RX memory.
N * @details It discards the data of the length of <i>len(variable)</i> bytes in internal RX memory.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param len Data length
N */
Nvoid wiz_recv_ignore(uint8_t sn, uint16_t len);
N
N#endif   // _W5500_H_
L 52 "..\..\Ethernet\W5500\w5500.c" 2
N
N
N#define _W5500_SPI_VDM_OP_          0x00
N#define _W5500_SPI_FDM_OP_LEN1_     0x01
N#define _W5500_SPI_FDM_OP_LEN2_     0x02
N#define _W5500_SPI_FDM_OP_LEN4_     0x03
N
N////////////////////////////////////////////////////
N
Nuint8_t  WIZCHIP_READ(uint32_t AddrSel)
N{
N   uint8_t ret;
N
N   WIZCHIP_CRITICAL_ENTER();
X   WIZCHIP . CRIS . _enter();
N   WIZCHIP.CS._select();
N
N#if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
X#if( ((0x0200 + 1) & 0x0200))
N
N   #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
X   #if  ( (0x0200 + 1) == (0x0200 + 1) )
N   	   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);
X   	   AddrSel |= ((0x00 << 2) | 0x00);
N   #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
S   	   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_FDM_OP_LEN1_);
S   #else
S      #error "Unsupported _WIZCHIP_IO_SPI_ in W5500 !!!"
N   #endif
N
N   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
N   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
N   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
N   ret = WIZCHIP.IF.SPI._read_byte();
N
N#elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
S
S   #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
S
S   #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
S
S   #else
S      #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
S   #endif
S#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W5000. !!!"   
N#endif
N
N   WIZCHIP.CS._deselect();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _exit();
N   return ret;
N}
N
Nvoid     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
N{
N    WIZCHIP_CRITICAL_ENTER();
X    WIZCHIP . CRIS . _enter();
N    WIZCHIP.CS._select();
N
N#if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
X#if( ((0x0200 + 1) & 0x0200))
N
N   #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
X   #if  ( (0x0200 + 1) == (0x0200 + 1) )
N   	   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
X   	   AddrSel |= ((0x01 << 2) | 0x00);
N   #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
S   	   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_FDM_OP_LEN1_);
S   #else
S      #error "Unsupported _WIZCHIP_IO_SPI_ in W5500 !!!"
N   #endif
N
N   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
N   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
N   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
N   WIZCHIP.IF.SPI._write_byte(wb);
N
N#elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
S
S   #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
S
S   #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
S
S   #else
S      #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
S   #endif
S#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W5500. !!!"
N#endif
N
N   WIZCHIP.CS._deselect();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _exit();
N}
N         
Nvoid     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
N{
N   uint16_t i = 0;
N   uint16_t j = 0;
N   WIZCHIP_CRITICAL_ENTER();
X   WIZCHIP . CRIS . _enter();
N   WIZCHIP.CS._select();
N
N#if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
X#if( ((0x0200 + 1) & 0x0200))
N
N   #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
X   #if  ( (0x0200 + 1) == (0x0200 + 1) )
N      AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);
X      AddrSel |= ((0x00 << 2) | 0x00);
N      WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
N      WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
N      WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
N      for(i = 0; i < len; i++,j)
N        pBuf[i] = WIZCHIP.IF.SPI._read_byte();
N   #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
S      AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_FDM_OP_LEN4_);
S      for(i = 0; i < len/4; i++, j)
S      {
S         WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
S         WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
S         WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
S         pBuf[i*4]   = WIZCHIP.IF.SPI._read_byte();
S         pBuf[i*4+1] = WIZCHIP.IF.SPI._read_byte();
S         pBuf[i*4+2] = WIZCHIP.IF.SPI._read_byte();            
S         pBuf[i*4+3] = WIZCHIP.IF.SPI._read_byte();            
S         AddrSel = WIZCHIP_OFFSET_INC(AddrSel,4);
S      }
S      len %= 4;      // for the rest data
S      // M20131220 : remove for loop
S      i *= 4;        
S      if(len >= 2)
S      {
S         AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN4_ to _W5500_SPI_FDM_OP_LEN2_
S
S       //for(j = 0; j < len/2 ; j++)
S         {
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
S            pBuf[i]   = WIZCHIP.IF.SPI._read_byte();
S            pBuf[i+1] = WIZCHIP.IF.SPI._read_byte();
S            i += 2;
S            AddrSel = WIZCHIP_OFFSET_INC(AddrSel,2);
S         }
S      }
S      len %= 2;
S      if(len)
S      {
S        AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN2_ to _W5500_SPI_FDM_OP_LEN1_
S        WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
S        WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
S        WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
S        pBuf[i]   = WIZCHIP.IF.SPI._read_byte();
S      }      
S   #else
S      #error "Unsupported _WIZCHIP_IO_MODE_SPI_ in W5500 !!!"
N   #endif
N
N#elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
S
S   #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
S
S   #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
S
S   #else
S      #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
S   #endif
S#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W5500. !!!!"
N#endif
N
N   WIZCHIP.CS._deselect();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _exit();
N}
N
Nvoid     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
N{
N   uint16_t i = 0;
N   uint16_t j = 0;
N   WIZCHIP_CRITICAL_ENTER();
X   WIZCHIP . CRIS . _enter();
N   WIZCHIP.CS._select();
N
N#if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
X#if( ((0x0200 + 1) & 0x0200))
N
N   #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
X   #if  ( (0x0200 + 1) == (0x0200 + 1) )
N      AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
X      AddrSel |= ((0x01 << 2) | 0x00);
N      WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
N      WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
N      WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
N      for(i = 0; i < len; i++,j)
N         WIZCHIP.IF.SPI._write_byte(pBuf[i]);
N   #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
S      AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_FDM_OP_LEN4_);
S      for(i = 0; i < len/4; i++, j)
S      {
S         WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
S         WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
S         WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
S         WIZCHIP.IF.SPI._write_byte(pBuf[i*4]  );
S         WIZCHIP.IF.SPI._write_byte(pBuf[i*4+1]);
S         WIZCHIP.IF.SPI._write_byte(pBuf[i*4+2]);            
S         WIZCHIP.IF.SPI._write_byte(pBuf[i*4+3]);            
S         AddrSel = WIZCHIP_OFFSET_INC(AddrSel,4);
S      }
S      len %= 4;      // for the rest data
S      // M20131220 : Remove for loop
S      i *= 4;
S      if(len >= 2)
S      {
S         AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN4_ to _W5500_SPI_FDM_OP_LEN2_
S
S       //for(j = 0; j < len/2 ; j++)
S         {
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
S            WIZCHIP.IF.SPI._write_byte(pBuf[i]  );
S            WIZCHIP.IF.SPI._write_byte(pBuf[i+1]);
S            i += 2;
S            AddrSel = WIZCHIP_OFFSET_INC(AddrSel, 2);
S         }
S         len %= 2;
S         if(len)
S         {
S            AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN2_ to _W5500_SPI_FDM_OP_LEN1_
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
S            WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
S            WIZCHIP.IF.SPI._write_byte(pBuf[i]);
S         }      
S      }
S   #else
S      #error "Unsupported _WIZCHIP_IO_SPI_ in W5500 !!!"
N   #endif
N
N#elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
S
S   #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
S
S   #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
S
S   #else
S      #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
S   #endif
S#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W5500. !!!!"
N#endif
N
N   WIZCHIP.CS._deselect();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _exit();
N}
N
N
Nuint16_t getSn_TX_FSR(uint8_t sn)
N{
N   uint16_t val=0,val1=0;
N   do
N   {
N      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
X      val1 = WIZCHIP_READ((0x00000000 + (0x0020 << 8) + ((1+4*sn) << 3)));
N      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
X      val1 = (val1 << 8) + WIZCHIP_READ(((0x00000000 + (0x0020 << 8) + ((1+4*sn) << 3)) + (1<<8)));
N      if (val1 != 0)
N      {
N        val = WIZCHIP_READ(Sn_TX_FSR(sn));
X        val = WIZCHIP_READ((0x00000000 + (0x0020 << 8) + ((1+4*sn) << 3)));
N        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
X        val = (val << 8) + WIZCHIP_READ(((0x00000000 + (0x0020 << 8) + ((1+4*sn) << 3)) + (1<<8)));
N      }
N   }while (val != val1);
N   return val;
N}
N
N
Nuint16_t getSn_RX_RSR(uint8_t sn)
N{
N   uint16_t val=0,val1=0;
N   do
N   {
N      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
X      val1 = WIZCHIP_READ((0x00000000 + (0x0026 << 8) + ((1+4*sn) << 3)));
N      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
X      val1 = (val1 << 8) + WIZCHIP_READ(((0x00000000 + (0x0026 << 8) + ((1+4*sn) << 3)) + (1<<8)));
N      if (val1 != 0)
N      {
N        val = WIZCHIP_READ(Sn_RX_RSR(sn));
X        val = WIZCHIP_READ((0x00000000 + (0x0026 << 8) + ((1+4*sn) << 3)));
N        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
X        val = (val << 8) + WIZCHIP_READ(((0x00000000 + (0x0026 << 8) + ((1+4*sn) << 3)) + (1<<8)));
N      }
N   }while (val != val1);
N   return val;
N}
N
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
N{
N   uint16_t ptr = 0;
N   uint32_t addrsel = 0;
N   if(len == 0)  return;
N   ptr = getSn_TX_WR(sn);
X   ptr = ((WIZCHIP_READ((0x00000000 + (0x0024 << 8) + ((1+4*sn) << 3))) << 8) + WIZCHIP_READ(((0x00000000 + (0x0024 << 8) + ((1+4*sn) << 3)) + (1<<8))));
N   //M20140501 : implict type casting -> explict type casting
N   //addrsel = (ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
N   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
X   addrsel = ((uint32_t)ptr << 8) + ((2+4*sn) << 3);
N   //
N   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
N   
N   ptr += len;
N   setSn_TX_WR(sn,ptr);
X   { WIZCHIP_WRITE((0x00000000 + (0x0024 << 8) + ((1+4*sn) << 3)), (uint8_t)(ptr>>8)); WIZCHIP_WRITE(((0x00000000 + (0x0024 << 8) + ((1+4*sn) << 3)) + (1<<8)), (uint8_t) ptr); };
N}
N
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
N{
N   uint16_t ptr = 0;
N   uint32_t addrsel = 0;
N   
N   if(len == 0) return;
N   ptr = getSn_RX_RD(sn);
X   ptr = ((WIZCHIP_READ((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3))) << 8) + WIZCHIP_READ(((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3)) + (1<<8))));
N   //M20140501 : implict type casting -> explict type casting
N   //addrsel = ((ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
N   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
X   addrsel = ((uint32_t)ptr << 8) + ((3+4*sn) << 3);
N   //
N   WIZCHIP_READ_BUF(addrsel, wizdata, len);
N   ptr += len;
N   
N   setSn_RX_RD(sn,ptr);
X   { WIZCHIP_WRITE((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3)), (uint8_t)(ptr>>8)); WIZCHIP_WRITE(((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3)) + (1<<8)), (uint8_t) ptr); };
N}
N
N
Nvoid wiz_recv_ignore(uint8_t sn, uint16_t len)
N{
N   uint16_t ptr = 0;
N   ptr = getSn_RX_RD(sn);
X   ptr = ((WIZCHIP_READ((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3))) << 8) + WIZCHIP_READ(((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3)) + (1<<8))));
N   ptr += len;
N   setSn_RX_RD(sn,ptr);
X   { WIZCHIP_WRITE((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3)), (uint8_t)(ptr>>8)); WIZCHIP_WRITE(((0x00000000 + (0x0028 << 8) + ((1+4*sn) << 3)) + (1<<8)), (uint8_t) ptr); };
N}
N
