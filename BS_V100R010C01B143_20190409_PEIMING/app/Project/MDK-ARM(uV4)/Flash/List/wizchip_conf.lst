L 1 "..\..\Ethernet\wizchip_conf.c"
N//****************************************************************************/ 
N//!
N//! \file wizchip_conf.c
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.1
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2014/05/01> V1.0.1  Refer to M20140501
N//!        1. Explicit type casting in wizchip_bus_readbyte() & wizchip_bus_writebyte()
N//            Issued by Mathias ClauBen.
N//!           uint32_t type converts into ptrdiff_t first. And then recoverting it into uint8_t*
N//!           For remove the warning when pointer type size is not 32bit.
N//!           If ptrdiff_t doesn't support in your complier, You should must replace ptrdiff_t into your suitable pointer type.
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************/
N//A20140501 : for use the type - ptrdiff_t
N#include <stddef.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 49 "..\..\Ethernet\wizchip_conf.c" 2
N//
N
N#include "wizchip_conf.h"
L 1 "..\..\Ethernet\wizchip_conf.h" 1
N//*****************************************************************************
N//
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. It could be replaced at WIZCHIP I/O function because they were made by WIZCHIP I/O functions.  
N * @details There are functions of configuring WIZCHIP, network, interrupt, phy, network information and timer. \n
N * 
N */
N
N#ifndef  _WIZCHIP_CONF_H_
N#define  _WIZCHIP_CONF_H_
N
N#include <stdint.h>
L 1 "D:\MDK5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 54 "..\..\Ethernet\wizchip_conf.h" 2
N/**
N * @brief Select WIZCHIP.
N * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
N *       ex> <code> #define \_WIZCHIP_      5500 </code>
N */
N#define _WIZCHIP_                      5500   // 5100, 5200, 5500
N
N#define _WIZCHIP_IO_MODE_NONE_         0x0000
N#define _WIZCHIP_IO_MODE_BUS_          0x0100 /**< Bus interface mode */
N#define _WIZCHIP_IO_MODE_SPI_          0x0200 /**< SPI interface mode */
N//#define _WIZCHIP_IO_MODE_IIC_          0x0400
N//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
N// Add to
N//
N
N#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) /**< BUS interface mode for direct  */
N#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) /**< BUS interface mode for indirect */
N
N#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
N#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
N
N
N#if   (_WIZCHIP_ == 5100)
X#if   (5500 == 5100)
S   #define _WIZCHIP_ID_                "W5100\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S
S#elif (_WIZCHIP_ == 5200)
X#elif (5500 == 5200)
S   #define _WIZCHIP_ID_                "W5200\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S   #include "W5200/w5200.h"
N#elif (_WIZCHIP_ == 5500)
X#elif (5500 == 5500)
N  #define _WIZCHIP_ID_                 "W5500\0"
N  
N/**
N * @brief Define interface mode. \n
N * @todo Should select interface mode as chip. 
N *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
N *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
N *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
N *        - Others will be defined in future. \n\n
N *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
N *       
N */
N   //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
N   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
N   #include "W5500/w5500.h"
L 1 "..\..\Ethernet\W5500/w5500.h" 1
N//*****************************************************************************
N//
N//! \file w5500.h
N//! \brief W5500 HAL Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#ifndef  _W5500_H_
N#define  _W5500_H_
N
N#include <stdint.h>
N#include "wizchip_conf.h"
L 1 "..\..\Ethernet\wizchip_conf.h" 1
N//*****************************************************************************
N//
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2013/10/21
N//! \par  Revision history
N//!       <2013/10/21> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2013, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. It could be replaced at WIZCHIP I/O function because they were made by WIZCHIP I/O functions.  
N * @details There are functions of configuring WIZCHIP, network, interrupt, phy, network information and timer. \n
N * 
N */
N
N#ifndef  _WIZCHIP_CONF_H_
S#define  _WIZCHIP_CONF_H_
S
S#include <stdint.h>
S/**
S * @brief Select WIZCHIP.
S * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
S *       ex> <code> #define \_WIZCHIP_      5500 </code>
S */
S#define _WIZCHIP_                      5500   // 5100, 5200, 5500
S
S#define _WIZCHIP_IO_MODE_NONE_         0x0000
S#define _WIZCHIP_IO_MODE_BUS_          0x0100 /**< Bus interface mode */
S#define _WIZCHIP_IO_MODE_SPI_          0x0200 /**< SPI interface mode */
S//#define _WIZCHIP_IO_MODE_IIC_          0x0400
S//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
S// Add to
S//
S
S#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) /**< BUS interface mode for direct  */
S#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) /**< BUS interface mode for indirect */
S
S#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
S#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
S
S
S#if   (_WIZCHIP_ == 5100)
S   #define _WIZCHIP_ID_                "W5100\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S
S#elif (_WIZCHIP_ == 5200)
S   #define _WIZCHIP_ID_                "W5200\0"
S/**
S * @brief Define interface mode.
S * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
S */
S// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
S   #include "W5200/w5200.h"
S#elif (_WIZCHIP_ == 5500)
S  #define _WIZCHIP_ID_                 "W5500\0"
S  
S/**
S * @brief Define interface mode. \n
S * @todo Should select interface mode as chip. 
S *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
S *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
S *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
S *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
S *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
S *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
S *        - Others will be defined in future. \n\n
S *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
S *       
S */
S   //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
S   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
S   #include "W5500/w5500.h"
S#else 
S   #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
S#endif
S
S#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
S#endif
S
S/**
S * @brief Define I/O base address when BUS IF mode.
S * @todo Should re-define it to fit your system when BUS IF Mode (@ref \_WIZCHIP_IO_MODE_BUS_,
S *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
S *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
S */
S#define _WIZCHIP_IO_BASE_              0x00000000  // 
S
S#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
S   #ifndef _WIZCHIP_IO_BASE_
S      #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
S   #endif
S#endif   
S
S#if _WIZCHIP_ > 5100
S   #define _WIZCHIP_SOCK_NUM_   8   ///< The count of independant socket of @b WIZCHIP
S#else
S   #define _WIZCHIP_SOCK_NUM_   4   ///< The count of independant socket of @b WIZCHIP
S#endif      
S
S
S/********************************************************
S* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
S*********************************************************/
S/**
S * @ingroup DATA_TYPE
S * @brief The set of callback functions for W5500:@ref WIZCHIP_IO_Functions W5200:@ref WIZCHIP_IO_Functions_W5200
S */
Stypedef struct __WIZCHIP
S{
S   uint16_t  if_mode;               ///< host interface mode
S   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
S   /**
S    * The set of critical section callback func.
S    */
S   struct _CRIS
S   {
S      void (*_enter)  (void);       ///< crtical section enter 
S      void (*_exit) (void);         ///< critial section exit  
S   }CRIS;  
S   /**
S    *  The set of @ref\_WIZCHIP_ select control callback func.
S    */
S   struct _CS
S   {
S      void (*_select)  (void);      ///< @ref \_WIZCHIP_ selected
S      void (*_deselect)(void);      ///< @ref \_WIZCHIP_ deselected
S   }CS;  
S   /**
S    * The set of interface IO callback func.
S    */
S   union _IF
S   {	 
S      /**
S       * For BUS interface IO
S       */  
S      struct
S      {
S         uint8_t  (*_read_byte)  (uint32_t AddrSel);
S         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
S      }BUS;      
S      /**
S       * For SPI interface IO
S       */
S      struct
S      {
S         uint8_t (*_read_byte)   (void);
S         void    (*_write_byte)  (uint8_t wb);
S      }SPI;
S      // To be added
S      //
S   }IF;
S}_WIZCHIP;
S
Sextern _WIZCHIP  WIZCHIP;
S
S/**
S * @ingroup DATA_TYPE
S *  WIZCHIP control type enumration used in @ref ctlwizchip().
S */
Stypedef enum
S{
S   CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
S   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
S   CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
S   CW_CLR_INTERRUPT,   ///< Clears interrupt
S   CW_SET_INTRMASK,    ///< Masks interrupt
S   CW_GET_INTRMASK,    ///< Get interrupt mask
S   CW_SET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
S   CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
S   CW_GET_ID,          ///< Gets WIZCHIP name.
S
S#if _WIZCHIP_ ==  5500
S   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
S   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
S   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
S   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
S   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
S#endif
S   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
S   CW_GET_PHYLINK      ///< Get PHY Link status
S}ctlwizchip_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Network control type enumration used in @ref ctlnetwork().
S */
Stypedef enum
S{
S   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
S   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
S   CN_SET_NETMODE,  ///< Set network mode as WOL, PPPoE, Ping Block, and Force ARP mode
S   CN_GET_NETMODE,  ///< Get network mode as WOL, PPPoE, Ping Block, and Force ARP mode
S   CN_SET_TIMEOUT,  ///< Set network timeout as retry count and time.
S   CN_GET_TIMEOUT,  ///< Get network timeout as retry count and time.
S}ctlnetwork_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Interrupt kind when CW_SET_INTRRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK
S *  and CW_GET_INTRMASK is used in @ref ctlnetwork().
S *  It can be used with OR operation.
S */
Stypedef enum
S{
S#if _WIZCHIP_ > 5200
S   IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
S#endif   
S
S   IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
S
S#if _WIZCHIP_ != 5200
S   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
S#endif   
S
S   IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
S
S   IK_SOCK_0            = (1 << 8),   ///< Socket 0 interrupt
S   IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
S   IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
S   IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
S#if _WIZCHIP_ > 5100   
S   IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
S   IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
S   IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
S   IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
S#endif   
S
S#if _WIZCHIP_ > 5100
S   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
S#else
S   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
S#endif      
S}intr_kind;
S
S#define PHY_CONFBY_HW            0     ///< Configured PHY operation mode by HW pin
S#define PHY_CONFBY_SW            1     ///< Configured PHY operation mode by SW register   
S#define PHY_MODE_MANUAL          0     ///< Configured PHY operation mode with user setting.
S#define PHY_MODE_AUTONEGO        1     ///< Configured PHY operation mode with auto-negotiation
S#define PHY_SPEED_10             0     ///< Link Speed 10
S#define PHY_SPEED_100            1     ///< Link Speed 100
S#define PHY_DUPLEX_HALF          0     ///< Link Half-Duplex
S#define PHY_DUPLEX_FULL          1     ///< Link Full-Duplex
S#define PHY_LINK_OFF             0     ///< Link Off
S#define PHY_LINK_ON              1     ///< Link On
S#define PHY_POWER_NORM           0     ///< PHY power normal mode
S#define PHY_POWER_DOWN           1     ///< PHY power down mode 
S
S
S#if _WIZCHIP_ == 5500 
S/**
S * @ingroup DATA_TYPE
S *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
S *  and it indicates the real PHY status configured by HW or SW in all WIZCHIP. \n
S *  Valid only in W5500.
S */
Stypedef struct wiz_PhyConf_t
S{
S      uint8_t by;       ///< set by @ref PHY_CONFBY_HW or @ref PHY_CONFBY_SW
S      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL or @ref PHY_MODE_AUTONEGO
S      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
S      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
S      //uint8_t power;  ///< set by @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
S      //uint8_t link;   ///< Valid only in CW_GET_PHYSTATUS. set by @ref PHY_LINK_ON or PHY_DUPLEX_OFF 
S   }wiz_PhyConf;
S#endif   
S
S/**
S * @ingroup DATA_TYPE
S *  It used in setting dhcp_mode of @ref wiz_NetInfo.
S */
Stypedef enum
S{
S   NETINFO_STATIC = 1,    ///< Static IP configuration by manually.
S   NETINFO_DHCP           ///< Dynamic IP configruation from a DHCP sever
S}dhcp_mode;
S
S/**
S * @ingroup DATA_TYPE
S *  Network Information for WIZCHIP
S */
Stypedef struct wiz_NetInfo_t
S{
S   uint8_t mac[6];  ///< Source Mac Address
S   uint8_t ip[4];   ///< Source IP Address
S   uint8_t sn[4];   ///< Subnet Mask 
S   uint8_t gw[4];   ///< Gateway IP Address
S   uint8_t dns[4];  ///< DNS server IP Address
S   dhcp_mode dhcp;  ///< 1 - Static, 2 - DHCP
S}wiz_NetInfo;
S
S/**
S * @ingroup DATA_TYPE
S *  Network mode
S */
Stypedef enum
S{
S#if _WIZCHIP_ == 5500   
S   NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
S#endif   
S   NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
S   NM_PINGBLOCK   = (1<<4),  ///< Block ping-request
S   NM_PPPOE       = (1<<3),  ///< PPPoE mode
S}netmode_type;
S
S/**
S * @ingroup DATA_TYPE
S *  Used in CN_SET_TIMEOUT or CN_GET_TIMEOUT of @ref ctlwizchip() for timeout configruation.
S */
Stypedef struct wiz_NetTimeout_t
S{
S   uint8_t  retry_cnt;     ///< retry count 
S   uint16_t time_100us;    ///< time unit 100us
S}wiz_NetTimeout;
S
S/**
S *@brief Registers call back function for critical section of I/O functions such as
S *\ref WIZCHIP_READ, @ref WIZCHIP_WRITE, @ref WIZCHIP_READ_BUF and @ref WIZCHIP_WRITE_BUF.
S *@param cris_en : callback function for critical section enter.
S *@param cris_ex : callback function for critical section exit.
S *@todo Describe @ref WIZCHIP_CRITICAL_ENTER and @ref WIZCHIP_CRITICAL_EXIT marco or register your functions.
S *@note If you do not describe or register, default functions(@ref wizchip_cris_enter & @ref wizchip_cris_exit) is called.
S */
Svoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
S
S
S/**
S *@brief Registers call back function for WIZCHIP select & deselect.
S *@param cs_sel : callback function for WIZCHIP select
S *@param cs_desel : callback fucntion for WIZCHIP deselect
S *@todo Describe @ref wizchip_cs_select and @ref wizchip_cs_deselect function or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
S
S/**
S *@brief Registers call back function for bus interface.
S *@param bus_rb   : callback function to read byte data using system bus
S *@param bus_wb   : callback function to write byte data using system bus
S *@todo Describe @ref wizchip_bus_readbyte and @ref wizchip_bus_writebyte function
S *or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
S
S/**
S *@brief Registers call back function for SPI interface.
S *@param spi_rb : callback function to read byte usig SPI 
S *@param spi_wb : callback function to write byte usig SPI 
S *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
S *or register your functions.
S *@note If you do not describe or register, null function is called.
S */
Svoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb));
S
S/**
S * @ingroup extra_functions
S * @brief Controls to the WIZCHIP.
S * @details Resets WIZCHIP & internal PHY, Configures PHY mode, Monitor PHY(Link,Speed,Half/Full/Auto),
S * controls interrupt & mask and so on.
S * @param cwtype : Decides to the control type
S * @param arg : arg type is dependent on cwtype.
S * @return  0 : Success \n
S *         -1 : Fail because of invalid \ref ctlwizchip_type or unsupported \ref ctlwizchip_type in WIZCHIP 
S */          
Sint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
S
S/**
S * @ingroup extra_functions
S * @brief Controls to network.
S * @details Controls to network environment, mode, timeout and so on.
S * @param cntype : Input. Decides to the control type
S * @param arg : Inout. arg type is dependent on cntype.
S * @return -1 : Fail because of invalid \ref ctlnetwork_type or unsupported \ref ctlnetwork_type in WIZCHIP \n
S *          0 : Success      
S */          
Sint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
S
S
S/* 
S * The following functions are implemented for internal use. 
S * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
S */
S 
S/**
S * @ingroup extra_functions
S * @brief Reset WIZCHIP by softly.
S */ 
Svoid   wizchip_sw_reset(void);
S
S/**
S * @ingroup extra_functions
S * @brief Initializes WIZCHIP with socket buffer size
S * @param txsize Socket tx buffer sizes. If null, initialized the default size 2KB.
S * @param rxsize Socket rx buffer sizes. If null, initialized the default size 2KB.
S * @return 0 : succcess \n
S *        -1 : fail. Invalid buffer size
S */
Sint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
S
S/** 
S * @ingroup extra_functions
S * @brief Clear Interrupt of WIZCHIP.
S * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Svoid wizchip_clrinterrupt(intr_kind intr);
S
S/** 
S * @ingroup extra_functions
S * @brief Get Interrupt of WIZCHIP.
S * @return @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Sintr_kind wizchip_getinterrupt(void);
S
S/** 
S * @ingroup extra_functions
S * @brief Mask or Unmask Interrupt of WIZCHIP.
S * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
S */
Svoid wizchip_setinterruptmask(intr_kind intr);
S
S/** 
S * @ingroup extra_functions
S * @brief Get Interrupt mask of WIZCHIP.
S * @return : The operated OR vaule of @ref intr_kind. It can type-cast to uint16_t.
S */
Sintr_kind wizchip_getinterruptmask(void);
S
S#if _WIZCHIP_ > 5100
S   int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
S   int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
S#endif
S
S#if _WIZCHIP_ == 5500
S   void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
S/**
S * @ingroup extra_functions
S * @brief Set the phy information for WIZCHIP without power mode
S * @param phyconf : @ref wiz_PhyConf
S */
S   void   wizphy_setphyconf(wiz_PhyConf* phyconf);  
S /**
S * @ingroup extra_functions
S * @brief Get phy configuration information.
S * @param phyconf : @ref wiz_PhyConf
S */
S   void   wizphy_getphyconf(wiz_PhyConf* phyconf); 
S /**
S * @ingroup extra_functions
S * @brief Get phy status.
S * @param phyconf : @ref wiz_PhyConf
S */ 
S   void   wizphy_getphystat(wiz_PhyConf* phyconf);
S /**
S * @ingroup extra_functions
S * @brief set the power mode of phy inside WIZCHIP. Refer to @ref PHYCFGR in W5500, @ref PHYSTATUS in W5200
S * @param pmode Settig value of power down mode.
S */   
S   int8_t wizphy_setphypmode(uint8_t pmode);    
S#endif
S
S/**
S* @ingroup extra_functions
S * @brief Set the network information for WIZCHIP
S * @param pnetinfo : @ref wizNetInfo
S */
Svoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
S
S/**
S * @ingroup extra_functions
S * @brief Get the network information for WIZCHIP
S * @param pnetinfo : @ref wizNetInfo
S */
Svoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
S
S/**
S * @ingroup extra_functions
S * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
S * @param pnetinfo Value of network mode. Refer to @ref netmode_type.
S */
Sint8_t wizchip_setnetmode(netmode_type netmode);
S
S/**
S * @ingroup extra_functions
S * @brief Get the network mode such WOL, PPPoE, Ping Block, and etc. 
S * @return Value of network mode. Refer to @ref netmode_type.
S */
Snetmode_type wizchip_getnetmode(void);
S
S/**
S * @ingroup extra_functions
S * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
S * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
S * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
S */
Svoid wizchip_settimeout(wiz_NetTimeout* nettime);
S
S/**
S * @ingroup extra_functions
S * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
S * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
S * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
S */
Svoid wizchip_gettimeout(wiz_NetTimeout* nettime);
S
N#endif   // _WIZCHIP_CONF_H_
L 47 "..\..\Ethernet\W5500/w5500.h" 2
N
N#define _W5500_IO_BASE_              0x00000000
N
N#define _W5500_SPI_READ_			   (0x00 << 2) //< SPI interface Read operation in Control Phase
N#define _W5500_SPI_WRITE_			   (0x01 << 2) //< SPI interface Write operation in Control Phase
N
N#define WIZCHIP_CREG_BLOCK          0x00 	//< Common register block
N#define WIZCHIP_SREG_BLOCK(N)       (1+4*N) //< Socket N register block
N#define WIZCHIP_TXBUF_BLOCK(N)      (2+4*N) //< Socket N Tx buffer address block
N#define WIZCHIP_RXBUF_BLOCK(N)      (3+4*N) //< Socket N Rx buffer address block
N
N#define WIZCHIP_OFFSET_INC(ADDR, N)    (ADDR + (N<<8)) //< Increase offset address
N
N
N///////////////////////////////////////
N// Definition For Legacy Chip Driver //
N///////////////////////////////////////
N#define IINCHIP_READ(ADDR)                WIZCHIP_READ(ADDR)               ///< The defined for legacy chip driver
N#define IINCHIP_WRITE(ADDR,VAL)           WIZCHIP_WRITE(ADDR,VAL)          ///< The defined for legacy chip driver
N#define IINCHIP_READ_BUF(ADDR,BUF,LEN)    WIZCHIP_READ_BUF(ADDR,BUF,LEN)   ///< The defined for legacy chip driver
N#define IINCHIP_WRITE_BUF(ADDR,BUF,LEN)   WIZCHIP_WRITE(ADDR,BUF,LEN)      ///< The defined for legacy chip driver
N
N//////////////////////////////
N//--------------------------  defgroup ---------------------------------
N/**
N * @defgroup W5500 W5500
N *
N * @brief WHIZCHIP register defines and I/O functions of @b W5500.
N *
N * - @ref WIZCHIP_register : @ref Common_register_group and @ref Socket_register_group
N * - @ref WIZCHIP_IO_Functions : @ref Basic_IO_function, @ref Common_register_access_function and @ref Socket_register_access_function
N */
N 
N 
N/**
N * @defgroup WIZCHIP_register WIZCHIP register
N * @ingroup W5500
N *
N * @brief WHIZCHIP register defines register group of @b W5500.
N *
N * - @ref Common_register_group : Common register group
N * - @ref Socket_register_group : \c SOCKET n register group
N */
N
N
N/**
N * @defgroup WIZCHIP_IO_Functions WIZCHIP I/O functions
N * @ingroup W5500
N *
N * @brief This supports the basic I/O functions for @ref WIZCHIP_register.
N *
N * - <b> Basic I/O function </b> \n
N *   WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF() \n\n
N *
N * - @ref Common_register_group <b>access functions</b> \n
N * 	-# @b Mode \n
N *    getMR(), setMR()
N * 	-# @b Interrupt \n
N *    getIR(), setIR(), getIMR(), setIMR(), getSIR(), setSIR(), getSIMR(), setSIMR(), getINTLEVEL(), setINTLEVEL()
N * 	-# <b> Network Information </b> \n
N *    getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR()
N * 	-# @b Retransmission \n
N *    getRCR(), setRCR(), getRTR(), setRTR()
N * 	-# @b PPPoE \n
N *    getPTIMER(), setPTIMER(), getPMAGIC(), getPMAGIC(), getPSID(), setPSID(), getPHAR(), setPHAR(), getPMRU(), setPMRU()
N * 	-# <b> ICMP packet </b>\n
N *    getUIPR(), getUPORTR()
N * 	-# @b etc. \n
N *    getPHYCFGR(), setPHYCFGR(), getVERSIONR() \n\n
N *
N * - \ref Socket_register_group <b>access functions</b> \n
N *   -# <b> SOCKET control</b> \n
N *      getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IR()
N *   -# <b> SOCKET information</b> \n
N *      getSn_SR(), getSn_DHAR(), setSn_DHAR(), getSn_PORT(), setSn_PORT(), getSn_DIPR(), setSn_DIPR(), getSn_DPORT(), setSn_DPORT()
N *      getSn_MSSR(), setSn_MSSR()
N *   -# <b> SOCKET communication </b> \n
N *      getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE() \n
N *      getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
N *      getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
N *      getSn_TX_FSR(), getSn_RX_RSR(), getSn_KPALVTR(), setSn_KPALVTR()
N *   -# <b> IP header field </b> \n
N *      getSn_FRAG(), setSn_FRAG(),  getSn_TOS(), setSn_TOS() \n
N *      getSn_TTL(), setSn_TTL()
N */
N
N
N
N/**
N * @defgroup Common_register_group Common register
N * @ingroup WIZCHIP_register
N *
N * @brief Common register group\n
N * It set the basic for the networking\n
N * It set the configuration such as interrupt, network information, ICMP, etc.
N * @details
N * @sa MR : Mode register.
N * @sa GAR, SUBR, SHAR, SIPR
N * @sa INTLEVEL, IR, IMR, SIR, SIMR : Interrupt.
N * @sa RTR, RCR : Data retransmission.
N * @sa PTIMER, PMAGIC, PHAR, PSID, PMRU : PPPoE.
N * @sa UIPR, UPORTR : ICMP message.
N * @sa PHYCFGR, VERSIONR : etc.
N */
N 
N  
N 
N/**
N * @defgroup Socket_register_group Socket register
N * @ingroup WIZCHIP_register
N *
N * @brief Socket register group.\n
N * Socket register configures and control SOCKETn which is necessary to data communication.
N * @details
N * @sa Sn_MR, Sn_CR, Sn_IR, Sn_IMR : SOCKETn Control
N * @sa Sn_SR, Sn_PORT, Sn_DHAR, Sn_DIPR, Sn_DPORT : SOCKETn Information
N * @sa Sn_MSSR, Sn_TOS, Sn_TTL, Sn_KPALVTR, Sn_FRAG : Internet protocol.
N * @sa Sn_RXBUF_SIZE, Sn_TXBUF_SIZE, Sn_TX_FSR, Sn_TX_RD, Sn_TX_WR, Sn_RX_RSR, Sn_RX_RD, Sn_RX_WR : Data communication
N */
N 
N 
N 
N /**
N * @defgroup Basic_IO_function Basic I/O function
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are basic input/output functions to read values from register or write values to register.
N */
N
N/**
N * @defgroup Common_register_access_function Common register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>common registers</b>.
N */
N
N/**
N * @defgroup Socket_register_access_function Socket register access functions
N * @ingroup WIZCHIP_IO_Functions
N * @brief These are functions to access <b>socket registers</b>.
N */
N 
N//------------------------------- defgroup end --------------------------------------------
N//----------------------------- W5500 Common Registers IOMAP -----------------------------
N/**
N * @ingroup Common_register_group
N * @brief Mode Register address(R/W)\n
N * @ref MR is used for S/W reset, ping block mode, PPPoE mode and etc.
N * @details Each bit of @ref MR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>RST</td> <td>Reserved</td> <td>WOL</td> <td>PB</td> <td>PPPoE</td> <td>Reserved</td> <td>FARP</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref MR_RST		 	: Reset
N * - \ref MR_WOL       		: Wake on LAN
N * - \ref MR_PB         	: Ping block
N * - \ref MR_PPPOE      	: PPPoE mode
N * - \ref MR_FARP			: Force ARP mode
N */
N#define MR                 (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Gateway IP Register address(R/W)
N * @details @ref GAR configures the default gateway address.
N */
N#define GAR                (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Subnet mask Register address(R/W)
N * @details @ref SUBR configures the subnet mask address.
N */
N#define SUBR               (_W5500_IO_BASE_ + (0x0005 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source MAC Register address(R/W)
N * @details @ref SHAR configures the source hardware address.
N */
N#define SHAR               (_W5500_IO_BASE_ + (0x0009 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Source IP Register address(R/W)
N * @details @ref SIPR configures the source IP address.
N */
N#define SIPR               (_W5500_IO_BASE_ + (0x000F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Set Interrupt low level timer register address(R/W)
N * @details @ref INTLEVEL configures the Interrupt Assert Time.
N */
N#define INTLEVEL           (_W5500_IO_BASE_ + (0x0013 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt Register(R/W)
N * @details @ref IR indicates the interrupt status. Each bit of @ref IR will be still until the bit will be written to by the host.
N * If @ref IR is not equal to x00 INTn PIN is asserted to low until it is x00\n\n
N * Each bit of @ref IR defined as follows.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>CONFLICT</td> <td>UNREACH</td> <td>PPPoE</td> <td>MP</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IR_CONFLICT : IP conflict
N * - \ref IR_UNREACH  : Destination unreachable
N * - \ref IR_PPPoE	  : PPPoE connection close
N * - \ref IR_MP		  : Magic packet
N */
N#define IR                 (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Interrupt mask register(R/W)
N * @details @ref IMR is used to mask interrupts. Each bit of @ref IMR corresponds to each bit of @ref IR.
N * When a bit of @ref IMR is and the corresponding bit of @ref IR is  an interrupt will be issued. In other words,
N * if a bit of @ref IMR is  an interrupt will not be issued even if the corresponding bit of @ref IR is \n\n
N * Each bit of @ref IMR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>IM_IR7</td> <td>IM_IR6</td> <td>IM_IR5</td> <td>IM_IR4</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> </tr>
N * </table>
N * - \ref IM_IR7 : IP Conflict Interrupt Mask
N * - \ref IM_IR6 : Destination unreachable Interrupt Mask
N * - \ref IM_IR5 : PPPoE Close Interrupt Mask
N * - \ref IM_IR4 : Magic Packet Interrupt Mask
N */
N#define IMR                (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Register(R/W)
N * @details @ref SIR indicates the interrupt status of Socket.\n
N * Each bit of @ref SIR be still until @ref Sn_IR is cleared by the host.\n
N * If @ref Sn_IR is not equal to x00 the n-th bit of @ref SIR is and INTn PIN is asserted until @ref SIR is x00 */
N#define SIR                (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Socket Interrupt Mask Register(R/W)
N * @details Each bit of @ref SIMR corresponds to each bit of @ref SIR.
N * When a bit of @ref SIMR is and the corresponding bit of @ref SIR is  Interrupt will be issued.
N * In other words, if a bit of @ref SIMR is  an interrupt will be not issued even if the corresponding bit of @ref SIR is 
N */
N#define SIMR               (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Timeout register address( 1 is 100us )(R/W)
N * @details @ref RTR configures the retransmission timeout period. The unit of timeout period is 100us and the default of @ref RTR is x07D0or 000
N * And so the default timeout period is 200ms(100us X 2000). During the time configured by @ref RTR, W5500 waits for the peer response
N * to the packet that is transmitted by \ref Sn_CR (CONNECT, DISCON, CLOSE, SEND, SEND_MAC, SEND_KEEP command).
N * If the peer does not respond within the @ref RTR time, W5500 retransmits the packet or issues timeout.
N */
N#define RTR                (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Retry count register(R/W)
N * @details @ref RCR configures the number of time of retransmission.
N * When retransmission occurs as many as ref RCR+1 Timeout interrupt is issued (@ref Sn_IR[TIMEOUT] = .
N */
N#define RCR                (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Request Timer register  in PPPoE mode(R/W)
N * @details @ref PTIMER configures the time for sending LCP echo request. The unit of time is 25ms.
N */
N#define PTIMER             (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP LCP Magic number register  in PPPoE mode(R/W)
N * @details @ref PMAGIC configures the 4bytes magic number to be used in LCP negotiation.
N */
N#define PMAGIC             (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Destination MAC Register address(R/W)
N * @details @ref PHAR configures the PPPoE server hardware address that is acquired during PPPoE connection process.
N */
N#define PHAR                (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Session Identification Register(R/W)
N * @details @ref PSID configures the PPPoE sever session ID acquired during PPPoE connection process.
N */
N#define PSID               (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PPP Maximum Segment Size(MSS) register(R/W)
N * @details @ref PMRU configures the maximum receive unit of PPPoE.
N */
N#define PMRU               (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable IP register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR indicates
N * the destination IP address & port number respectively.
N */
N#define UIPR               (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief Unreachable Port register address in UDP mode(R)
N * @details W5500 receives an ICMP packet(Destination port unreachable) when data is sent to a port number
N * which socket is not open and @ref UNREACH bit of @ref IR becomes and @ref UIPR & @ref UPORTR
N * indicates the destination IP address & port number respectively.
N */
N#define UPORTR              (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief PHY Status Register(R/W)
N * @details @ref PHYCFGR configures PHY operation mode and resets PHY. In addition, @ref PHYCFGR indicates the status of PHY such as duplex, Speed, Link.
N */
N#define PHYCFGR            (_W5500_IO_BASE_ + (0x002E << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0031 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0032 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0033 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0034 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0035 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0036 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0037 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0038 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N/**
N * @ingroup Common_register_group
N * @brief chip version register address(R)
N * @details @ref VERSIONR always indicates the W5500 version as @b 0x04.
N */
N#define VERSIONR           (_W5500_IO_BASE_ + (0x0039 << 8) + (WIZCHIP_CREG_BLOCK << 3))
N
N
N//----------------------------- W5500 Socket Registers IOMAP -----------------------------
N/**
N * @ingroup Socket_register_group
N * @brief socket Mode register(R/W)
N * @details @ref Sn_MR configures the option or protocol type of Socket n.\n\n
N * Each bit of @ref Sn_MR defined as the following.
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>MULTI/MFEN</td> <td>BCASTB</td> <td>ND/MC/MMB</td> <td>UCASTB/MIP6B</td> <td>Protocol[3]</td> <td>Protocol[2]</td> <td>Protocol[1]</td> <td>Protocol[0]</td> </tr>
N * </table>
N * - @ref Sn_MR_MULTI	: Support UDP Multicasting
N * - @ref Sn_MR_BCASTB	: Broadcast block <b>in UDP Multicasting</b>
N * - @ref Sn_MR_ND		: No Delayed Ack(TCP) flag
N * - @ref Sn_MR_MC   	: IGMP version used <b>in UDP mulitcasting</b>
N * - @ref Sn_MR_MMB    	: Multicast Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - @ref Sn_MR_UCASTB	: Unicast Block <b>in UDP Multicating</b>
N * - @ref Sn_MR_MIP6B   : IPv6 packet Blocking <b>in @ref Sn_MR_MACRAW mode</b>
N * - <b>Protocol</b>
N * <table>
N * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>Closed</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>TCP</td>   </tr>
N * 		<tr>   <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>UDP</td>   </tr>
N * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
N * </table>
N *	- @ref Sn_MR_MACRAW	: MAC LAYER RAW SOCK \n
N *  - @ref Sn_MR_UDP		: UDP
N *  - @ref Sn_MR_TCP		: TCP
N *  - @ref Sn_MR_CLOSE	: Unused socket
N *  @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR(N)           (_W5500_IO_BASE_ + (0x0000 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket command register(R/W)
N * @details This is used to set the command for Socket n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
N * After W5500 accepts the command, the @ref Sn_CR register is automatically cleared to 0x00.
N * Even though @ref Sn_CR is cleared to 0x00, the command is still being processed.\n
N * To check whether the command is completed or not, please check the @ref Sn_IR or @ref Sn_SR.
N * - @ref Sn_CR_OPEN 		: Initialize or open socket.
N * - @ref Sn_CR_LISTEN 		: Wait connection request in TCP mode(<b>Server mode</b>)
N * - @ref Sn_CR_CONNECT 	: Send connection request in TCP mode(<b>Client mode</b>)
N * - @ref Sn_CR_DISCON 		: Send closing request in TCP mode.
N * - @ref Sn_CR_CLOSE   	: Close socket.
N * - @ref Sn_CR_SEND    	: Update TX buffer pointer and send data.
N * - @ref Sn_CR_SEND_MAC	: Send data with MAC address, so without ARP process.
N * - @ref Sn_CR_SEND_KEEP 	: Send keep alive message.
N * - @ref Sn_CR_RECV		: Update RX buffer pointer and receive data.
N */
N#define Sn_CR(N)           (_W5500_IO_BASE_ + (0x0001 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket interrupt register(R)
N * @details @ref Sn_IR indicates the status of Socket Interrupt such as establishment, termination, receiving data, timeout).\n
N * When an interrupt occurs and the corresponding bit of @ref Sn_IMR is  the corresponding bit of @ref Sn_IR becomes \n
N * In order to clear the @ref Sn_IR bit, the host should write the bit to \n
N * <table>
N * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
N * 		<tr>  <td>Reserved</td> <td>Reserved</td> <td>Reserved</td> <td>SEND_OK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
N * </table>
N * - \ref Sn_IR_SENDOK : <b>SEND_OK Interrupt</b>
N * - \ref Sn_IR_TIMEOUT : <b>TIMEOUT Interrupt</b>
N * - \ref Sn_IR_RECV : <b>RECV Interrupt</b>
N * - \ref Sn_IR_DISCON : <b>DISCON Interrupt</b>
N * - \ref Sn_IR_CON : <b>CON Interrupt</b>
N */
N#define Sn_IR(N)           (_W5500_IO_BASE_ + (0x0002 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Socket status register(R)
N * @details @ref Sn_SR indicates the status of Socket n.\n
N * The status of Socket n is changed by @ref Sn_CR or some special control packet as SYN, FIN packet in TCP.
N * @par Normal status
N * - @ref SOCK_CLOSED 		: Closed
N * - @ref SOCK_INIT   		: Initiate state
N * - @ref SOCK_LISTEN    	: Listen state
N * - @ref SOCK_ESTABLISHED 	: Success to connect
N * - @ref SOCK_CLOSE_WAIT   : Closing state
N * - @ref SOCK_UDP   		: UDP socket
N * - @ref SOCK_MACRAW  		: MAC raw mode socket
N *@par Temporary status during changing the status of Socket n.
N * - @ref SOCK_SYNSENT   	: This indicates Socket n sent the connect-request packet (SYN packet) to a peer.
N * - @ref SOCK_SYNRECV    	: It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.
N * - @ref SOCK_FIN_WAIT		: Connection state
N * - @ref SOCK_CLOSING		: Closing state
N * - @ref SOCK_TIME_WAIT	: Closing state
N * - @ref SOCK_LAST_ACK 	: Closing state
N */
N#define Sn_SR(N)           (_W5500_IO_BASE_ + (0x0003 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief source port register(R/W)
N * @details @ref Sn_PORT configures the source port number of Socket n.
N * It is valid when Socket n is used in TCP/UPD mode. It should be set before OPEN command is ordered.
N */
N#define Sn_PORT(N)         (_W5500_IO_BASE_ + (0x0004 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer MAC register address(R/W)
N * @details @ref Sn_DHAR configures the destination hardware address of Socket n when using SEND_MAC command in UDP mode or
N * it indicates that it is acquired in ARP-process by CONNECT/SEND command.
N */
N#define Sn_DHAR(N)         (_W5500_IO_BASE_ + (0x0006 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer IP register address(R/W)
N * @details @ref Sn_DIPR configures or indicates the destination IP address of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In TCP client mode, it configures an IP address of TCP serverbefore CONNECT command.
N * In TCP server mode, it indicates an IP address of TCP clientafter successfully establishing connection.
N * In UDP mode, it configures an IP address of peer to be received the UDP packet by SEND or SEND_MAC command.
N */
N#define Sn_DIPR(N)         (_W5500_IO_BASE_ + (0x000C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Peer port register address(R/W)
N * @details @ref Sn_DPORT configures or indicates the destination port number of Socket n. It is valid when Socket n is used in TCP/UDP mode.
N * In TCP clientmode, it configures the listen port number of TCP serverbefore CONNECT command.
N * In TCP Servermode, it indicates the port number of TCP client after successfully establishing connection.
N * In UDP mode, it configures the port number of peer to be transmitted the UDP packet by SEND/SEND_MAC command.
N */
N#define Sn_DPORT(N)        (_W5500_IO_BASE_ + (0x0010 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Maximum Segment Size(Sn_MSSR0) register address(R/W)
N * @details @ref Sn_MSSR configures or indicates the MTU(Maximum Transfer Unit) of Socket n.
N */
N#define Sn_MSSR(N)         (_W5500_IO_BASE_ + (0x0012 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N// Reserved			         (_W5500_IO_BASE_ + (0x0014 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief IP Type of Service(TOS) Register(R/W)
N * @details @ref Sn_TOS configures the TOS(Type Of Service field in IP Header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TOS(N)          (_W5500_IO_BASE_ + (0x0015 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N/**
N * @ingroup Socket_register_group
N * @brief IP Time to live(TTL) Register(R/W)
N * @details @ref Sn_TTL configures the TTL(Time To Live field in IP header) of Socket n.
N * It is set before OPEN command.
N */
N#define Sn_TTL(N)          (_W5500_IO_BASE_ + (0x0016 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0017 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x0018 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3)) 
N// Reserved			         (_W5500_IO_BASE_ + (0x0019 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001B << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N// Reserved			         (_W5500_IO_BASE_ + (0x001D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Receive memory size register(R/W)
N * @details @ref Sn_RXBUF_SIZE configures the RX buffer block size of Socket n.
N * Socket n RX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data cannot be normally received from a peer.
N * Although Socket n RX Buffer Block size is initially configured to 2Kbytes,
N * user can re-configure its size using @ref Sn_RXBUF_SIZE. The total sum of @ref Sn_RXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data reception error is occurred.
N */
N#define Sn_RXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001E << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory size register(R/W)
N * @details @ref Sn_TXBUF_SIZE configures the TX buffer block size of Socket n. Socket n TX Buffer Block size can be configured with 1,2,4,8, and 16 Kbytes.
N * If a different size is configured, the data cant be normally transmitted to a peer.
N * Although Socket n TX Buffer Block size is initially configured to 2Kbytes,
N * user can be re-configure its size using @ref Sn_TXBUF_SIZE. The total sum of @ref Sn_TXBUF_SIZE can not be exceed 16Kbytes.
N * When exceeded, the data transmission error is occurred.
N */
N#define Sn_TXBUF_SIZE(N)   (_W5500_IO_BASE_ + (0x001F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit free memory size register(R)
N * @details @ref Sn_TX_FSR indicates the free size of Socket n TX Buffer Block. It is initialized to the configured size by @ref Sn_TXBUF_SIZE.
N * Data bigger than @ref Sn_TX_FSR should not be saved in the Socket n TX Buffer because the bigger data overwrites the previous saved data not yet sent.
N * Therefore, check before saving the data to the Socket n TX Buffer, and if data is equal or smaller than its checked size,
N * transmit the data with SEND/SEND_MAC command after saving the data in Socket n TX buffer. But, if data is bigger than its checked size,
N * transmit the data after dividing into the checked size and saving in the Socket n TX buffer.
N */
N#define Sn_TX_FSR(N)       (_W5500_IO_BASE_ + (0x0020 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory read pointer register address(R)
N * @details @ref Sn_TX_RD is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.
N * After its initialization, it is auto-increased by SEND command.
N * SEND command transmits the saved data from the current @ref Sn_TX_RD to the @ref Sn_TX_WR in the Socket n TX Buffer.
N * After transmitting the saved data, the SEND command increases the @ref Sn_TX_RD as same as the @ref Sn_TX_WR.
N * If its increment value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_TX_RD(N)        (_W5500_IO_BASE_ + (0x0022 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Transmit memory write pointer register address(R/W)
N * @details @ref Sn_TX_WR is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001, it is re-initialized while connecting with TCP.\n
N * It should be read or be updated like as follows.\n
N * 1. Read the starting address for saving the transmitting data.\n
N * 2. Save the transmitting data from the starting address of Socket n TX buffer.\n
N * 3. After saving the transmitting data, update @ref Sn_TX_WR to the increased value as many as transmitting data size.
N * If the increment value exceeds the maximum value 0xFFFF(greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.\n
N * 4. Transmit the saved data in Socket n TX Buffer by using SEND/SEND command
N */
N#define Sn_TX_WR(N)        (_W5500_IO_BASE_ + (0x0024 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Received data size register(R)
N * @details @ref Sn_RX_RSR indicates the data size received and saved in Socket n RX Buffer.
N * @ref Sn_RX_RSR does not exceed the @ref Sn_RXBUF_SIZE and is calculated as the difference between
N * Socket n RX Write Pointer (@ref Sn_RX_WR)and Socket n RX Read Pointer (@ref Sn_RX_RD)
N */
N#define Sn_RX_RSR(N)       (_W5500_IO_BASE_ + (0x0026 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Read point of Receive memory(R/W)
N * @details @ref Sn_RX_RD is initialized by OPEN command. Make sure to be read or updated as follows.\n
N * 1. Read the starting save address of the received data.\n
N * 2. Read data from the starting address of Socket n RX Buffer.\n
N * 3. After reading the received data, Update @ref Sn_RX_RD to the increased value as many as the reading size.
N * If the increment value exceeds the maximum value 0xFFFF, that is, is greater than 0x10000 and the carry bit occurs,
N * update with the lower 16bits value ignored the carry bit.\n
N * 4. Order RECV command is for notifying the updated @ref Sn_RX_RD to W5500.
N */
N#define Sn_RX_RD(N)        (_W5500_IO_BASE_ + (0x0028 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Write point of Receive memory(R)
N * @details @ref Sn_RX_WR is initialized by OPEN command and it is auto-increased by the data reception.
N * If the increased value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
N * then the carry bit is ignored and will automatically update with the lower 16bits value.
N */
N#define Sn_RX_WR(N)        (_W5500_IO_BASE_ + (0x002A << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief socket interrupt mask register(R)
N * @details @ref Sn_IMR masks the interrupt of Socket n.
N * Each bit corresponds to each bit of @ref Sn_IR. When a Socket n Interrupt is occurred and the corresponding bit of @ref Sn_IMR is 
N * the corresponding bit of @ref Sn_IR becomes  When both the corresponding bit of @ref Sn_IMR and @ref Sn_IR are and the n-th bit of @ref IR is 
N * Host is interrupted by asserted INTn PIN to low.
N */
N#define Sn_IMR(N)          (_W5500_IO_BASE_ + (0x002C << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Fragment field value in IP header register(R/W)
N * @details @ref Sn_FRAG configures the FRAG(Fragment field in IP header).
N */
N#define Sn_FRAG(N)         (_W5500_IO_BASE_ + (0x002D << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N/**
N * @ingroup Socket_register_group
N * @brief Keep Alive Timer register(R/W)
N * @details @ref Sn_KPALVTR configures the transmitting timer of KEEP ALIVE(KA)packet of SOCKETn. It is valid only in TCP mode,
N * and ignored in other modes. The time unit is 5s.
N * KA packet is transmittable after @ref Sn_SR is changed to SOCK_ESTABLISHED and after the data is transmitted or received to/from a peer at least once.
N * In case of '@ref Sn_KPALVTR > 0', W5500 automatically transmits KA packet after time-period for checking the TCP connection (Auto-keepalive-process).
N * In case of '@ref Sn_KPALVTR = 0', Auto-keep-alive-process will not operate,
N * and KA packet can be transmitted by SEND_KEEP command by the host (Manual-keep-alive-process).
N * Manual-keep-alive-process is ignored in case of '@ref Sn_KPALVTR > 0'.
N */
N#define Sn_KPALVTR(N)      (_W5500_IO_BASE_ + (0x002F << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N//#define Sn_TSR(N)          (_W5500_IO_BASE_ + (0x0030 << 8) + (WIZCHIP_SREG_BLOCK(N) << 3))
N
N
N//----------------------------- W5500 Register values  -----------------------------
N
N/* MODE register values */
N/**
N * @brief Reset
N * @details If this bit is  All internal registers will be initialized. It will be automatically cleared as after S/W reset.
N */
N#define MR_RST                       0x80
N
N/**
N * @brief Wake on LAN
N * @details 0 : Disable WOL mode\n
N * 1 : Enable WOL mode\n
N * If WOL mode is enabled and the received magic packet over UDP has been normally processed, the Interrupt PIN (INTn) asserts to low.
N * When using WOL mode, the UDP Socket should be opened with any source port number. (Refer to Socket n Mode Register (@ref Sn_MR) for opening Socket.)
N * @note The magic packet over UDP supported by W5500 consists of 6 bytes synchronization stream (xFFFFFFFFFFFF and
N * 16 times Target MAC address stream in UDP payload. The options such like password are ignored. You can use any UDP source port number for WOL mode.
N */
N#define MR_WOL                       0x20
N
N/**
N * @brief Ping block
N * @details 0 : Disable Ping block\n
N * 1 : Enable Ping block\n
N * If the bit is  it blocks the response to a ping request.
N */
N#define MR_PB                        0x10
N
N/**
N * @brief Enable PPPoE
N * @details 0 : DisablePPPoE mode\n
N * 1 : EnablePPPoE mode\n
N * If you use ADSL, this bit should be 
N */
N#define MR_PPPOE                     0x08
N
N/**
N * @brief Enable UDP_FORCE_ARP CHECHK
N * @details 0 : Disable Force ARP mode\n
N * 1 : Enable Force ARP mode\n
N * In Force ARP mode, It forces on sending ARP Request whenever data is sent.
N */
N#define MR_FARP                      0x02
N
N/* IR register values */
N/**
N * @brief Check IP conflict.
N * @details Bit is set as when own source IP address is same with the sender IP address in the received ARP request.
N */
N#define IR_CONFLICT                  0x80
N
N/**
N * @brief Get the destination unreachable message in UDP sending.
N * @details When receiving the ICMP (Destination port unreachable) packet, this bit is set as 
N * When this bit is  Destination Information such as IP address and Port number may be checked with the corresponding @ref UIPR & @ref UPORTR.
N */
N#define IR_UNREACH                   0x40
N
N/**
N * @brief Get the PPPoE close message.
N * @details When PPPoE is disconnected during PPPoE mode, this bit is set.
N */
N#define IR_PPPoE                     0x20
N
N/**
N * @brief Get the magic packet interrupt.
N * @details When WOL mode is enabled and receives the magic packet over UDP, this bit is set.
N */
N#define IR_MP                        0x10
N
N
N/* PHYCFGR register value */
N#define PHYCFGR_RST                  ~(1<<7)  //< For PHY reset, must operate AND mask.
N#define PHYCFGR_OPMD                 (1<<6)   // Configre PHY with OPMDC value
N#define PHYCFGR_OPMDC_ALLA           (7<<3)
N#define PHYCFGR_OPMDC_PDOWN          (6<<3)
N#define PHYCFGR_OPMDC_NA             (5<<3)
N#define PHYCFGR_OPMDC_100FA          (4<<3)
N#define PHYCFGR_OPMDC_100F           (3<<3)
N#define PHYCFGR_OPMDC_100H           (2<<3)
N#define PHYCFGR_OPMDC_10F            (1<<3)
N#define PHYCFGR_OPMDC_10H            (0<<3)           
N#define PHYCFGR_DPX_FULL             (1<<2)
N#define PHYCFGR_DPX_HALF             (0<<2)
N#define PHYCFGR_SPD_100              (1<<1)
N#define PHYCFGR_SPD_10               (0<<1)
N#define PHYCFGR_LNK_ON               (1<<0)
N#define PHYCFGR_LNK_OFF              (0<<0)
N
N/* IMR register values */
N/**
N * @brief IP Conflict Interrupt Mask.
N * @details 0: Disable IP Conflict Interrupt\n
N * 1: Enable IP Conflict Interrupt
N */
N#define IM_IR7                  	 0x80
N
N/**
N * @brief Destination unreachable Interrupt Mask.
N * @details 0: Disable Destination unreachable Interrupt\n
N * 1: Enable Destination unreachable Interrupt
N */
N#define IM_IR6                  	 0x40
N
N/**
N * @brief PPPoE Close Interrupt Mask.
N * @details 0: Disable PPPoE Close Interrupt\n
N * 1: Enable PPPoE Close Interrupt
N */
N#define IM_IR5                  	 0x20
N
N/**
N * @brief Magic Packet Interrupt Mask.
N * @details 0: Disable Magic Packet Interrupt\n
N * 1: Enable Magic Packet Interrupt
N */
N#define IM_IR4                  	 0x10
N
N/* Sn_MR Default values */
N/**
N * @brief Support UDP Multicasting
N * @details 0 : disable Multicasting\n
N * 1 : enable Multicasting\n
N * This bit is applied only during UDP mode(P[3:0] = 010.\n
N * To use multicasting, @ref Sn_DIPR & @ref Sn_DPORT should be respectively configured with the multicast group IP address & port number
N * before Socket n is opened by OPEN command of @ref Sn_CR.
N */
N#define Sn_MR_MULTI                  0x80
N
N/**
N * @brief Broadcast block in UDP Multicasting.
N * @details 0 : disable Broadcast Blocking\n
N * 1 : enable Broadcast Blocking\n
N * This bit blocks to receive broadcasting packet during UDP mode(P[3:0] = 010.\m
N * In addition, This bit does when MACRAW mode(P[3:0] = 100
N */
N#define Sn_MR_BCASTB                 0x40
N
N/**
N * @brief No Delayed Ack(TCP), Multicast flag
N * @details 0 : Disable No Delayed ACK option\n
N * 1 : Enable No Delayed ACK option\n
N * This bit is applied only during TCP mode (P[3:0] = 001.\n
N * When this bit is  It sends the ACK packet without delay as soon as a Data packet is received from a peer.\n
N * When this bit is  It sends the ACK packet after waiting for the timeout time configured by @ref RTR.
N */
N#define Sn_MR_ND                     0x20
N
N/**
N * @brief Unicast Block in UDP Multicasting
N * @details 0 : disable Unicast Blocking\n
N * 1 : enable Unicast Blocking\n
N * This bit blocks receiving the unicast packet during UDP mode(P[3:0] = 010 and MULTI = 
N */
N#define Sn_MR_UCASTB                 0x10
N
N/**
N * @brief MAC LAYER RAW SOCK
N * @details This configures the protocol mode of Socket n.
N * @note MACRAW mode should be only used in Socket 0.
N */
N#define Sn_MR_MACRAW                 0x04
N
N//#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
N
N/**
N * @brief UDP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_UDP                    0x02
N
N/**
N * @brief TCP
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_TCP                    0x01
N
N/**
N * @brief Unused socket
N * @details This configures the protocol mode of Socket n.
N */
N#define Sn_MR_CLOSE                  0x00
N
N/* Sn_MR values used with Sn_MR_MACRAW */
N/**
N * @brief MAC filter enable in @ref Sn_MR_MACRAW mode
N * @details 0 : disable MAC Filtering\n
N * 1 : enable MAC Filtering\n
N * This bit is applied only during MACRAW mode(P[3:0] = 100.\n
N * When set as  W5500 can only receive broadcasting packet or packet sent to itself.
N * When this bit is  W5500 can receive all packets on Ethernet.
N * If user wants to implement Hybrid TCP/IP stack,
N * it is recommended that this bit is set as for reducing host overhead to process the all received packets.
N */
N#define Sn_MR_MFEN                   Sn_MR_MULTI
N
N/**
N * @brief Multicast Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : using IGMP version 2\n
N * 1 : using IGMP version 1\n
N * This bit is applied only during UDP mode(P[3:0] = 010 and MULTI = 
N * It configures the version for IGMP messages (Join/Leave/Report).
N */
N#define Sn_MR_MMB                    Sn_MR_ND
N
N/**
N * @brief IPv6 packet Blocking in @ref Sn_MR_MACRAW mode
N * @details 0 : disable IPv6 Blocking\n
N * 1 : enable IPv6 Blocking\n
N * This bit is applied only during MACRAW mode (P[3:0] = 100. It blocks to receiving the IPv6 packet.
N */
N#define Sn_MR_MIP6B                  Sn_MR_UCASTB
N
N/* Sn_MR value used with Sn_MR_UDP & Sn_MR_MULTI */
N/**
N * @brief IGMP version used in UDP mulitcasting
N * @details 0 : disable Multicast Blocking\n
N * 1 : enable Multicast Blocking\n
N * This bit is applied only when MACRAW mode(P[3:0] = 100. It blocks to receive the packet with multicast MAC address.
N */
N#define Sn_MR_MC                     Sn_MR_ND
N
N/* Sn_MR alternate values */
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_STREAM                  Sn_MR_TCP
N
N/**
N * @brief For Berkeley Socket API
N */
N#define SOCK_DGRAM                   Sn_MR_UDP
N
N
N/* Sn_CR values */
N/**
N * @brief Initialize or open socket
N * @details Socket n is initialized and opened according to the protocol selected in Sn_MR(P3:P0).
N * The table below shows the value of @ref Sn_SR corresponding to @ref Sn_MR.\n
N * <table>
N *   <tr>  <td>\b Sn_MR (P[3:0])</td> <td>\b Sn_SR</td>            		 </tr>
N *   <tr>  <td>Sn_MR_CLOSE  (000</td> <td></td>         	   		 </tr>
N *   <tr>  <td>Sn_MR_TCP  (001</td> <td>SOCK_INIT (0x13)</td>  		 </tr>
N *   <tr>  <td>Sn_MR_UDP  (010</td>  <td>SOCK_UDP (0x22)</td>  		 </tr>
N *   <tr>  <td>S0_MR_MACRAW  (100</td>  <td>SOCK_MACRAW (0x02)</td>  </tr>
N * </table>
N */
N#define Sn_CR_OPEN                   0x01
N
N/**
N * @brief Wait connection request in TCP mode(Server mode)
N * @details This is valid only in TCP mode (Sn_MR(P3:P0) = Sn_MR_TCP).
N * In this mode, Socket n operates as a TCP serverand waits for  connection-request (SYN packet) from any TCP client
N * The @ref Sn_SR changes the state from SOCK_INIT to SOCKET_LISTEN.
N * When a TCP clientconnection request is successfully established,
N * the @ref Sn_SR changes from SOCK_LISTEN to SOCK_ESTABLISHED and the Sn_IR(0) becomes 
N * But when a TCP clientconnection request is failed, Sn_IR(3) becomes and the status of @ref Sn_SR changes to SOCK_CLOSED.
N */
N#define Sn_CR_LISTEN                 0x02
N
N/**
N * @brief Send connection request in TCP mode(Client mode)
N * @details  To connect, a connect-request (SYN packet) is sent to b>TCP server</b>configured by @ref Sn_DIPR & Sn_DPORT(destination address & port).
N * If the connect-request is successful, the @ref Sn_SR is changed to @ref SOCK_ESTABLISHED and the Sn_IR(0) becomes \n\n
N * The connect-request fails in the following three cases.\n
N * 1. When a @b ARPTO occurs (@ref Sn_IR[3] =  ) because destination hardware address is not acquired through the ARP-process.\n
N * 2. When a @b SYN/ACK packet is not received and @b TCPTO (Sn_IR(3) =  )\n
N * 3. When a @b RST packet is received instead of a @b SYN/ACK packet. In these cases, @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note This is valid only in TCP mode and operates when Socket n acts as b>TCP client</b>
N */
N#define Sn_CR_CONNECT                0x04
N
N/**
N * @brief Send closing request in TCP mode
N * @details Regardless of b>TCP server</b>or b>TCP client</b> the DISCON command processes the disconnect-process (b>Active close</b>or b>Passive close</b>.\n
N * @par Active close
N * it transmits disconnect-request(FIN packet) to the connected peer\n
N * @par Passive close
N * When FIN packet is received from peer, a FIN packet is replied back to the peer.\n
N * @details When the disconnect-process is successful (that is, FIN/ACK packet is received successfully), @ref Sn_SR is changed to @ref SOCK_CLOSED.\n
N * Otherwise, TCPTO occurs (Sn_IR(3)=)= and then @ref Sn_SR is changed to @ref SOCK_CLOSED.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_DISCON                 0x08
N
N/**
N * @brief Close socket
N * @details Sn_SR is changed to @ref SOCK_CLOSED.
N */
N#define Sn_CR_CLOSE                  0x10
N
N/**
N * @brief Update TX buffer pointer and send data
N * @details SEND transmits all the data in the Socket n TX buffer.\n
N * For more details, please refer to Socket n TX Free Size Register (@ref Sn_TX_FSR), Socket n,
N * TX Write Pointer Register(@ref Sn_TX_WR), and Socket n TX Read Pointer Register(@ref Sn_TX_RD).
N */
N#define Sn_CR_SEND                   0x20
N
N/**
N * @brief Send data with MAC address, so without ARP process
N * @details The basic operation is same as SEND.\n
N * Normally SEND transmits data after destination hardware address is acquired by the automatic ARP-process(Address Resolution Protocol).\n
N * But SEND_MAC transmits data without the automatic ARP-process.\n
N * In this case, the destination hardware address is acquired from @ref Sn_DHAR configured by host, instead of APR-process.
N * @note Valid only in UDP mode.
N */
N#define Sn_CR_SEND_MAC               0x21
N
N/**
N * @brief Send keep alive message
N * @details It checks the connection status by sending 1byte keep-alive packet.\n
N * If the peer can not respond to the keep-alive packet during timeout time, the connection is terminated and the timeout interrupt will occur.
N * @note Valid only in TCP mode.
N */
N#define Sn_CR_SEND_KEEP              0x22
N
N/**
N * @brief Update RX buffer pointer and receive data
N * @details RECV completes the processing of the received data in Socket n RX Buffer by using a RX read pointer register (@ref Sn_RX_RD).\n
N * For more details, refer to Socket n RX Received Size Register (@ref Sn_RX_RSR), Socket n RX Write Pointer Register (@ref Sn_RX_WR),
N * and Socket n RX Read Pointer Register (@ref Sn_RX_RD).
N */
N#define Sn_CR_RECV                   0x40
N
N/* Sn_IR values */
N/**
N * @brief SEND_OK Interrupt
N * @details This is issued when SEND command is completed.
N */
N#define Sn_IR_SENDOK                 0x10
N
N/**
N * @brief TIMEOUT Interrupt
N * @details This is issued when ARPTO or TCPTO occurs.
N */
N#define Sn_IR_TIMEOUT                0x08
N
N/**
N * @brief RECV Interrupt
N * @details This is issued whenever data is received from a peer.
N */
N#define Sn_IR_RECV                   0x04
N
N/**
N * @brief DISCON Interrupt
N * @details This is issued when FIN or FIN/ACK packet is received from a peer.
N */
N#define Sn_IR_DISCON                 0x02
N
N/**
N * @brief CON Interrupt
N * @details This is issued one time when the connection with peer is successful and then @ref Sn_SR is changed to @ref SOCK_ESTABLISHED.
N */
N#define Sn_IR_CON                    0x01
N
N/* Sn_SR values */
N/**
N * @brief Closed
N * @details This indicates that Socket n is released.\N
N * When DICON, CLOSE command is ordered, or when a timeout occurs, it is changed to @ref SOCK_CLOSED regardless of previous status.
N */
N#define SOCK_CLOSED                  0x00
N
N/**
N * @brief Initiate state
N * @details This indicates Socket n is opened with TCP mode.\N
N * It is changed to @ref SOCK_INIT when Sn_MR(P[3:0]) = 001and OPEN command is ordered.\N
N * After @ref SOCK_INIT, user can use LISTEN /CONNECT command.
N */
N#define SOCK_INIT                    0x13
N
N/**
N * @brief Listen state
N * @details This indicates Socket n is operating as b>TCP server</b>mode and waiting for connection-request (SYN packet) from a peer (b>TCP client</b>.\n
N * It will change to @ref SOCK_ESTALBLISHED when the connection-request is successfully accepted.\n
N * Otherwise it will change to @ref SOCK_CLOSED after TCPTO occurred (Sn_IR(TIMEOUT) = .
N */
N#define SOCK_LISTEN                  0x14
N
N/**
N * @brief Connection state
N * @details This indicates Socket n sent the connect-request packet (SYN packet) to a peer.\n
N * It is temporarily shown when @ref Sn_SR is changed from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by CONNECT command.\n
N * If connect-accept(SYN/ACK packet) is received from the peer at SOCK_SYNSENT, it changes to @ref SOCK_ESTABLISHED.\n
N * Otherwise, it changes to @ref SOCK_CLOSED after TCPTO (@ref Sn_IR[TIMEOUT] =  is occurred.
N */
N#define SOCK_SYNSENT                 0x15
N
N/**
N * @brief Connection state
N * @details It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.\n
N * If socket n sends the response (SYN/ACK  packet) to the peer successfully,  it changes to @ref SOCK_ESTABLISHED. \n
N * If not, it changes to @ref SOCK_CLOSED after timeout occurs (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_SYNRECV                 0x16
N
N/**
N * @brief Success to connect
N * @details This indicates the status of the connection of Socket n.\n
N * It changes to @ref SOCK_ESTABLISHED when the b>TCP SERVER</b>processed the SYN packet from the b>TCP CLIENT</b>during @ref SOCK_LISTEN, or
N * when the CONNECT command is successful.\n
N * During @ref SOCK_ESTABLISHED, DATA packet can be transferred using SEND or RECV command.
N */
N#define SOCK_ESTABLISHED             0x17
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_FIN_WAIT                0x18
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_CLOSING                 0x1A
N
N/**
N * @brief Closing state
N * @details These indicate Socket n is closing.\n
N * These are shown in disconnect-process such as active-close and passive-close.\n
N * When Disconnect-process is successfully completed, or when timeout occurs, these change to @ref SOCK_CLOSED.
N */
N#define SOCK_TIME_WAIT               0x1B
N
N/**
N * @brief Closing state
N * @details This indicates Socket n received the disconnect-request (FIN packet) from the connected peer.\n
N * This is half-closing status, and data can be transferred.\n
N * For full-closing, DISCON command is used. But For just-closing, CLOSE command is used.
N */
N#define SOCK_CLOSE_WAIT              0x1C
N
N/**
N * @brief Closing state
N * @details This indicates Socket n is waiting for the response (FIN/ACK packet) to the disconnect-request (FIN packet) by passive-close.\n
N * It changes to @ref SOCK_CLOSED when Socket n received the response successfully, or when timeout occurs  (@ref Sn_IR[TIMEOUT] = .
N */
N#define SOCK_LAST_ACK                0x1D
N
N/**
N * @brief UDP socket
N * @details This indicates Socket n is opened in UDP mode(Sn_MR(P[3:0]) = 010.\n
N * It changes to SOCK_UPD when Sn_MR(P[3:0]) = 010 and OPEN command is ordered.\n
N * Unlike TCP mode, data can be transfered without the connection-process.
N */
N#define SOCK_UDP                     0x22
N
N//#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
N
N/**
N * @brief MAC raw mode socket
N * @details This indicates Socket 0 is opened in MACRAW mode (S0_MR(P[3:0]) = 100and is valid only in Socket 0.\n
N * It changes to SOCK_MACRAW when S0_MR(P[3:0] = 100and OPEN command is ordered.\n
N * Like UDP mode socket, MACRAW mode Socket 0 can transfer a MAC packet (Ethernet frame) without the connection-process.
N */
N#define SOCK_MACRAW                  0x42
N
N//#define SOCK_PPPOE                   0x5F
N
N/* IP PROTOCOL */
N#define IPPROTO_IP                   0        //< Dummy for IP 
N#define IPPROTO_ICMP                 1        //< Control message protocol
N#define IPPROTO_IGMP                 2        //< Internet group management protocol
N#define IPPROTO_GGP                  3        //< Gateway^2 (deprecated)
N#define IPPROTO_TCP                  6        //< TCP
N#define IPPROTO_PUP                  12       //< PUP
N#define IPPROTO_UDP                  17       //< UDP
N#define IPPROTO_IDP                  22       //< XNS idp
N#define IPPROTO_ND                   77       //< UNOFFICIAL net disk protocol
N#define IPPROTO_RAW                  255      //< Raw IP packet
N
N
N/**
N * @brief Enter a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n \n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt.\n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * \sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * \sa WIZCHIP_CRITICAL_EXIT()
N */
N#define WIZCHIP_CRITICAL_ENTER()    WIZCHIP.CRIS._enter()
N
N/**
N * @brief Exit a critical section
N *
N * @details It is provided to protect your shared code which are executed without distribution. \n\n
N *
N * In non-OS environment, It can be just implemented by disabling whole interrupt. \n
N * In OS environment, You can replace it to critical section api supported by OS.
N *
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_ENTER()
N */
N#define WIZCHIP_CRITICAL_EXIT()     WIZCHIP.CRIS._exit()
N
N
N
N////////////////////////
N// Basic I/O Function //
N////////////////////////
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads 1 byte value from a register.
N * @param AddrSel Register address
N * @return The value of register
N */
Nuint8_t  WIZCHIP_READ (uint32_t AddrSel);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes 1 byte value to a register.
N * @param AddrSel Register address
N * @param wb Write data
N * @return void
N */
Nvoid     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
N
N/**
N * @ingroup Basic_IO_function
N * @brief It reads sequence data from registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to read data
N * @param len Data length
N */
Nvoid     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It writes sequence data to registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to write data
N * @param len Data length
N */
Nvoid     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
N
N/////////////////////////////////
N// Common Register I/O function //
N/////////////////////////////////
N/**
N * @ingroup Common_register_access_function
N * @brief Set Mode Register
N * @param (uint8_t)mr The value to be set.
N * @sa getMR()
N */
N#define setMR(mr) \
N	WIZCHIP_WRITE(MR,mr)
X#define setMR(mr) 	WIZCHIP_WRITE(MR,mr)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get Mode Register
N * @return uint8_t. The value of Mode register.
N * @sa setMR()
N */
N#define getMR() \
N		WIZCHIP_READ(MR)
X#define getMR() 		WIZCHIP_READ(MR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set gateway IP address
N * @param (uint8_t*)gar Pointer variable to set gateway IP address. It should be allocated 4 bytes.
N * @sa getGAR()
N */
N#define setGAR(gar) \
N		WIZCHIP_WRITE_BUF(GAR,gar,4)
X#define setGAR(gar) 		WIZCHIP_WRITE_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get gateway IP address
N * @param (uint8_t*)gar Pointer variable to get gateway IP address. It should be allocated 4 bytes.
N * @sa setGAR()
N */
N#define getGAR(gar) \
N		WIZCHIP_READ_BUF(GAR,gar,4)
X#define getGAR(gar) 		WIZCHIP_READ_BUF(GAR,gar,4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set subnet mask address
N * @param (uint8_t*)subr Pointer variable to set subnet mask address. It should be allocated 4 bytes.
N * @sa getSUBR()
N */
N#define setSUBR(subr) \
N		WIZCHIP_WRITE_BUF(SUBR, subr,4)
X#define setSUBR(subr) 		WIZCHIP_WRITE_BUF(SUBR, subr,4)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get subnet mask address
N * @param (uint8_t*)subr Pointer variable to get subnet mask address. It should be allocated 4 bytes.
N * @sa setSUBR()
N */
N#define getSUBR(subr) \
N		WIZCHIP_READ_BUF(SUBR, subr, 4)
X#define getSUBR(subr) 		WIZCHIP_READ_BUF(SUBR, subr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local MAC address
N * @param (uint8_t*)shar Pointer variable to set local MAC address. It should be allocated 6 bytes.
N * @sa getSHAR()
N */
N#define setSHAR(shar) \
N		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
X#define setSHAR(shar) 		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local MAC address
N * @param (uint8_t*)shar Pointer variable to get local MAC address. It should be allocated 6 bytes.
N * @sa setSHAR()
N */
N#define getSHAR(shar) \
N		WIZCHIP_READ_BUF(SHAR, shar, 6)
X#define getSHAR(shar) 		WIZCHIP_READ_BUF(SHAR, shar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set local IP address
N * @param (uint8_t*)sipr Pointer variable to set local IP address. It should be allocated 4 bytes.
N * @sa getSIPR()
N */
N#define setSIPR(sipr) \
N		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
X#define setSIPR(sipr) 		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)sipr Pointer variable to get local IP address. It should be allocated 4 bytes.
N * @sa setSIPR()
N */
N#define getSIPR(sipr) \
N		WIZCHIP_READ_BUF(SIPR, sipr, 4)
X#define getSIPR(sipr) 		WIZCHIP_READ_BUF(SIPR, sipr, 4)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set INTLEVEL register
N * @param (uint16_t)intlevel Value to set @ref INTLEVEL register.
N * @sa getINTLEVEL()
N */
N#define setINTLEVEL(intlevel)  {\
N		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); \
N	}
X#define setINTLEVEL(intlevel)  {		WIZCHIP_WRITE(INTLEVEL,   (uint8_t)(intlevel >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(INTLEVEL,1), (uint8_t) intlevel); 	}
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get INTLEVEL register
N * @return uint16_t. Value of @ref INTLEVEL register.
N * @sa setINTLEVEL()
N */
N#define getINTLEVEL() \
N		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
X#define getINTLEVEL() 		((WIZCHIP_READ(INTLEVEL) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(INTLEVEL,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IR register
N * @param (uint8_t)ir Value to set @ref IR register.
N * @sa getIR()
N */
N#define setIR(ir) \
N		WIZCHIP_WRITE(IR, (ir & 0xF0))
X#define setIR(ir) 		WIZCHIP_WRITE(IR, (ir & 0xF0))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IR register
N * @return uint8_t. Value of @ref IR register.
N * @sa setIR()
N */
N#define getIR() \
N		(WIZCHIP_READ(IR) & 0xF0)
X#define getIR() 		(WIZCHIP_READ(IR) & 0xF0)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref IMR register
N * @param (uint8_t)imr Value to set @ref IMR register.
N * @sa getIMR()
N */
N#define setIMR(imr) \
N		WIZCHIP_WRITE(IMR, imr)
X#define setIMR(imr) 		WIZCHIP_WRITE(IMR, imr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref IMR register
N * @return uint8_t. Value of @ref IMR register.
N * @sa setIMR()
N */
N#define getIMR() \
N		WIZCHIP_READ(IMR)
X#define getIMR() 		WIZCHIP_READ(IMR)
N
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIR register
N * @param (uint8_t)sir Value to set @ref SIR register.
N * @sa getSIR()
N */
N#define setSIR(sir) \
N		WIZCHIP_WRITE(SIR, sir)
X#define setSIR(sir) 		WIZCHIP_WRITE(SIR, sir)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIR register
N * @return uint8_t. Value of @ref SIR register.
N * @sa setSIR()
N */
N#define getSIR() \
N		WIZCHIP_READ(SIR)
X#define getSIR() 		WIZCHIP_READ(SIR)
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref SIMR register
N * @param (uint8_t)simr Value to set @ref SIMR register.
N * @sa getSIMR()
N */
N#define setSIMR(simr) \
N		WIZCHIP_WRITE(SIMR, simr)
X#define setSIMR(simr) 		WIZCHIP_WRITE(SIMR, simr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref SIMR register
N * @return uint8_t. Value of @ref SIMR register.
N * @sa setSIMR()
N */
N#define getSIMR() \
N		WIZCHIP_READ(SIMR)
X#define getSIMR() 		WIZCHIP_READ(SIMR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RTR register
N * @param (uint16_t)rtr Value to set @ref RTR register.
N * @sa getRTR()
N */
N#define setRTR(rtr)   {\
N		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); \
N	}
X#define setRTR(rtr)   {		WIZCHIP_WRITE(RTR,   (uint8_t)(rtr >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(RTR,1), (uint8_t) rtr); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RTR register
N * @return uint16_t. Value of @ref RTR register.
N * @sa setRTR()
N */
N#define getRTR() \
N		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
X#define getRTR() 		((WIZCHIP_READ(RTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(RTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref RCR register
N * @param (uint8_t)rcr Value to set @ref RCR register.
N * @sa getRCR()
N */
N#define setRCR(rcr) \
N		WIZCHIP_WRITE(RCR, rcr)
X#define setRCR(rcr) 		WIZCHIP_WRITE(RCR, rcr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref RCR register
N * @return uint8_t. Value of @ref RCR register.
N * @sa setRCR()
N */
N#define getRCR() \
N		WIZCHIP_READ(RCR)
X#define getRCR() 		WIZCHIP_READ(RCR)
N
N//================================================== test done ===========================================================
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PTIMER register
N * @param (uint8_t)ptimer Value to set @ref PTIMER register.
N * @sa getPTIMER()
N */
N#define setPTIMER(ptimer) \
N		WIZCHIP_WRITE(PTIMER, ptimer)
X#define setPTIMER(ptimer) 		WIZCHIP_WRITE(PTIMER, ptimer)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PTIMER register
N * @return uint8_t. Value of @ref PTIMER register.
N * @sa setPTIMER()
N */
N#define getPTIMER() \
N		WIZCHIP_READ(PTIMER)
X#define getPTIMER() 		WIZCHIP_READ(PTIMER)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMAGIC register
N * @param (uint8_t)pmagic Value to set @ref PMAGIC register.
N * @sa getPMAGIC()
N */
N#define setPMAGIC(pmagic) \
N		WIZCHIP_WRITE(PMAGIC, pmagic)
X#define setPMAGIC(pmagic) 		WIZCHIP_WRITE(PMAGIC, pmagic)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMAGIC register
N * @return uint8_t. Value of @ref PMAGIC register.
N * @sa setPMAGIC()
N */
N#define getPMAGIC() \
N		WIZCHIP_READ(PMAGIC)
X#define getPMAGIC() 		WIZCHIP_READ(PMAGIC)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set PHAR address
N * @param (uint8_t*)phar Pointer variable to set PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa getPHAR()
N */
N#define setPHAR(phar) \
N		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
X#define setPHAR(phar) 		WIZCHIP_WRITE_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get local IP address
N * @param (uint8_t*)phar Pointer variable to PPP destination MAC register address. It should be allocated 6 bytes.
N * @sa setPHAR()
N */
N#define getPHAR(phar) \
N		WIZCHIP_READ_BUF(PHAR, phar, 6)
X#define getPHAR(phar) 		WIZCHIP_READ_BUF(PHAR, phar, 6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PSID register
N * @param (uint16_t)psid Value to set @ref PSID register.
N * @sa getPSID()
N */
N#define setPSID(psid)  {\
N		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); \
N	}
X#define setPSID(psid)  {		WIZCHIP_WRITE(PSID,   (uint8_t)(psid >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PSID,1), (uint8_t) psid); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PSID register
N * @return uint16_t. Value of @ref PSID register.
N * @sa setPSID()
N */
N//uint16_t getPSID(void);
N#define getPSID() \
N		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
X#define getPSID() 		((WIZCHIP_READ(PSID) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PSID,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PMRU register
N * @param (uint16_t)pmru Value to set @ref PMRU register.
N * @sa getPMRU()
N */
N#define setPMRU(pmru) { \
N		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); \
N	}
X#define setPMRU(pmru) { 		WIZCHIP_WRITE(PMRU,   (uint8_t)(pmru>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(PMRU,1), (uint8_t) pmru); 	}
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PMRU register
N * @return uint16_t. Value of @ref PMRU register.
N * @sa setPMRU()
N */
N#define getPMRU() \
N		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
X#define getPMRU() 		((WIZCHIP_READ(PMRU) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PMRU,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get unreachable IP address
N * @param (uint8_t*)uipr Pointer variable to get unreachable IP address. It should be allocated 4 bytes.
N */
N#define getUIPR(uipr) \
N		WIZCHIP_READ_BUF(UIPR,uipr,6)
X#define getUIPR(uipr) 		WIZCHIP_READ_BUF(UIPR,uipr,6)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref UPORTR register
N * @return uint16_t. Value of @ref UPORTR register.
N */
N#define getUPORTR() \
N	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
X#define getUPORTR() 	((WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(UPORTR,1)))
N
N/**
N * @ingroup Common_register_access_function
N * @brief Set @ref PHYCFGR register
N * @param (uint8_t)phycfgr Value to set @ref PHYCFGR register.
N * @sa getPHYCFGR()
N */
N#define setPHYCFGR(phycfgr) \
N		WIZCHIP_WRITE(PHYCFGR, phycfgr)
X#define setPHYCFGR(phycfgr) 		WIZCHIP_WRITE(PHYCFGR, phycfgr)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref PHYCFGR register
N * @return uint8_t. Value of @ref PHYCFGR register.
N * @sa setPHYCFGR()
N */
N#define getPHYCFGR() \
N		WIZCHIP_READ(PHYCFGR)
X#define getPHYCFGR() 		WIZCHIP_READ(PHYCFGR)
N
N/**
N * @ingroup Common_register_access_function
N * @brief Get @ref VERSIONR register
N * @return uint8_t. Value of @ref VERSIONR register.
N */
N#define getVERSIONR() \
N		WIZCHIP_READ(VERSIONR)
X#define getVERSIONR() 		WIZCHIP_READ(VERSIONR)
N
N/////////////////////////////////////
N
N///////////////////////////////////
N// Socket N register I/O function //
N///////////////////////////////////
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)mr Value to set @ref Sn_MR
N * @sa getSn_MR()
N */
N#define setSn_MR(sn, mr) \
N		WIZCHIP_WRITE(Sn_MR(sn),mr)
X#define setSn_MR(sn, mr) 		WIZCHIP_WRITE(Sn_MR(sn),mr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_MR.
N * @sa setSn_MR()
N */
N#define getSn_MR(sn) \
N	WIZCHIP_READ(Sn_MR(sn))
X#define getSn_MR(sn) 	WIZCHIP_READ(Sn_MR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)cr Value to set @ref Sn_CR
N * @sa getSn_CR()
N */
N#define setSn_CR(sn, cr) \
N		WIZCHIP_WRITE(Sn_CR(sn), cr)
X#define setSn_CR(sn, cr) 		WIZCHIP_WRITE(Sn_CR(sn), cr)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_CR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_CR.
N * @sa setSn_CR()
N */
N#define getSn_CR(sn) \
N		WIZCHIP_READ(Sn_CR(sn))
X#define getSn_CR(sn) 		WIZCHIP_READ(Sn_CR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ir Value to set @ref Sn_IR
N * @sa getSn_IR()
N */
N#define setSn_IR(sn, ir) \
N		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
X#define setSn_IR(sn, ir) 		WIZCHIP_WRITE(Sn_IR(sn), (ir & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IR.
N * @sa setSn_IR()
N */
N#define getSn_IR(sn) \
N		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
X#define getSn_IR(sn) 		(WIZCHIP_READ(Sn_IR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)imr Value to set @ref Sn_IMR
N * @sa getSn_IMR()
N */
N#define setSn_IMR(sn, imr) \
N		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
X#define setSn_IMR(sn, imr) 		WIZCHIP_WRITE(Sn_IMR(sn), (imr & 0x1F))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_IMR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_IMR.
N * @sa setSn_IMR()
N */
N#define getSn_IMR(sn) \
N		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
X#define getSn_IMR(sn) 		(WIZCHIP_READ(Sn_IMR(sn)) & 0x1F)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_SR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_SR.
N */
N#define getSn_SR(sn) \
N		WIZCHIP_READ(Sn_SR(sn))
X#define getSn_SR(sn) 		WIZCHIP_READ(Sn_SR(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)port Value to set @ref Sn_PORT.
N * @sa getSn_PORT()
N */
N#define setSn_PORT(sn, port)  { \
N		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); \
N	}
X#define setSn_PORT(sn, port)  { 		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_PORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_PORT.
N * @sa setSn_PORT()
N */
N#define getSn_PORT(sn) \
N		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
X#define getSn_PORT(sn) 		((WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DHAR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to set socket n destination hardware address. It should be allocated 6 bytes.
N * @sa getSn_DHAR()
N */
N#define setSn_DHAR(sn, dhar) \
N		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
X#define setSn_DHAR(sn, dhar) 		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dhar Pointer variable to get socket n destination hardware address. It should be allocated 6 bytes.
N * @sa setSn_DHAR()
N */
N#define getSn_DHAR(sn, dhar) \
N		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
X#define getSn_DHAR(sn, dhar) 		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to set socket n destination IP address. It should be allocated 4 bytes.
N * @sa getSn_DIPR()
N */
N#define setSn_DIPR(sn, dipr) \
N		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
X#define setSn_DIPR(sn, dipr) 		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DIPR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t*)dipr Pointer variable to get socket n destination IP address. It should be allocated 4 bytes.
N * @sa SetSn_DIPR()
N */
N#define getSn_DIPR(sn, dipr) \
N		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
X#define getSn_DIPR(sn, dipr) 		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)dport Value to set @ref Sn_DPORT
N * @sa getSn_DPORT()
N */
N#define setSn_DPORT(sn, dport) { \
N		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); \
N	}
X#define setSn_DPORT(sn, dport) { 		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_DPORT register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_DPORT.
N * @sa setSn_DPORT()
N */
N#define getSn_DPORT(sn) \
N		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
X#define getSn_DPORT(sn) 		((WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)mss Value to set @ref Sn_MSSR
N * @sa setSn_MSSR()
N */
N#define setSn_MSSR(sn, mss) { \
N		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); \
N	}
X#define setSn_MSSR(sn, mss) { 		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_MSSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_MSSR.
N * @sa setSn_MSSR()
N */
N#define getSn_MSSR(sn) \
N		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
X#define getSn_MSSR(sn) 		((WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)tos Value to set @ref Sn_TOS
N * @sa getSn_TOS()
N */
N#define setSn_TOS(sn, tos) \
N		WIZCHIP_WRITE(Sn_TOS(sn), tos)
X#define setSn_TOS(sn, tos) 		WIZCHIP_WRITE(Sn_TOS(sn), tos)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TOS register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of Sn_TOS.
N * @sa setSn_TOS()
N */
N#define getSn_TOS(sn) \
N		WIZCHIP_READ(Sn_TOS(sn))
X#define getSn_TOS(sn) 		WIZCHIP_READ(Sn_TOS(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)ttl Value to set @ref Sn_TTL
N * @sa getSn_TTL()
N */
N#define setSn_TTL(sn, ttl) \
N		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
X#define setSn_TTL(sn, ttl) 		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TTL register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TTL.
N * @sa setSn_TTL()
N */
N#define getSn_TTL(sn) \
N		WIZCHIP_READ(Sn_TTL(sn))
X#define getSn_TTL(sn) 		WIZCHIP_READ(Sn_TTL(sn))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)rxbufsize Value to set @ref Sn_RXBUF_SIZE
N * @sa getSn_RXBUF_SIZE()
N */
N#define setSn_RXBUF_SIZE(sn, rxbufsize) \
N		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
X#define setSn_RXBUF_SIZE(sn, rxbufsize) 		WIZCHIP_WRITE(Sn_RXBUF_SIZE(sn),rxbufsize)
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_RXBUF_SIZE.
N * @sa setSn_RXBUF_SIZE()
N */
N#define getSn_RXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
X#define getSn_RXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_RXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)txbufsize Value to set @ref Sn_TXBUF_SIZE
N * @sa getSn_TXBUF_SIZE()
N */
N#define setSn_TXBUF_SIZE(sn, txbufsize) \
N		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
X#define setSn_TXBUF_SIZE(sn, txbufsize) 		WIZCHIP_WRITE(Sn_TXBUF_SIZE(sn), txbufsize)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TXBUF_SIZE register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_TXBUF_SIZE.
N * @sa setSn_TXBUF_SIZE()
N */
N#define getSn_TXBUF_SIZE(sn) \
N		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
X#define getSn_TXBUF_SIZE(sn) 		WIZCHIP_READ(Sn_TXBUF_SIZE(sn))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_FSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_FSR.
N */
Nuint16_t getSn_TX_FSR(uint8_t sn);
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_RD.
N */
N#define getSn_TX_RD(sn) \
N		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
X#define getSn_TX_RD(sn) 		((WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)txwr Value to set @ref Sn_TX_WR
N * @sa GetSn_TX_WR()
N */
N#define setSn_TX_WR(sn, txwr) { \
N		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); \
N		}
X#define setSn_TX_WR(sn, txwr) { 		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); 		}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_TX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_TX_WR.
N * @sa setSn_TX_WR()
N */
N#define getSn_TX_WR(sn) \
N		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
X#define getSn_TX_WR(sn) 		((WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RSR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_RSR.
N */
Nuint16_t getSn_RX_RSR(uint8_t sn);
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)rxrd Value to set @ref Sn_RX_RD
N * @sa getSn_RX_RD()
N */
N#define setSn_RX_RD(sn, rxrd) { \
N		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); \
N	}
X#define setSn_RX_RD(sn, rxrd) { 		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_RD register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @regurn uint16_t. Value of @ref Sn_RX_RD.
N * @sa setSn_RX_RD()
N */
N#define getSn_RX_RD(sn) \
N		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
X#define getSn_RX_RD(sn) 		((WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_RX_WR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_RX_WR.
N */
N#define getSn_RX_WR(sn) \
N		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
X#define getSn_RX_WR(sn) 		((WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
N
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint16_t)frag Value to set @ref Sn_FRAG
N * @sa getSn_FRAD()
N */
N#define setSn_FRAG(sn, frag) { \
N		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); \
N		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); \
N	}
X#define setSn_FRAG(sn, frag) { 		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); 		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); 	}
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_FRAG register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of @ref Sn_FRAG.
N * @sa setSn_FRAG()
N */
N#define getSn_FRAG(sn) \
N		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
X#define getSn_FRAG(sn) 		((WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Set @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param (uint8_t)kpalvt Value to set @ref Sn_KPALVTR
N * @sa getSn_KPALVTR()
N */
N#define setSn_KPALVTR(sn, kpalvt) \
N		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
X#define setSn_KPALVTR(sn, kpalvt) 		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvt)
N
N/**
N * @ingroup Socket_register_access_function
N * @brief Get @ref Sn_KPALVTR register
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint8_t. Value of @ref Sn_KPALVTR.
N * @sa setSn_KPALVTR()
N */
N#define getSn_KPALVTR(sn) \
N		WIZCHIP_READ(Sn_KPALVTR(sn))
X#define getSn_KPALVTR(sn) 		WIZCHIP_READ(Sn_KPALVTR(sn))
N
N//////////////////////////////////////
N
N/////////////////////////////////////
N// Sn_TXBUF & Sn_RXBUF IO function //
N/////////////////////////////////////
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameter.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n RX max buffer size.
N */
N#define getSn_RxMAX(sn) \
N		(getSn_RXBUF_SIZE(sn) << 10)
X#define getSn_RxMAX(sn) 		(getSn_RXBUF_SIZE(sn) << 10)
N
N/**  
N * @brief Gets the max buffer size of socket sn passed as parameters.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @return uint16_t. Value of Socket n TX max buffer size.
N */
N//uint16_t getSn_TxMAX(uint8_t sn);
N#define getSn_TxMAX(sn) \
N		(getSn_TXBUF_SIZE(sn) << 10)
X#define getSn_TxMAX(sn) 		(getSn_TXBUF_SIZE(sn) << 10)
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to internal TX memory
N *
N * @details This function reads the Tx write pointer register and after that,
N * it copies the <i>wizdata(pointer buffer)</i> of the length of <i>len(variable)</i> bytes to internal TX memory
N * and updates the Tx write pointer register.
N * This function is being called by send() and sendto() function also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to write data
N * @param len Data length
N * @sa wiz_recv_data()
N */
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It copies data to your buffer from internal RX memory
N *
N * @details This function read the Rx read pointer register and after that,
N * it copies the received data from internal RX memory
N * to <i>wizdata(pointer variable)</i> of the length of <i>len(variable)</i> bytes.
N * This function is being called by recv() also.
N *
N * @note User should read upper byte first and lower byte later to get proper value.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param wizdata Pointer buffer to read data
N * @param len Data length
N * @sa wiz_send_data()
N */
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
N
N/**
N * @ingroup Basic_IO_function
N * @brief It discard the received data in RX memory.
N * @details It discards the data of the length of <i>len(variable)</i> bytes in internal RX memory.
N * @param (uint8_t)sn Socket number. It should be <b>0 ~ 7</b>.
N * @param len Data length
N */
Nvoid wiz_recv_ignore(uint8_t sn, uint16_t len);
N
N#endif   // _W5500_H_
L 115 "..\..\Ethernet\wizchip_conf.h" 2
N#else 
S   #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
N#endif
N
N#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
N#endif
N
N/**
N * @brief Define I/O base address when BUS IF mode.
N * @todo Should re-define it to fit your system when BUS IF Mode (@ref \_WIZCHIP_IO_MODE_BUS_,
N *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
N *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
N */
N#define _WIZCHIP_IO_BASE_              0x00000000  // 
N
N#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
X#if (0x0200 + 1) & _WIZCHIP_IO_MODE_BUS
S   #ifndef _WIZCHIP_IO_BASE_
S      #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
S   #endif
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   #define _WIZCHIP_SOCK_NUM_   8   ///< The count of independant socket of @b WIZCHIP
N#else
S   #define _WIZCHIP_SOCK_NUM_   4   ///< The count of independant socket of @b WIZCHIP
N#endif      
N
N
N/********************************************************
N* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
N*********************************************************/
N/**
N * @ingroup DATA_TYPE
N * @brief The set of callback functions for W5500:@ref WIZCHIP_IO_Functions W5200:@ref WIZCHIP_IO_Functions_W5200
N */
Ntypedef struct __WIZCHIP
N{
N   uint16_t  if_mode;               ///< host interface mode
N   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
N   /**
N    * The set of critical section callback func.
N    */
N   struct _CRIS
N   {
N      void (*_enter)  (void);       ///< crtical section enter 
N      void (*_exit) (void);         ///< critial section exit  
N   }CRIS;  
N   /**
N    *  The set of @ref\_WIZCHIP_ select control callback func.
N    */
N   struct _CS
N   {
N      void (*_select)  (void);      ///< @ref \_WIZCHIP_ selected
N      void (*_deselect)(void);      ///< @ref \_WIZCHIP_ deselected
N   }CS;  
N   /**
N    * The set of interface IO callback func.
N    */
N   union _IF
N   {	 
N      /**
N       * For BUS interface IO
N       */  
N      struct
N      {
N         uint8_t  (*_read_byte)  (uint32_t AddrSel);
N         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
N      }BUS;      
N      /**
N       * For SPI interface IO
N       */
N      struct
N      {
N         uint8_t (*_read_byte)   (void);
N         void    (*_write_byte)  (uint8_t wb);
N      }SPI;
N      // To be added
N      //
N   }IF;
N}_WIZCHIP;
N
Nextern _WIZCHIP  WIZCHIP;
N
N/**
N * @ingroup DATA_TYPE
N *  WIZCHIP control type enumration used in @ref ctlwizchip().
N */
Ntypedef enum
N{
N   CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
N   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
N   CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
N   CW_CLR_INTERRUPT,   ///< Clears interrupt
N   CW_SET_INTRMASK,    ///< Masks interrupt
N   CW_GET_INTRMASK,    ///< Get interrupt mask
N   CW_SET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
N   CW_GET_ID,          ///< Gets WIZCHIP name.
N
N#if _WIZCHIP_ ==  5500
X#if 5500 ==  5500
N   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
N   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
N   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
N   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
N   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
N#endif
N   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
N   CW_GET_PHYLINK      ///< Get PHY Link status
N}ctlwizchip_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Network control type enumration used in @ref ctlnetwork().
N */
Ntypedef enum
N{
N   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
N   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
N   CN_SET_NETMODE,  ///< Set network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_GET_NETMODE,  ///< Get network mode as WOL, PPPoE, Ping Block, and Force ARP mode
N   CN_SET_TIMEOUT,  ///< Set network timeout as retry count and time.
N   CN_GET_TIMEOUT,  ///< Get network timeout as retry count and time.
N}ctlnetwork_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Interrupt kind when CW_SET_INTRRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK
N *  and CW_GET_INTRMASK is used in @ref ctlnetwork().
N *  It can be used with OR operation.
N */
Ntypedef enum
N{
N#if _WIZCHIP_ > 5200
X#if 5500 > 5200
N   IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
N#endif   
N
N   IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
N
N#if _WIZCHIP_ != 5200
X#if 5500 != 5200
N   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
N#endif   
N
N   IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
N
N   IK_SOCK_0            = (1 << 8),   ///< Socket 0 interrupt
N   IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
N   IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
N   IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
N#if _WIZCHIP_ > 5100   
X#if 5500 > 5100   
N   IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
N   IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
N   IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
N   IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
N#endif   
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
N#else
S   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
N#endif      
N}intr_kind;
N
N#define PHY_CONFBY_HW            0     ///< Configured PHY operation mode by HW pin
N#define PHY_CONFBY_SW            1     ///< Configured PHY operation mode by SW register   
N#define PHY_MODE_MANUAL          0     ///< Configured PHY operation mode with user setting.
N#define PHY_MODE_AUTONEGO        1     ///< Configured PHY operation mode with auto-negotiation
N#define PHY_SPEED_10             0     ///< Link Speed 10
N#define PHY_SPEED_100            1     ///< Link Speed 100
N#define PHY_DUPLEX_HALF          0     ///< Link Half-Duplex
N#define PHY_DUPLEX_FULL          1     ///< Link Full-Duplex
N#define PHY_LINK_OFF             0     ///< Link Off
N#define PHY_LINK_ON              1     ///< Link On
N#define PHY_POWER_NORM           0     ///< PHY power normal mode
N#define PHY_POWER_DOWN           1     ///< PHY power down mode 
N
N
N#if _WIZCHIP_ == 5500 
X#if 5500 == 5500 
N/**
N * @ingroup DATA_TYPE
N *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
N *  and it indicates the real PHY status configured by HW or SW in all WIZCHIP. \n
N *  Valid only in W5500.
N */
Ntypedef struct wiz_PhyConf_t
N{
N      uint8_t by;       ///< set by @ref PHY_CONFBY_HW or @ref PHY_CONFBY_SW
N      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL or @ref PHY_MODE_AUTONEGO
N      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
N      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
N      //uint8_t power;  ///< set by @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N      //uint8_t link;   ///< Valid only in CW_GET_PHYSTATUS. set by @ref PHY_LINK_ON or PHY_DUPLEX_OFF 
N   }wiz_PhyConf;
N#endif   
N
N/**
N * @ingroup DATA_TYPE
N *  It used in setting dhcp_mode of @ref wiz_NetInfo.
N */
Ntypedef enum
N{
N   NETINFO_STATIC = 1,    ///< Static IP configuration by manually.
N   NETINFO_DHCP           ///< Dynamic IP configruation from a DHCP sever
N}dhcp_mode;
N
N/**
N * @ingroup DATA_TYPE
N *  Network Information for WIZCHIP
N */
Ntypedef struct wiz_NetInfo_t
N{
N   uint8_t mac[6];  ///< Source Mac Address
N   uint8_t ip[4];   ///< Source IP Address
N   uint8_t sn[4];   ///< Subnet Mask 
N   uint8_t gw[4];   ///< Gateway IP Address
N   uint8_t dns[4];  ///< DNS server IP Address
N   dhcp_mode dhcp;  ///< 1 - Static, 2 - DHCP
N}wiz_NetInfo;
N
N/**
N * @ingroup DATA_TYPE
N *  Network mode
N */
Ntypedef enum
N{
N#if _WIZCHIP_ == 5500   
X#if 5500 == 5500   
N   NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
N#endif   
N   NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
N   NM_PINGBLOCK   = (1<<4),  ///< Block ping-request
N   NM_PPPOE       = (1<<3),  ///< PPPoE mode
N}netmode_type;
N
N/**
N * @ingroup DATA_TYPE
N *  Used in CN_SET_TIMEOUT or CN_GET_TIMEOUT of @ref ctlwizchip() for timeout configruation.
N */
Ntypedef struct wiz_NetTimeout_t
N{
N   uint8_t  retry_cnt;     ///< retry count 
N   uint16_t time_100us;    ///< time unit 100us
N}wiz_NetTimeout;
N
N/**
N *@brief Registers call back function for critical section of I/O functions such as
N *\ref WIZCHIP_READ, @ref WIZCHIP_WRITE, @ref WIZCHIP_READ_BUF and @ref WIZCHIP_WRITE_BUF.
N *@param cris_en : callback function for critical section enter.
N *@param cris_ex : callback function for critical section exit.
N *@todo Describe @ref WIZCHIP_CRITICAL_ENTER and @ref WIZCHIP_CRITICAL_EXIT marco or register your functions.
N *@note If you do not describe or register, default functions(@ref wizchip_cris_enter & @ref wizchip_cris_exit) is called.
N */
Nvoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
N
N
N/**
N *@brief Registers call back function for WIZCHIP select & deselect.
N *@param cs_sel : callback function for WIZCHIP select
N *@param cs_desel : callback fucntion for WIZCHIP deselect
N *@todo Describe @ref wizchip_cs_select and @ref wizchip_cs_deselect function or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
N
N/**
N *@brief Registers call back function for bus interface.
N *@param bus_rb   : callback function to read byte data using system bus
N *@param bus_wb   : callback function to write byte data using system bus
N *@todo Describe @ref wizchip_bus_readbyte and @ref wizchip_bus_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
N
N/**
N *@brief Registers call back function for SPI interface.
N *@param spi_rb : callback function to read byte usig SPI 
N *@param spi_wb : callback function to write byte usig SPI 
N *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
N *or register your functions.
N *@note If you do not describe or register, null function is called.
N */
Nvoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb));
N
N/**
N * @ingroup extra_functions
N * @brief Controls to the WIZCHIP.
N * @details Resets WIZCHIP & internal PHY, Configures PHY mode, Monitor PHY(Link,Speed,Half/Full/Auto),
N * controls interrupt & mask and so on.
N * @param cwtype : Decides to the control type
N * @param arg : arg type is dependent on cwtype.
N * @return  0 : Success \n
N *         -1 : Fail because of invalid \ref ctlwizchip_type or unsupported \ref ctlwizchip_type in WIZCHIP 
N */          
Nint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network.
N * @details Controls to network environment, mode, timeout and so on.
N * @param cntype : Input. Decides to the control type
N * @param arg : Inout. arg type is dependent on cntype.
N * @return -1 : Fail because of invalid \ref ctlnetwork_type or unsupported \ref ctlnetwork_type in WIZCHIP \n
N *          0 : Success      
N */          
Nint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
N
N
N/* 
N * The following functions are implemented for internal use. 
N * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
N */
N 
N/**
N * @ingroup extra_functions
N * @brief Reset WIZCHIP by softly.
N */ 
Nvoid   wizchip_sw_reset(void);
N
N/**
N * @ingroup extra_functions
N * @brief Initializes WIZCHIP with socket buffer size
N * @param txsize Socket tx buffer sizes. If null, initialized the default size 2KB.
N * @param rxsize Socket rx buffer sizes. If null, initialized the default size 2KB.
N * @return 0 : succcess \n
N *        -1 : fail. Invalid buffer size
N */
Nint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
N
N/** 
N * @ingroup extra_functions
N * @brief Clear Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_clrinterrupt(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt of WIZCHIP.
N * @return @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterrupt(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Mask or Unmask Interrupt of WIZCHIP.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint16_t.
N */
Nvoid wizchip_setinterruptmask(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt mask of WIZCHIP.
N * @return : The operated OR vaule of @ref intr_kind. It can type-cast to uint16_t.
N */
Nintr_kind wizchip_getinterruptmask(void);
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N   int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
N   int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
N#endif
N
N#if _WIZCHIP_ == 5500
X#if 5500 == 5500
N   void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
N/**
N * @ingroup extra_functions
N * @brief Set the phy information for WIZCHIP without power mode
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_setphyconf(wiz_PhyConf* phyconf);  
N /**
N * @ingroup extra_functions
N * @brief Get phy configuration information.
N * @param phyconf : @ref wiz_PhyConf
N */
N   void   wizphy_getphyconf(wiz_PhyConf* phyconf); 
N /**
N * @ingroup extra_functions
N * @brief Get phy status.
N * @param phyconf : @ref wiz_PhyConf
N */ 
N   void   wizphy_getphystat(wiz_PhyConf* phyconf);
N /**
N * @ingroup extra_functions
N * @brief set the power mode of phy inside WIZCHIP. Refer to @ref PHYCFGR in W5500, @ref PHYSTATUS in W5200
N * @param pmode Settig value of power down mode.
N */   
N   int8_t wizphy_setphypmode(uint8_t pmode);    
N#endif
N
N/**
N* @ingroup extra_functions
N * @brief Set the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network information for WIZCHIP
N * @param pnetinfo : @ref wizNetInfo
N */
Nvoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @param pnetinfo Value of network mode. Refer to @ref netmode_type.
N */
Nint8_t wizchip_setnetmode(netmode_type netmode);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network mode such WOL, PPPoE, Ping Block, and etc. 
N * @return Value of network mode. Refer to @ref netmode_type.
N */
Nnetmode_type wizchip_getnetmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_settimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
N * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
N * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
N */
Nvoid wizchip_gettimeout(wiz_NetTimeout* nettime);
N
N#endif   // _WIZCHIP_CONF_H_
L 52 "..\..\Ethernet\wizchip_conf.c" 2
N
N/**
N * @brief Default function to enable interrupt.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
Nvoid 	  wizchip_cris_enter(void)           {};
N/**
N * @brief Default function to disable interrupt.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
Nvoid 	  wizchip_cris_exit(void)          {};
N/**
N * @brief Default function to select chip.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
Nvoid 	wizchip_cs_select(void)            {};
N/**
N * @brief Default function to deselect chip.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
Nvoid 	wizchip_cs_deselect(void)          {};
N/**
N * @brief Default function to read in direct or indirect interface.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
N //M20140501 : Explict pointer type casting
N//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *) AddrSel); };
Nuint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); };
N/**
N * @brief Default function to write in direct or indirect interface.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
N 
N//M20140501 : Explict pointer type casting
N//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*) AddrSel) = wb; };
Nvoid 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; };
N
N/**
N * @brief Default function to read in SPI interface.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
Nuint8_t wizchip_spi_readbyte(void)        {return 0;};
N/**
N * @brief Default function to write in SPI interface.
N * @note This function help not to access wrong address. If you do not describe this function or register any functions,
N * null function is called.
N */
Nvoid 	wizchip_spi_writebyte(uint8_t wb) {};
N
N/**
N * @\ref _WIZCHIP instance
N */
N_WIZCHIP  WIZCHIP =
N      {
N      .id                  = _WIZCHIP_ID_,
X      .id                  = "W5500\0",
N      .if_mode             = _WIZCHIP_IO_MODE_,
X      .if_mode             = (0x0200 + 1),
N      .CRIS._enter         = wizchip_cris_enter,
N      .CRIS._exit          = wizchip_cris_exit,
N      .CS._select          = wizchip_cs_select,
N      .CS._deselect        = wizchip_cs_deselect,
N      .IF.BUS._read_byte   = wizchip_bus_readbyte,
N      .IF.BUS._write_byte  = wizchip_bus_writebyte
N//    .IF.SPI._read_byte   = wizchip_spi_readbyte,
N//    .IF.SPI._write_byte  = wizchip_spi_writebyte
N      };
N
Nstatic uint8_t    _DNS_[4];      // DNS server ip address
Nstatic dhcp_mode  _DHCP_;        // DHCP mode
N
Nvoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void))
N{
N   if(!cris_en || !cris_ex)
N   {
N      WIZCHIP.CRIS._enter = wizchip_cris_enter;
N      WIZCHIP.CRIS._exit  = wizchip_cris_exit;
N   }
N   else
N   {
N      WIZCHIP.CRIS._enter = cris_en;
N      WIZCHIP.CRIS._exit  = cris_ex;
N   }
N}
N
Nvoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void))
N{
N   if(!cs_sel || !cs_desel)
N   {
N      WIZCHIP.CS._select   = wizchip_cs_select;
N      WIZCHIP.CS._deselect = wizchip_cs_deselect;
N   }
N   else
N   {
N      WIZCHIP.CS._select   = cs_sel;
N      WIZCHIP.CS._deselect = cs_desel;
N   }
N}
N
Nvoid reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb))
N{
N   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_BUS_));
X   while(!(WIZCHIP.if_mode & 0x0100));
N   
N   if(!bus_rb || !bus_wb)
N   {
N      WIZCHIP.IF.BUS._read_byte   = wizchip_bus_readbyte;
N      WIZCHIP.IF.BUS._write_byte  = wizchip_bus_writebyte;
N   }
N   else
N   {
N      WIZCHIP.IF.BUS._read_byte   = bus_rb;
N      WIZCHIP.IF.BUS._write_byte  = bus_wb;
N   }
N}
N
Nvoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb))
N{
N   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
X   while(!(WIZCHIP.if_mode & 0x0200));
N   
N   if(!spi_rb || !spi_wb)
N   {
N      WIZCHIP.IF.SPI._read_byte   = wizchip_spi_readbyte;
N      WIZCHIP.IF.SPI._write_byte  = wizchip_spi_writebyte;
N   }
N   else
N   {
N      WIZCHIP.IF.SPI._read_byte   = spi_rb;
N      WIZCHIP.IF.SPI._write_byte  = spi_wb;
N   }
N}
N
Nint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
N{
N   uint8_t tmp = 0;
N   uint8_t* ptmp[2] = {0,0};
N   switch(cwtype)
N   {
N      case CW_RESET_WIZCHIP:
N         wizchip_sw_reset();
N         break;
N      case CW_INIT_WIZCHIP:
N         if(arg != 0) 
N         {
N            ptmp[0] = (uint8_t*)arg;
N            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
X            ptmp[1] = ptmp[0] + 8;
N         }
N         return wizchip_init(ptmp[0], ptmp[1]);
N      case CW_CLR_INTERRUPT:
N         wizchip_clrinterrupt(*((intr_kind*)arg));
N         break;
N      case CW_GET_INTERRUPT:
N        *((intr_kind*)arg) = wizchip_getinterrupt();
N         break;
N      case CW_SET_INTRMASK:
N         wizchip_setinterruptmask(*((intr_kind*)arg));
N         break;         
N      case CW_GET_INTRMASK:
N         *((intr_kind*)arg) = wizchip_getinterruptmask();
N         break;
N   #if _WIZCHIP_ > 5100
X   #if 5500 > 5100
N      case CW_SET_INTRTIME:
N         setINTLEVEL(*(uint16_t*)arg);
X         { WIZCHIP_WRITE((0x00000000 + (0x0013 << 8) + (0x00 << 3)), (uint8_t)(*(uint16_t*)arg >> 8)); WIZCHIP_WRITE(((0x00000000 + (0x0013 << 8) + (0x00 << 3)) + (1<<8)), (uint8_t) *(uint16_t*)arg); };
N         break;
N      case CW_GET_INTRTIME:
N         *(uint16_t*)arg = getINTLEVEL();
X         *(uint16_t*)arg = ((WIZCHIP_READ((0x00000000 + (0x0013 << 8) + (0x00 << 3))) << 8) + WIZCHIP_READ(((0x00000000 + (0x0013 << 8) + (0x00 << 3)) + (1<<8))));
N         break;
N   #endif
N      case CW_GET_ID:
N         ((uint8_t*)arg)[0] = WIZCHIP.id[0];
N         ((uint8_t*)arg)[1] = WIZCHIP.id[1];
N         ((uint8_t*)arg)[2] = WIZCHIP.id[2];
N         ((uint8_t*)arg)[3] = WIZCHIP.id[3];
N         ((uint8_t*)arg)[4] = WIZCHIP.id[4];
N         ((uint8_t*)arg)[5] = 0;
N         break;
N   #if _WIZCHIP_ ==  5500
X   #if 5500 ==  5500
N      case CW_RESET_PHY:
N         wizphy_reset();
N         break;
N      case CW_SET_PHYCONF:
N         wizphy_setphyconf((wiz_PhyConf*)arg);
N         break;
N      case CW_GET_PHYCONF:
N         wizphy_getphyconf((wiz_PhyConf*)arg);
N         break;
N      case CW_GET_PHYSTATUS:  
N         break;
N      case CW_SET_PHYPOWMODE:
N         return wizphy_setphypmode(*(uint8_t*)arg);
N   #endif
N      case CW_GET_PHYPOWMODE:
N         tmp = wizphy_getphypmode();
N         if((int8_t)tmp == -1) return -1;
N         *(uint8_t*)arg = tmp;
N         break;
N      case CW_GET_PHYLINK:
N         tmp = wizphy_getphylink();
N         if((int8_t)tmp == -1) return -1;
N         *(uint8_t*)arg = tmp;
N         break;
N      default:
N         return -1;
N   }
N   return 0;
N}
N
N
Nint8_t ctlnetwork(ctlnetwork_type cntype, void* arg)
N{
N   
N   switch(cntype)
N   {
N      case CN_SET_NETINFO:
N         wizchip_setnetinfo((wiz_NetInfo*)arg);
N         break;
N      case CN_GET_NETINFO:
N         wizchip_getnetinfo((wiz_NetInfo*)arg);
N         break;
N      case CN_SET_NETMODE:
N         return wizchip_setnetmode(*(netmode_type*)arg);
N      case CN_GET_NETMODE:
N         *(netmode_type*)arg = wizchip_getnetmode();
N         break;
N      case CN_SET_TIMEOUT:
N         wizchip_settimeout((wiz_NetTimeout*)arg);
N         break;
N      case CN_GET_TIMEOUT:
N         wizchip_gettimeout((wiz_NetTimeout*)arg);
N         break;
N      default:
N         return -1;
N   }
N   return 0;
N}
N
Nvoid wizchip_sw_reset(void)
N{
N   uint8_t gw[4], sn[4], sip[4];
N   uint8_t mac[6];
N   getSHAR(mac);
X   WIZCHIP_READ_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), mac, 6);
N   getGAR(gw);  getSUBR(sn);  getSIPR(sip);
X   WIZCHIP_READ_BUF((0x00000000 + (0x0001 << 8) + (0x00 << 3)),gw,4);  WIZCHIP_READ_BUF((0x00000000 + (0x0005 << 8) + (0x00 << 3)), sn, 4);  WIZCHIP_READ_BUF((0x00000000 + (0x000F << 8) + (0x00 << 3)), sip, 4);
N   setMR(MR_RST);
X   WIZCHIP_WRITE((0x00000000 + (0x0000 << 8) + (0x00 << 3)),0x80);
N   getMR(); // for delay
X   WIZCHIP_READ((0x00000000 + (0x0000 << 8) + (0x00 << 3))); 
N   setSHAR(mac);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), mac, 6);
N   setGAR(gw);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0001 << 8) + (0x00 << 3)),gw,4);
N   setSUBR(sn);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0005 << 8) + (0x00 << 3)), sn,4);
N   setSIPR(sip);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x000F << 8) + (0x00 << 3)), sip, 4);
N}
N
Nint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize)
N{
N   int8_t i;
N   int8_t tmp = 0;
N   wizchip_sw_reset();
N   if(txsize)
N   {
N      tmp = 0;
N      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
X      for(i = 0 ; i < 8; i++)
N         tmp += txsize[i];
N      if(tmp > 16) return -1;
N      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
X      for(i = 0 ; i < 8; i++)
N         setSn_TXBUF_SIZE(i, txsize[i]);
X         WIZCHIP_WRITE((0x00000000 + (0x001F << 8) + ((1+4*i) << 3)), txsize[i]);
N   }
N   if(rxsize)
N   {
N      tmp = 0;
N      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
X      for(i = 0 ; i < 8; i++)
N         tmp += rxsize[i];
N      if(tmp > 16) return -1;
N      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
X      for(i = 0 ; i < 8; i++)
N         setSn_RXBUF_SIZE(i, rxsize[i]);
X         WIZCHIP_WRITE((0x00000000 + (0x001E << 8) + ((1+4*i) << 3)),rxsize[i]);
N   }
N   return 0;
N}
N
Nvoid wizchip_clrinterrupt(intr_kind intr)
N{
N   uint8_t ir  = (uint8_t)intr;
N   uint8_t sir = (uint8_t)((uint16_t)intr >> 8);
N#if _WIZCHIP_ < 5500
X#if 5500 < 5500
S   ir |= (1<<4); // IK_WOL
N#endif
N#if _WIZCHIP_ == 5200
X#if 5500 == 5200
S   ir |= (1 << 6);
N#endif
N   
N#if _WIZCHIP_ < 5200
X#if 5500 < 5200
S   sir &= 0x0F;
N#endif
N
N#if _WIZCHIP_ == 5100
X#if 5500 == 5100
S   ir |= sir;
S   setIR(ir);
N#else
N   setIR(ir);
X   WIZCHIP_WRITE((0x00000000 + (0x0015 << 8) + (0x00 << 3)), (ir & 0xF0));
N   setSIR(sir);
X   WIZCHIP_WRITE((0x00000000 + (0x0017 << 8) + (0x00 << 3)), sir);
N#endif   
N}
N
Nintr_kind wizchip_getinterrupt(void)
N{
N   uint8_t ir  = 0;
N   uint8_t sir = 0;
N   uint16_t ret = 0;
N#if _WIZCHIP_ == 5100
X#if 5500 == 5100
S   ir = getIR();
S   sir = ir 0x0F;
N#else
N   ir  = getIR();
X   ir  = (WIZCHIP_READ((0x00000000 + (0x0015 << 8) + (0x00 << 3))) & 0xF0);
N   sir = getSIR();
X   sir = WIZCHIP_READ((0x00000000 + (0x0017 << 8) + (0x00 << 3)));
N#endif         
N
N#if _WIZCHIP_ < 5500
X#if 5500 < 5500
S   ir &= ~(1<<4); // IK_WOL
N#endif
N#if _WIZCHIP_ == 5200
X#if 5500 == 5200
S   ir &= ~(1 << 6);
N#endif
N  ret = sir;
N  ret = (ret << 8) + ir;
N  return (intr_kind)ret;
N}
N
Nvoid wizchip_setinterruptmask(intr_kind intr)
N{
N   uint8_t imr  = (uint8_t)intr;
N   uint8_t simr = (uint8_t)((uint16_t)intr >> 8);
N#if _WIZCHIP_ < 5500
X#if 5500 < 5500
S   imr &= ~(1<<4); // IK_WOL
N#endif
N#if _WIZCHIP_ == 5200
X#if 5500 == 5200
S   imr &= ~(1 << 6);
N#endif
N   
N#if _WIZCHIP_ < 5200
X#if 5500 < 5200
S   simr &= 0x0F;
N#endif
N
N#if _WIZCHIP_ == 5100
X#if 5500 == 5100
S   imr |= simr;
S   setIMR(imr);
N#else
N   setIMR(imr);
X   WIZCHIP_WRITE((0x00000000 + (0x0016 << 8) + (0x00 << 3)), imr);
N   setSIMR(simr);
X   WIZCHIP_WRITE((0x00000000 + (0x0018 << 8) + (0x00 << 3)), simr);
N#endif   
N}
N
Nintr_kind wizchip_getinterruptmask(void)
N{
N   uint8_t imr  = 0;
N   uint8_t simr = 0;
N   uint16_t ret = 0;
N#if _WIZCHIP_ == 5100
X#if 5500 == 5100
S   imr  = getIMR();
S   simr = imr 0x0F;
N#else
N   imr  = getIMR();
X   imr  = WIZCHIP_READ((0x00000000 + (0x0016 << 8) + (0x00 << 3)));
N   simr = getSIMR();
X   simr = WIZCHIP_READ((0x00000000 + (0x0018 << 8) + (0x00 << 3)));
N#endif         
N
N#if _WIZCHIP_ < 5500
X#if 5500 < 5500
S   imr &= ~(1<<4); // IK_WOL
N#endif
N#if _WIZCHIP_ == 5200
X#if 5500 == 5200
S   imr &= ~(1 << 6);  // IK_DEST_UNREACH
N#endif
N  ret = simr;
N  ret = (ret << 8) + imr;
N  return (intr_kind)ret;
N}
N
Nint8_t wizphy_getphylink(void)
N{
N   int8_t tmp;
N#if   _WIZCHIP_ == 5200
X#if   5500 == 5200
S   if(getPHYSTATUS() & PHYSTATUS_LINK)
S      tmp = PHY_LINK_ON;
S   else
S      tmp = PHY_LINK_OFF;
N#elif _WIZCHIP_ == 5500
X#elif 5500 == 5500
N   if(getPHYCFGR() & PHYCFGR_LNK_ON)
X   if(WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3))) & (1<<0))
N      tmp = PHY_LINK_ON;
X      tmp = 1;
N   else
N      tmp = PHY_LINK_OFF;
X      tmp = 0;
N#else
S   tmp = -1;
N#endif
N   return tmp;
N}
N
N#if _WIZCHIP_ > 5100
X#if 5500 > 5100
N
Nint8_t wizphy_getphypmode(void)
N{
N   int8_t tmp = 0;
N   #if   _WIZCHIP_ == 5200
X   #if   5500 == 5200
S      if(getPHYSTATUS() & PHYSTATUS_POWERDOWN)
S         tmp = PHY_POWER_DOWN;
S      else          
S         tmp = PHY_POWER_NORM;
N   #elif _WIZCHIP_ == 5500
X   #elif 5500 == 5500
N      if(getPHYCFGR() & PHYCFGR_OPMDC_PDOWN)
X      if(WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3))) & (6<<3))
N         tmp = PHY_POWER_DOWN;
X         tmp = 1;
N      else 
N         tmp = PHY_POWER_NORM;
X         tmp = 0;
N   #else
S      tmp = -1;
N   #endif
N   return tmp;
N}
N#endif
N
N#if _WIZCHIP_ == 5500
X#if 5500 == 5500
Nvoid wizphy_reset(void)
N{
N   uint8_t tmp = getPHYCFGR();
X   uint8_t tmp = WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3)));
N   tmp &= PHYCFGR_RST;
X   tmp &= ~(1<<7);
N   setPHYCFGR(tmp);
X   WIZCHIP_WRITE((0x00000000 + (0x002E << 8) + (0x00 << 3)), tmp);
N   tmp = getPHYCFGR(); 
X   tmp = WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3))); 
N   tmp |= ~PHYCFGR_RST;
X   tmp |= ~~(1<<7);
N   setPHYCFGR(tmp);
X   WIZCHIP_WRITE((0x00000000 + (0x002E << 8) + (0x00 << 3)), tmp);
N}
N
Nvoid wizphy_setphyconf(wiz_PhyConf* phyconf)
N{
N   uint8_t tmp = 0;
N   if(phyconf->by == PHY_CONFBY_SW)
X   if(phyconf->by == 1)
N      tmp |= PHYCFGR_OPMD;
X      tmp |= (1<<6);
N   else
N      tmp &= ~PHYCFGR_OPMD;
X      tmp &= ~(1<<6);
N   if(phyconf->mode == PHY_MODE_AUTONEGO)
X   if(phyconf->mode == 1)
N      tmp |= PHYCFGR_OPMDC_ALLA;
X      tmp |= (7<<3);
N   else
N   {
N      if(phyconf->duplex == PHY_DUPLEX_FULL)
X      if(phyconf->duplex == 1)
N      {
N         if(phyconf->speed == PHY_SPEED_100)
X         if(phyconf->speed == 1)
N            tmp |= PHYCFGR_OPMDC_100F;
X            tmp |= (3<<3);
N         else
N            tmp |= PHYCFGR_OPMDC_10F;
X            tmp |= (1<<3);
N      }   
N      else
N      {
N         if(phyconf->speed == PHY_SPEED_100)
X         if(phyconf->speed == 1)
N            tmp |= PHYCFGR_OPMDC_100H;
X            tmp |= (2<<3);
N         else
N            tmp |= PHYCFGR_OPMDC_10H;
X            tmp |= (0<<3);
N      }
N   }
N   setPHYCFGR(tmp);
X   WIZCHIP_WRITE((0x00000000 + (0x002E << 8) + (0x00 << 3)), tmp);
N   wizphy_reset();
N}
N
Nvoid wizphy_getphyconf(wiz_PhyConf* phyconf)
N{
N   uint8_t tmp = 0;
N   tmp = getPHYCFGR();
X   tmp = WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3)));
N   phyconf->by   = (tmp & PHYCFGR_OPMD) ? PHY_CONFBY_SW : PHY_CONFBY_HW;
X   phyconf->by   = (tmp & (1<<6)) ? 1 : 0;
N   switch(tmp & PHYCFGR_OPMDC_ALLA)
X   switch(tmp & (7<<3))
N   {
N      case PHYCFGR_OPMDC_ALLA:
X      case (7<<3):
N      case PHYCFGR_OPMDC_100FA: 
X      case (4<<3): 
N         phyconf->mode = PHY_MODE_AUTONEGO;
X         phyconf->mode = 1;
N         break;
N      default:
N         phyconf->mode = PHY_MODE_MANUAL;
X         phyconf->mode = 0;
N         break;
N   }
N   switch(tmp & PHYCFGR_OPMDC_ALLA)
X   switch(tmp & (7<<3))
N   {
N      case PHYCFGR_OPMDC_100FA:
X      case (4<<3):
N      case PHYCFGR_OPMDC_100F:
X      case (3<<3):
N      case PHYCFGR_OPMDC_100H:
X      case (2<<3):
N         phyconf->speed = PHY_SPEED_100;
X         phyconf->speed = 1;
N         break;
N      default:
N         phyconf->speed = PHY_SPEED_10;
X         phyconf->speed = 0;
N         break;
N   }
N   switch(tmp & PHYCFGR_OPMDC_ALLA)
X   switch(tmp & (7<<3))
N   {
N      case PHYCFGR_OPMDC_100FA:
X      case (4<<3):
N      case PHYCFGR_OPMDC_100F:
X      case (3<<3):
N      case PHYCFGR_OPMDC_10F:
X      case (1<<3):
N         phyconf->duplex = PHY_DUPLEX_FULL;
X         phyconf->duplex = 1;
N         break;
N      default:
N         phyconf->duplex = PHY_DUPLEX_HALF;
X         phyconf->duplex = 0;
N         break;
N   }
N}
N
Nvoid wizphy_getphystat(wiz_PhyConf* phyconf)
N{
N   uint8_t tmp = getPHYCFGR();
X   uint8_t tmp = WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3)));
N   phyconf->duplex = (tmp & PHYCFGR_DPX_FULL) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
X   phyconf->duplex = (tmp & (1<<2)) ? 1 : 0;
N   phyconf->speed  = (tmp & PHYCFGR_SPD_100) ? PHY_SPEED_100 : PHY_SPEED_10;
X   phyconf->speed  = (tmp & (1<<1)) ? 1 : 0;
N}
N
Nint8_t wizphy_setphypmode(uint8_t pmode)
N{
N   uint8_t tmp = 0;
N   tmp = getPHYCFGR();
X   tmp = WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3)));
N   if((tmp & PHYCFGR_OPMD)== 0) return -1;
X   if((tmp & (1<<6))== 0) return -1;
N   tmp &= ~PHYCFGR_OPMDC_ALLA;         
X   tmp &= ~(7<<3);         
N   if( pmode == PHY_POWER_DOWN)
X   if( pmode == 1)
N      tmp |= PHYCFGR_OPMDC_PDOWN;
X      tmp |= (6<<3);
N   else
N      tmp |= PHYCFGR_OPMDC_ALLA;
X      tmp |= (7<<3);
N   setPHYCFGR(tmp);
X   WIZCHIP_WRITE((0x00000000 + (0x002E << 8) + (0x00 << 3)), tmp);
N   wizphy_reset();
N   tmp = getPHYCFGR();
X   tmp = WIZCHIP_READ((0x00000000 + (0x002E << 8) + (0x00 << 3)));
N   if( pmode == PHY_POWER_DOWN)
X   if( pmode == 1)
N   {
N      if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
X      if(tmp & (6<<3)) return 0;
N   }
N   else
N   {
N      if(tmp & PHYCFGR_OPMDC_ALLA) return 0;
X      if(tmp & (7<<3)) return 0;
N   }
N   return -1;
N}
N#endif
N
N
Nvoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo)
N{
N   setSHAR(pnetinfo->mac);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), pnetinfo->mac, 6);
N   setGAR(pnetinfo->gw);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0001 << 8) + (0x00 << 3)),pnetinfo->gw,4);
N   setSUBR(pnetinfo->sn);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x0005 << 8) + (0x00 << 3)), pnetinfo->sn,4);
N   setSIPR(pnetinfo->ip);
X   WIZCHIP_WRITE_BUF((0x00000000 + (0x000F << 8) + (0x00 << 3)), pnetinfo->ip, 4);
N   _DNS_[0] = pnetinfo->dns[0];
N   _DNS_[1] = pnetinfo->dns[1];
N   _DNS_[2] = pnetinfo->dns[2];
N   _DNS_[3] = pnetinfo->dns[3];
N   _DHCP_   = pnetinfo->dhcp;
N}
N
Nvoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
N{
N   getSHAR(pnetinfo->mac);
X   WIZCHIP_READ_BUF((0x00000000 + (0x0009 << 8) + (0x00 << 3)), pnetinfo->mac, 6);
N   getGAR(pnetinfo->gw);
X   WIZCHIP_READ_BUF((0x00000000 + (0x0001 << 8) + (0x00 << 3)),pnetinfo->gw,4);
N   getSUBR(pnetinfo->sn);
X   WIZCHIP_READ_BUF((0x00000000 + (0x0005 << 8) + (0x00 << 3)), pnetinfo->sn, 4);
N   getSIPR(pnetinfo->ip);
X   WIZCHIP_READ_BUF((0x00000000 + (0x000F << 8) + (0x00 << 3)), pnetinfo->ip, 4);
N   pnetinfo->dns[0]= _DNS_[0];
N   pnetinfo->dns[1]= _DNS_[1];
N   pnetinfo->dns[2]= _DNS_[2];
N   pnetinfo->dns[3]= _DNS_[3];
N   pnetinfo->dhcp  = _DHCP_;
N}
N
Nint8_t wizchip_setnetmode(netmode_type netmode)
N{
N   uint8_t tmp = 0;
N#if _WIZCHIP_ != 5500   
X#if 5500 != 5500   
S   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
N#else
N   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
N#endif      
N   tmp = getMR();
X   tmp = WIZCHIP_READ((0x00000000 + (0x0000 << 8) + (0x00 << 3)));
N   tmp |= (uint8_t)netmode;
N   setMR(tmp);
X   WIZCHIP_WRITE((0x00000000 + (0x0000 << 8) + (0x00 << 3)),tmp);
N   return 0;
N}
N
Nnetmode_type wizchip_getnetmode(void)
N{
N   return (netmode_type) getMR();
X   return (netmode_type) WIZCHIP_READ((0x00000000 + (0x0000 << 8) + (0x00 << 3)));
N}
N
Nvoid wizchip_settimeout(wiz_NetTimeout* nettime)
N{
N   setRCR(nettime->retry_cnt);
X   WIZCHIP_WRITE((0x00000000 + (0x001B << 8) + (0x00 << 3)), nettime ->retry_cnt);
N   setRTR(nettime->time_100us);
X   { WIZCHIP_WRITE((0x00000000 + (0x0019 << 8) + (0x00 << 3)), (uint8_t)(nettime ->time_100us >> 8)); WIZCHIP_WRITE(((0x00000000 + (0x0019 << 8) + (0x00 << 3)) + (1<<8)), (uint8_t) nettime ->time_100us); };
N}
N
Nvoid wizchip_gettimeout(wiz_NetTimeout* nettime)
N{
N   nettime->retry_cnt = getRCR();
X   nettime->retry_cnt = WIZCHIP_READ((0x00000000 + (0x001B << 8) + (0x00 << 3)));
N   nettime->time_100us = getRTR();
X   nettime->time_100us = ((WIZCHIP_READ((0x00000000 + (0x0019 << 8) + (0x00 << 3))) << 8) + WIZCHIP_READ(((0x00000000 + (0x0019 << 8) + (0x00 << 3)) + (1<<8))));
N}
