; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\utility.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\utility.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\MQTT -I..\..\Ethernet -I..\..\Ethernet\W5500 -I..\..\Internet\DHCP -I..\..\Internet\DNS -I..\..\User\app\src -I..\..\User\app\inc -I..\..\Internet\NTP -I..\..\Internet\HTTP -I.\RTE\_Flash -ID:\MDK5\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\MDK5\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\utility.crf ..\..\Ethernet\utility.c]
                          THUMB

                          AREA ||i.atoi16||, CODE, READONLY, ALIGN=1

                  atoi16 PROC
;;;16     */
;;;17     uint16 atoi16(char* str,uint16 base	)
000000  b530              PUSH     {r4,r5,lr}
;;;18     {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;19       unsigned int num = 0;
000006  2400              MOVS     r4,#0
;;;20       while (*str !=0)
000008  e005              B        |L1.22|
                  |L1.10|
;;;21               num = num * base + c2d(*str++);
00000a  f8120b01          LDRB     r0,[r2],#1
00000e  f7fffffe          BL       ||c2d||
000012  fb040403          MLA      r4,r4,r3,r0
                  |L1.22|
000016  7810              LDRB     r0,[r2,#0]            ;20
000018  2800              CMP      r0,#0                 ;20
00001a  d1f6              BNE      |L1.10|
;;;22       return num;
00001c  b2a0              UXTH     r0,r4
;;;23     }
00001e  bd30              POP      {r4,r5,pc}
;;;24     
                          ENDP


                          AREA ||i.atoi32||, CODE, READONLY, ALIGN=1

                  atoi32 PROC
;;;29     */
;;;30     uint32 atoi32(char* str,uint16 base	)
000000  b530              PUSH     {r4,r5,lr}
;;;31     {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;32       uint32 num = 0;
000006  2400              MOVS     r4,#0
;;;33       while (*str !=0)
000008  e005              B        |L2.22|
                  |L2.10|
;;;34               num = num * base + c2d(*str++);
00000a  f8120b01          LDRB     r0,[r2],#1
00000e  f7fffffe          BL       ||c2d||
000012  fb040403          MLA      r4,r4,r3,r0
                  |L2.22|
000016  7810              LDRB     r0,[r2,#0]            ;33
000018  2800              CMP      r0,#0                 ;33
00001a  d1f6              BNE      |L2.10|
;;;35       return num;
00001c  4620              MOV      r0,r4
;;;36     }
00001e  bd30              POP      {r4,r5,pc}
;;;37     
                          ENDP


                          AREA ||i.c2d||, CODE, READONLY, ALIGN=1

                  ||c2d|| PROC
;;;95     */
;;;96     char c2d(uint8 c	)
000000  4601              MOV      r1,r0
;;;97     {
;;;98     	if (c >= '0' && c <= '9')
000002  2930              CMP      r1,#0x30
000004  db05              BLT      |L3.18|
000006  2939              CMP      r1,#0x39
000008  dc03              BGT      |L3.18|
;;;99     		return c - '0';
00000a  f1a10030          SUB      r0,r1,#0x30
00000e  b2c0              UXTB     r0,r0
                  |L3.16|
;;;100    	if (c >= 'a' && c <= 'f')
;;;101    		return 10 + c -'a';
;;;102    	if (c >= 'A' && c <= 'F')
;;;103    		return 10 + c -'A';
;;;104    
;;;105    	return (char)c;
;;;106    }
000010  4770              BX       lr
                  |L3.18|
000012  2961              CMP      r1,#0x61              ;100
000014  db05              BLT      |L3.34|
000016  2966              CMP      r1,#0x66              ;100
000018  dc03              BGT      |L3.34|
00001a  f1a10057          SUB      r0,r1,#0x57           ;101
00001e  b2c0              UXTB     r0,r0                 ;101
000020  e7f6              B        |L3.16|
                  |L3.34|
000022  2941              CMP      r1,#0x41              ;102
000024  db05              BLT      |L3.50|
000026  2946              CMP      r1,#0x46              ;102
000028  dc03              BGT      |L3.50|
00002a  f1a10037          SUB      r0,r1,#0x37           ;103
00002e  b2c0              UXTB     r0,r0                 ;103
000030  e7ee              B        |L3.16|
                  |L3.50|
000032  4608              MOV      r0,r1                 ;105
000034  e7ec              B        |L3.16|
;;;107    
                          ENDP


                          AREA ||i.checksum||, CODE, READONLY, ALIGN=1

                  checksum PROC
;;;310    */ 
;;;311    unsigned short checksum(
000000  b5f0              PUSH     {r4-r7,lr}
;;;312    	unsigned char * src, 	/**< pointer to stream  */
;;;313    	unsigned int len		/**< size of stream */
;;;314    	)
;;;315    {
000002  4602              MOV      r2,r0
000004  460d              MOV      r5,r1
;;;316    	u_int sum, tsum, i, j;
;;;317    	u_long lsum;
;;;318    
;;;319    	j = len >> 1;
000006  f3c5064f          UBFX     r6,r5,#1,#16
;;;320    
;;;321    	lsum = 0;
00000a  2400              MOVS     r4,#0
;;;322    
;;;323    	for (i = 0; i < j; i++) 
00000c  2100              MOVS     r1,#0
00000e  e00e              B        |L4.46|
                  |L4.16|
;;;324    	{
;;;325    		tsum = src[i * 2];
000010  f8123011          LDRB     r3,[r2,r1,LSL #1]
;;;326    		tsum = tsum << 8;
000014  f64f77ff          MOV      r7,#0xffff
000018  ea072303          AND      r3,r7,r3,LSL #8
;;;327    		tsum += src[i * 2 + 1];
00001c  2701              MOVS     r7,#1
00001e  eb070741          ADD      r7,r7,r1,LSL #1
000022  5dd7              LDRB     r7,[r2,r7]
000024  441f              ADD      r7,r7,r3
000026  b2bb              UXTH     r3,r7
;;;328    		lsum += tsum;
000028  441c              ADD      r4,r4,r3
00002a  1c4f              ADDS     r7,r1,#1              ;323
00002c  b2b9              UXTH     r1,r7                 ;323
                  |L4.46|
00002e  42b1              CMP      r1,r6                 ;323
000030  dbee              BLT      |L4.16|
;;;329    	}
;;;330    
;;;331    	if (len % 2) 
000032  f0050701          AND      r7,r5,#1
000036  b11f              CBZ      r7,|L4.64|
;;;332    	{
;;;333    		tsum = src[i * 2];
000038  f8123011          LDRB     r3,[r2,r1,LSL #1]
;;;334    		lsum += (tsum << 8);
00003c  eb042403          ADD      r4,r4,r3,LSL #8
                  |L4.64|
;;;335    	}
;;;336    
;;;337    
;;;338    	sum = lsum;
000040  b2a0              UXTH     r0,r4
;;;339    	sum = ~(sum + (lsum >> 16));
000042  eb004714          ADD      r7,r0,r4,LSR #16
000046  43ff              MVNS     r7,r7
000048  b2b8              UXTH     r0,r7
;;;340    	return (u_short) sum;	
;;;341    }
00004a  bdf0              POP      {r4-r7,pc}
;;;342    
                          ENDP


                          AREA ||i.htonl||, CODE, READONLY, ALIGN=1

                  htonl PROC
;;;259    */ 
;;;260    unsigned long htonl(
000000  b500              PUSH     {lr}
;;;261    	unsigned long hostlong		/**< hostshort  - A 32-bit number in host byte order.  */
;;;262    	)
;;;263    {
000002  4603              MOV      r3,r0
;;;264    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
;;;265    	return swapl(hostlong);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       swapl
;;;266    #else
;;;267    	return hostlong;
;;;268    #endif	
;;;269    }
00000a  bd00              POP      {pc}
;;;270    
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;243    */ 
;;;244    uint16 htons( 
000000  b500              PUSH     {lr}
;;;245    	uint16 hostshort	/**< A 16-bit number in host byte order.  */
;;;246    	)
;;;247    {
000002  4603              MOV      r3,r0
;;;248    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
;;;249    	return swaps(hostshort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       swaps
;;;250    #else
;;;251    	return hostshort;
;;;252    #endif		
;;;253    }
00000a  bd00              POP      {pc}
;;;254    
                          ENDP


                          AREA ||i.inet_addr_||, CODE, READONLY, ALIGN=2

                  inet_addr_ PROC
;;;158    */
;;;159    void inet_addr_(unsigned char* addr,unsigned char *ip)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;160    {
000004  b088              SUB      sp,sp,#0x20
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;161    	int i;
;;;162    	char taddr[30];
;;;163    	char * nexttok;
;;;164    	char num;
;;;165    	strcpy(taddr,(char *)addr);
00000a  4631              MOV      r1,r6
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       strcpy
;;;166    	
;;;167    	nexttok = taddr;
000012  466c              MOV      r4,sp
;;;168    	for(i = 0; i < 4 ; i++)
000014  2500              MOVS     r5,#0
000016  e01b              B        |L7.80|
                  |L7.24|
;;;169    	{
;;;170    		nexttok = strtok(nexttok,".");
000018  a110              ADR      r1,|L7.92|
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       strtok
000020  4604              MOV      r4,r0
;;;171    		if(nexttok[0] == '0' && nexttok[1] == 'x') num = atoi16(nexttok+2,0x10);
000022  7820              LDRB     r0,[r4,#0]
000024  2830              CMP      r0,#0x30
000026  d109              BNE      |L7.60|
000028  7860              LDRB     r0,[r4,#1]
00002a  2878              CMP      r0,#0x78
00002c  d106              BNE      |L7.60|
00002e  2110              MOVS     r1,#0x10
000030  1ca0              ADDS     r0,r4,#2
000032  f7fffffe          BL       atoi16
000036  f00008ff          AND      r8,r0,#0xff
00003a  e005              B        |L7.72|
                  |L7.60|
;;;172    		else num = atoi16(nexttok,10);
00003c  210a              MOVS     r1,#0xa
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       atoi16
000044  f00008ff          AND      r8,r0,#0xff
                  |L7.72|
;;;173    		
;;;174    		ip[i] = num;
000048  f8078005          STRB     r8,[r7,r5]
;;;175    		nexttok = NULL;
00004c  2400              MOVS     r4,#0
00004e  1c6d              ADDS     r5,r5,#1              ;168
                  |L7.80|
000050  2d04              CMP      r5,#4                 ;168
000052  dbe1              BLT      |L7.24|
;;;176    	}
;;;177    }	
000054  b008              ADD      sp,sp,#0x20
000056  e8bd81f0          POP      {r4-r8,pc}
;;;178     
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
00005c  2e00              DCB      ".",0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.inet_ntoa||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  inet_ntoa PROC
;;;183    */
;;;184    char* inet_ntoa(
000000  b51c              PUSH     {r2-r4,lr}
;;;185    	unsigned long addr	
;;;186    	)
;;;187    {
000002  4604              MOV      r4,r0
;;;188    	static char addr_str[32];
;;;189    	memset(addr_str,0,32);
000004  2120              MOVS     r1,#0x20
000006  4808              LDR      r0,|L8.40|
000008  f7fffffe          BL       __aeabi_memclr
;;;190    	sprintf(addr_str,"%d.%d.%d.%d",(int)(addr>>24 & 0xFF),(int)(addr>>16 & 0xFF),(int)(addr>>8 & 0xFF),(int)(addr & 0xFF));
00000c  b2e0              UXTB     r0,r4
00000e  f3c42107          UBFX     r1,r4,#8,#8
000012  0e22              LSRS     r2,r4,#24
000014  f3c44307          UBFX     r3,r4,#16,#8
000018  e9cd1000          STRD     r1,r0,[sp,#0]
00001c  a103              ADR      r1,|L8.44|
00001e  4802              LDR      r0,|L8.40|
000020  f7fffffe          BL       __2sprintf
;;;191    	return addr_str;
000024  4800              LDR      r0,|L8.40|
;;;192    }
000026  bd1c              POP      {r2-r4,pc}
;;;193    
                          ENDP

                  |L8.40|
                          DCD      addr_str
                  |L8.44|
00002c  25642e25          DCB      "%d.%d.%d.%d",0
000030  642e2564
000034  2e256400

                          AREA ||i.inet_ntoa_pad||, CODE, READONLY, ALIGN=2

                  inet_ntoa_pad PROC
;;;198    */
;;;199    char* inet_ntoa_pad(unsigned long addr)
000000  b51c              PUSH     {r2-r4,lr}
;;;200    {
000002  4604              MOV      r4,r0
;;;201    	static char addr_str[16];
;;;202    	memset(addr_str,0,16);
000004  2110              MOVS     r1,#0x10
000006  4808              LDR      r0,|L9.40|
000008  f7fffffe          BL       __aeabi_memclr
;;;203    	printf(addr_str,"%03d.%03d.%03d.%03d",(int)(addr>>24 & 0xFF),(int)(addr>>16 & 0xFF),(int)(addr>>8 & 0xFF),(int)(addr & 0xFF));
00000c  b2e0              UXTB     r0,r4
00000e  f3c42107          UBFX     r1,r4,#8,#8
000012  0e22              LSRS     r2,r4,#24
000014  f3c44307          UBFX     r3,r4,#16,#8
000018  e9cd1000          STRD     r1,r0,[sp,#0]
00001c  a103              ADR      r1,|L9.44|
00001e  4802              LDR      r0,|L9.40|
000020  f7fffffe          BL       printf
;;;204    	return addr_str;
000024  4800              LDR      r0,|L9.40|
;;;205    }
000026  bd1c              POP      {r2-r4,pc}
;;;206     
                          ENDP

                  |L9.40|
                          DCD      |symbol_number.47|
                  |L9.44|
00002c  25303364          DCB      "%03d.%03d.%03d.%03d",0
000030  2e253033
000034  642e2530
000038  33642e25
00003c  30336400

                          AREA ||i.itoa||, CODE, READONLY, ALIGN=1

                  itoa PROC
;;;42     */
;;;43     void itoa(uint16 n,uint8 str[5], uint8 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;44     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;45       
;;;46       uint8 i=len-1;
00000a  1e70              SUBS     r0,r6,#1
00000c  b2c7              UXTB     r7,r0
;;;47     
;;;48       memset(str,0x20,len);
00000e  2220              MOVS     r2,#0x20
000010  4631              MOV      r1,r6
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       __aeabi_memset
;;;49       do{
000018  bf00              NOP      
                  |L10.26|
;;;50       str[i--]=n%10+'0';
00001a  200a              MOVS     r0,#0xa
00001c  fb94f1f0          SDIV     r1,r4,r0
000020  fb004011          MLS      r0,r0,r1,r4
000024  3030              ADDS     r0,r0,#0x30
000026  b2c2              UXTB     r2,r0
000028  4638              MOV      r0,r7
00002a  1e79              SUBS     r1,r7,#1
00002c  b2cf              UXTB     r7,r1
00002e  542a              STRB     r2,[r5,r0]
;;;51       
;;;52      }while((n/=10)>0);
000030  200a              MOVS     r0,#0xa
000032  fb94f0f0          SDIV     r0,r4,r0
000036  b280              UXTH     r0,r0
000038  1e04              SUBS     r4,r0,#0
00003a  dcee              BGT      |L10.26|
;;;53     
;;;54      return;
;;;55     }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;56     
                          ENDP


                          AREA ||i.mid||, CODE, READONLY, ALIGN=1

                  mid PROC
;;;139    */
;;;140    void mid(int8* src, int8* s1, int8* s2, int8* sub)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;141    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;142    	int8* sub1;
;;;143    	int8* sub2;
;;;144    	uint16 n;
;;;145    
;;;146      sub1=strstr(src,s1);
00000c  4631              MOV      r1,r6
00000e  4648              MOV      r0,r9
000010  f7fffffe          BL       strstr
000014  4604              MOV      r4,r0
;;;147      sub1+=strlen(s1);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       strlen
00001c  4404              ADD      r4,r4,r0
;;;148      sub2=strstr(sub1,s2);
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       strstr
000026  4682              MOV      r10,r0
;;;149      n=sub2-sub1;
000028  ebaa0004          SUB      r0,r10,r4
00002c  fa1ff880          UXTH     r8,r0
;;;150      strncpy(sub,sub1,n);
000030  4642              MOV      r2,r8
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       strncpy
;;;151      sub[n]=0;
00003a  2000              MOVS     r0,#0
00003c  f8050008          STRB     r0,[r5,r8]
;;;152    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;153    
                          ENDP


                          AREA ||i.ntohl||, CODE, READONLY, ALIGN=1

                  ntohl PROC
;;;294    */ 
;;;295    unsigned long ntohl(unsigned long netlong)
000000  b510              PUSH     {r4,lr}
;;;296    {
000002  4604              MOV      r4,r0
;;;297    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
;;;298    	return htonl(netlong);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       htonl
;;;299    #else
;;;300    	return netlong;
;;;301    #endif		
;;;302    }
00000a  bd10              POP      {r4,pc}
;;;303    
                          ENDP


                          AREA ||i.ntohs||, CODE, READONLY, ALIGN=1

                  ntohs PROC
;;;277    */ 
;;;278    unsigned long ntohs(
000000  b510              PUSH     {r4,lr}
;;;279    	unsigned short netshort	/**< netshort - network odering 16bit value */
;;;280    	)
;;;281    {
000002  4604              MOV      r4,r0
;;;282    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )	
;;;283    	return htons(netshort);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       htons
;;;284    #else
;;;285    	return netshort;
;;;286    #endif		
;;;287    }
00000a  bd10              POP      {r4,pc}
;;;288    
                          ENDP


                          AREA ||i.replacetochar||, CODE, READONLY, ALIGN=1

                  replacetochar PROC
;;;83     */
;;;84     void replacetochar(char * str,	char oldchar,char newchar	)
000000  b510              PUSH     {r4,lr}
;;;85     {
000002  460b              MOV      r3,r1
;;;86       int x;
;;;87       for (x = 0; str[x]; x++) 
000004  2100              MOVS     r1,#0
000006  e004              B        |L14.18|
                  |L14.8|
;;;88         if (str[x] == oldchar) str[x] = newchar;	
000008  5c44              LDRB     r4,[r0,r1]
00000a  429c              CMP      r4,r3
00000c  d100              BNE      |L14.16|
00000e  5442              STRB     r2,[r0,r1]
                  |L14.16|
000010  1c49              ADDS     r1,r1,#1              ;87
                  |L14.18|
000012  5c44              LDRB     r4,[r0,r1]            ;87
000014  2c00              CMP      r4,#0                 ;87
000016  d1f7              BNE      |L14.8|
;;;89     }
000018  bd10              POP      {r4,pc}
;;;90     
                          ENDP


                          AREA ||i.swapl||, CODE, READONLY, ALIGN=1

                  swapl PROC
;;;124    */
;;;125    uint32 swapl(uint32 l)
000000  4601              MOV      r1,r0
;;;126    {
;;;127      uint32 ret=0;
000002  2000              MOVS     r0,#0
;;;128      ret = (l & 0xFF) << 24;
000004  0608              LSLS     r0,r1,#24
;;;129      ret |= ((l >> 8) & 0xFF) << 16;
000006  f3c12207          UBFX     r2,r1,#8,#8
00000a  ea404002          ORR      r0,r0,r2,LSL #16
;;;130      ret |= ((l >> 16) & 0xFF) << 8;
00000e  f3c14207          UBFX     r2,r1,#16,#8
000012  ea402002          ORR      r0,r0,r2,LSL #8
;;;131      ret |= ((l >> 24) & 0xFF);
000016  ea406011          ORR      r0,r0,r1,LSR #24
;;;132      return ret;
;;;133    }
00001a  4770              BX       lr
;;;134    
                          ENDP


                          AREA ||i.swaps||, CODE, READONLY, ALIGN=1

                  swaps PROC
;;;112    */
;;;113    uint16 swaps(uint16 i)
000000  4601              MOV      r1,r0
;;;114    {
;;;115      uint16 ret=0;
000002  2000              MOVS     r0,#0
;;;116      ret = (i & 0xFF) << 8;
000004  060a              LSLS     r2,r1,#24
000006  0c10              LSRS     r0,r2,#16
;;;117      ret |= ((i >> 8)& 0xFF);
000008  ea402011          ORR      r0,r0,r1,LSR #8
;;;118      return ret;	
;;;119    }
00000c  4770              BX       lr
;;;120    /**
                          ENDP


                          AREA ||i.validatoi||, CODE, READONLY, ALIGN=1

                  validatoi PROC
;;;62     */
;;;63     int validatoi(char* str, int base,int* ret)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;64     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;65       int c;
;;;66       char* tstr = str;
00000a  4626              MOV      r6,r4
;;;67       if(str == 0 || *str == '\0') return 0;
00000c  b10c              CBZ      r4,|L17.18|
00000e  7820              LDRB     r0,[r4,#0]
000010  b910              CBNZ     r0,|L17.24|
                  |L17.18|
000012  2000              MOVS     r0,#0
                  |L17.20|
;;;68       while(*tstr != '\0')
;;;69       {
;;;70         c = c2d(*tstr);
;;;71         if( c >= 0 && c < base) tstr++;
;;;72         else    return 0;
;;;73       }
;;;74       
;;;75       *ret = atoi16(str,base);
;;;76       return 1;
;;;77     }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L17.24|
000018  e00b              B        |L17.50|
                  |L17.26|
00001a  7830              LDRB     r0,[r6,#0]            ;70
00001c  f7fffffe          BL       ||c2d||
000020  4605              MOV      r5,r0                 ;70
000022  2d00              CMP      r5,#0                 ;71
000024  db03              BLT      |L17.46|
000026  42bd              CMP      r5,r7                 ;71
000028  da01              BGE      |L17.46|
00002a  1c76              ADDS     r6,r6,#1              ;71
00002c  e001              B        |L17.50|
                  |L17.46|
00002e  2000              MOVS     r0,#0                 ;72
000030  e7f0              B        |L17.20|
                  |L17.50|
000032  7830              LDRB     r0,[r6,#0]            ;68
000034  2800              CMP      r0,#0                 ;68
000036  d1f0              BNE      |L17.26|
000038  b2b9              UXTH     r1,r7                 ;75
00003a  4620              MOV      r0,r4                 ;75
00003c  f7fffffe          BL       atoi16
000040  f8c80000          STR      r0,[r8,#0]            ;75
000044  2001              MOVS     r0,#1                 ;76
000046  e7e5              B        |L17.20|
;;;78     
                          ENDP


                          AREA ||i.verify_ip_address||, CODE, READONLY, ALIGN=2

                  verify_ip_address PROC
;;;211    */
;;;212    char verify_ip_address(char* src, uint8 * ip)
000000  b5f0              PUSH     {r4-r7,lr}
;;;213    {
000002  b08f              SUB      sp,sp,#0x3c
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;214    	int i;
;;;215    	int tnum;
;;;216    	char tsrc[50];
;;;217    	char* tok = tsrc;
000008  ac01              ADD      r4,sp,#4
;;;218    	
;;;219    	strcpy(tsrc,src);
00000a  4631              MOV      r1,r6
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       strcpy
;;;220    	
;;;221    	for(i = 0; i < 4; i++)
000012  2500              MOVS     r5,#0
000014  e02a              B        |L18.108|
                  |L18.22|
;;;222    	{
;;;223    		tok = strtok(tok,".");
000016  a117              ADR      r1,|L18.116|
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       strtok
00001e  4604              MOV      r4,r0
;;;224    		if ( !tok ) return 0;
000020  b914              CBNZ     r4,|L18.40|
000022  2000              MOVS     r0,#0
                  |L18.36|
;;;225    		if(tok[0] == '0' && tok[1] == 'x')
;;;226    		{
;;;227    			if(!validatoi(tok+2,0x10,&tnum)) return 0;
;;;228    		}
;;;229    		else if(!validatoi(tok,10,&tnum)) return 0;
;;;230    
;;;231    		ip[i] = tnum;
;;;232    		
;;;233    		if(tnum < 0 || tnum > 255) return 0;
;;;234    		tok = NULL;
;;;235    	}
;;;236    	return 1;	
;;;237    }
000024  b00f              ADD      sp,sp,#0x3c
000026  bdf0              POP      {r4-r7,pc}
                  |L18.40|
000028  7820              LDRB     r0,[r4,#0]            ;225
00002a  2830              CMP      r0,#0x30              ;225
00002c  d10a              BNE      |L18.68|
00002e  7860              LDRB     r0,[r4,#1]            ;225
000030  2878              CMP      r0,#0x78              ;225
000032  d107              BNE      |L18.68|
000034  aa0e              ADD      r2,sp,#0x38           ;227
000036  2110              MOVS     r1,#0x10              ;227
000038  1ca0              ADDS     r0,r4,#2              ;227
00003a  f7fffffe          BL       validatoi
00003e  b948              CBNZ     r0,|L18.84|
000040  2000              MOVS     r0,#0                 ;227
000042  e7ef              B        |L18.36|
                  |L18.68|
000044  aa0e              ADD      r2,sp,#0x38           ;229
000046  210a              MOVS     r1,#0xa               ;229
000048  4620              MOV      r0,r4                 ;229
00004a  f7fffffe          BL       validatoi
00004e  b908              CBNZ     r0,|L18.84|
000050  2000              MOVS     r0,#0                 ;229
000052  e7e7              B        |L18.36|
                  |L18.84|
000054  980e              LDR      r0,[sp,#0x38]         ;231
000056  5578              STRB     r0,[r7,r5]            ;231
000058  980e              LDR      r0,[sp,#0x38]         ;233
00005a  2800              CMP      r0,#0                 ;233
00005c  db02              BLT      |L18.100|
00005e  980e              LDR      r0,[sp,#0x38]         ;233
000060  28ff              CMP      r0,#0xff              ;233
000062  dd01              BLE      |L18.104|
                  |L18.100|
000064  2000              MOVS     r0,#0                 ;233
000066  e7dd              B        |L18.36|
                  |L18.104|
000068  2400              MOVS     r4,#0                 ;234
00006a  1c6d              ADDS     r5,r5,#1              ;221
                  |L18.108|
00006c  2d04              CMP      r5,#4                 ;221
00006e  dbd2              BLT      |L18.22|
000070  2001              MOVS     r0,#1                 ;236
000072  e7d7              B        |L18.36|
;;;238    
                          ENDP

                  |L18.116|
000074  2e00              DCB      ".",0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  addr_str
                          %        32
                  |symbol_number.47|
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  aucCRCHi
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  aucCRCLo
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  xHandleTaskUserIF
                          DCD      0x00000000
                  xHandleCheckNet
                          DCD      0x00000000
                  xHandleTaskWEB
                          DCD      0x00000000
                  xHandleTaskMsgPro
                          DCD      0x00000000
                  xHandleTaskStart
                          DCD      0x00000000
                  xSemaphore
                          DCD      0x00000000
                  xMutex
                          DCD      0x00000000
                  xPingTimers
                          DCD      0x00000000
                  xNoNetTimers
                          DCD      0x00000000
                  xCreatedEventGroup
                          DCD      0x00000000
                  xUpdataEventGroup
                          DCD      0x00000000
                  xQueue1
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Ethernet\\utility.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_utility_c_atoi16____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_utility_c_atoi16____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_utility_c_atoi16____REVSH|
#line 128
|__asm___9_utility_c_atoi16____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
