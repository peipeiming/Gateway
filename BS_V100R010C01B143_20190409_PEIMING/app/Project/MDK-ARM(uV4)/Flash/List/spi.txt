; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\spi.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\MQTT -I..\..\Ethernet -I..\..\Ethernet\W5500 -I..\..\Internet\DHCP -I..\..\Internet\DNS -I..\..\User\app\src -I..\..\User\app\inc -I..\..\Internet\NTP -I..\..\Internet\HTTP -I.\RTE\_Flash -ID:\MDK5\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\MDK5\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\spi.crf ..\..\Ethernet\spi.c]
                          THUMB

                          AREA ||i.SPI_CS_Deselect||, CODE, READONLY, ALIGN=2

                  SPI_CS_Deselect PROC
;;;157      */
;;;158    void SPI_CS_Deselect(void)
000000  b510              PUSH     {r4,lr}
;;;159    {
;;;160    	#ifdef MCBR03
;;;161    	GPIO_SetBits(GPIOA,GPIO_Pin_15);
;;;162    	#else
;;;163    	GPIO_SetBits(GPIOB,GPIO_Pin_12);
000002  f44f5180          MOV      r1,#0x1000
000006  4802              LDR      r0,|L1.16|
000008  f7fffffe          BL       GPIO_SetBits
;;;164    	#endif
;;;165    }
00000c  bd10              POP      {r4,pc}
;;;166    /*********************************END OF FILE**********************************/
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40010c00

                          AREA ||i.SPI_CS_Select||, CODE, READONLY, ALIGN=2

                  SPI_CS_Select PROC
;;;145      */
;;;146    void SPI_CS_Select(void)
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148    	#ifdef MCBR03
;;;149    	GPIO_ResetBits(GPIOA,GPIO_Pin_15);
;;;150    	#else
;;;151    	GPIO_ResetBits(GPIOB,GPIO_Pin_12);
000002  f44f5180          MOV      r1,#0x1000
000006  4802              LDR      r0,|L2.16|
000008  f7fffffe          BL       GPIO_ResetBits
;;;152    	#endif
;;;153    }
00000c  bd10              POP      {r4,pc}
;;;154    /**
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40010c00

                          AREA ||i.SPI_Configuration||, CODE, READONLY, ALIGN=2

                  SPI_Configuration PROC
;;;58       */
;;;59     void SPI_Configuration(void)
000000  b500              PUSH     {lr}
;;;60     {
000002  b085              SUB      sp,sp,#0x14
;;;61     	SPI_InitTypeDef SPI_InitStruct;
;;;62     
;;;63     	SPI_RCC_Configuration();
000004  f7fffffe          BL       SPI_RCC_Configuration
;;;64     	SPI_GPIO_Configuration();
000008  f7fffffe          BL       SPI_GPIO_Configuration
;;;65     	
;;;66     	SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
00000c  2000              MOVS     r0,#0
00000e  f8ad000c          STRH     r0,[sp,#0xc]
;;;67     	SPI_InitStruct.SPI_Direction= SPI_Direction_2Lines_FullDuplex;
000012  f8ad0000          STRH     r0,[sp,#0]
;;;68     	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;
000016  f44f7082          MOV      r0,#0x104
00001a  f8ad0002          STRH     r0,[sp,#2]
;;;69     	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;
00001e  2000              MOVS     r0,#0
000020  f8ad0004          STRH     r0,[sp,#4]
;;;70     	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;
000024  f8ad0006          STRH     r0,[sp,#6]
;;;71     	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;
000028  f8ad0008          STRH     r0,[sp,#8]
;;;72     	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;
00002c  f44f7000          MOV      r0,#0x200
000030  f8ad000a          STRH     r0,[sp,#0xa]
;;;73     	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;
000034  2000              MOVS     r0,#0
000036  f8ad000e          STRH     r0,[sp,#0xe]
;;;74     	SPI_InitStruct.SPI_CRCPolynomial = 7;
00003a  2007              MOVS     r0,#7
00003c  f8ad0010          STRH     r0,[sp,#0x10]
;;;75     
;;;76     	#ifdef MCBR03
;;;77     	SPI_Init(SPI3,&SPI_InitStruct);
;;;78     	#else	
;;;79     	SPI_Init(SPI2,&SPI_InitStruct);
000040  4669              MOV      r1,sp
000042  4804              LDR      r0,|L3.84|
000044  f7fffffe          BL       SPI_Init
;;;80     	#endif
;;;81     	
;;;82     	#ifdef MCBR03
;;;83     	SPI_Cmd(SPI3, ENABLE);
;;;84     	#else
;;;85     	SPI_Cmd(SPI2, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4802              LDR      r0,|L3.84|
00004c  f7fffffe          BL       SPI_Cmd
;;;86     	#endif
;;;87     }
000050  b005              ADD      sp,sp,#0x14
000052  bd00              POP      {pc}
;;;88     /**
                          ENDP

                  |L3.84|
                          DCD      0x40003800

                          AREA ||i.SPI_CrisEnter||, CODE, READONLY, ALIGN=1

                  SPI_CrisEnter PROC
;;;128      */
;;;129    void SPI_CrisEnter(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
000006  bf00              NOP      
;;;130    {
;;;131    	__set_PRIMASK(1);
;;;132    }
000008  4770              BX       lr
;;;133    /**
                          ENDP


                          AREA ||i.SPI_CrisExit||, CODE, READONLY, ALIGN=1

                  SPI_CrisExit PROC
;;;136      */
;;;137    void SPI_CrisExit(void)
000000  2000              MOVS     r0,#0
000002  f3808810          MSR      PRIMASK,r0
000006  bf00              NOP      
;;;138    {
;;;139    	__set_PRIMASK(0);
;;;140    }
000008  4770              BX       lr
;;;141    
                          ENDP


                          AREA ||i.SPI_GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  SPI_GPIO_Configuration PROC
;;;24       */
;;;25     static void SPI_GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;26     {
;;;27     	GPIO_InitTypeDef 	GPIO_InitStructure;
;;;28     	
;;;29     	#ifdef MCBR03
;;;30     	//PA15->CS,PB3->SCK,PB4->MISO,PB5->MOSI
;;;31     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
;;;32     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;33     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;34     	GPIO_Init(GPIOB, &GPIO_InitStructure); 	
;;;35     	//初始化片选输出引脚
;;;36     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
;;;37     	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
;;;38     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
;;;39     	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;40     	GPIO_SetBits(GPIOA, GPIO_Pin_15);
;;;41     	#else
;;;42     	//PB12->CS,PB13->SCK,PB14->MISO,PB15->MOSI
;;;43     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
000002  f44f4060          MOV      r0,#0xe000
000006  f8ad0000          STRH     r0,[sp,#0]
;;;44     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;45     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000010  2018              MOVS     r0,#0x18
000012  f88d0003          STRB     r0,[sp,#3]
;;;46     	GPIO_Init(GPIOB, &GPIO_InitStructure); 	
000016  4669              MOV      r1,sp
000018  480b              LDR      r0,|L6.72|
00001a  f7fffffe          BL       GPIO_Init
;;;47     	//初始化片选输出引脚
;;;48     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00001e  f44f5080          MOV      r0,#0x1000
000022  f8ad0000          STRH     r0,[sp,#0]
;;;49     	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
000026  2003              MOVS     r0,#3
000028  f88d0002          STRB     r0,[sp,#2]
;;;50     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
00002c  2010              MOVS     r0,#0x10
00002e  f88d0003          STRB     r0,[sp,#3]
;;;51     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000032  4669              MOV      r1,sp
000034  4804              LDR      r0,|L6.72|
000036  f7fffffe          BL       GPIO_Init
;;;52     	GPIO_SetBits(GPIOB, GPIO_Pin_12);
00003a  f44f5180          MOV      r1,#0x1000
00003e  4802              LDR      r0,|L6.72|
000040  f7fffffe          BL       GPIO_SetBits
;;;53     	#endif
;;;54     }
000044  bd08              POP      {r3,pc}
;;;55     /**
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      0x40010c00

                          AREA ||i.SPI_RCC_Configuration||, CODE, READONLY, ALIGN=2

                  SPI_RCC_Configuration PROC
;;;6        */
;;;7      static void SPI_RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;8      {
;;;9      	#ifdef MCBR03
;;;10     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  //使能GPIOA时钟
;;;11     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);   //使能SPI3时钟 
;;;12     	#else
;;;13     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);   //使能SPI1时钟 
000002  2101              MOVS     r1,#1
000004  0388              LSLS     r0,r1,#14
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;14     	#endif
;;;15     	
;;;16     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);  //使能GPIOB时钟
00000a  2101              MOVS     r1,#1
00000c  2008              MOVS     r0,#8
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;17     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);   //使能复用时钟，管脚复用，管脚在APB2上
000012  2101              MOVS     r1,#1
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;18     	
;;;19     	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  4801              LDR      r0,|L7.36|
00001e  f7fffffe          BL       GPIO_PinRemapConfig
;;;20     }
000022  bd10              POP      {r4,pc}
;;;21     /**
                          ENDP

                  |L7.36|
                          DCD      0x00300200

                          AREA ||i.SPI_ReadByte||, CODE, READONLY, ALIGN=2

                  SPI_ReadByte PROC
;;;110      */
;;;111    uint8_t SPI_ReadByte(void)
000000  bf00              NOP      
                  |L8.2|
;;;112    {			 
;;;113    	#ifdef MCBR03
;;;114    	while((SPI3->SR&SPI_I2S_FLAG_TXE)==0);	//等待发送区空			  
;;;115    	SPI3->DR=0xFF;	 	  										//发送一个空数据产生输入数据的时钟 
;;;116    	while((SPI3->SR&SPI_I2S_FLAG_RXNE)==0); //等待接收完一个byte  
;;;117    	return SPI3->DR;  
;;;118    	#else
;;;119    	while((SPI2->SR&SPI_I2S_FLAG_TXE)==0);	//等待发送区空			  
000002  480b              LDR      r0,|L8.48|
000004  8800              LDRH     r0,[r0,#0]
000006  f0000002          AND      r0,r0,#2
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L8.2|
;;;120    	SPI2->DR=0xFF;	 	  										//发送一个空数据产生输入数据的时钟 
00000e  20ff              MOVS     r0,#0xff
000010  4907              LDR      r1,|L8.48|
000012  1d09              ADDS     r1,r1,#4
000014  8008              STRH     r0,[r1,#0]
;;;121    	while((SPI2->SR&SPI_I2S_FLAG_RXNE)==0); //等待接收完一个byte  
000016  bf00              NOP      
                  |L8.24|
000018  4805              LDR      r0,|L8.48|
00001a  8800              LDRH     r0,[r0,#0]
00001c  f0000001          AND      r0,r0,#1
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L8.24|
;;;122    	return SPI2->DR;  						    
000024  4802              LDR      r0,|L8.48|
000026  1d00              ADDS     r0,r0,#4
000028  8800              LDRH     r0,[r0,#0]
00002a  b2c0              UXTB     r0,r0
;;;123    	#endif
;;;124    }
00002c  4770              BX       lr
;;;125    /**
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0x40003808

                          AREA ||i.SPI_WriteByte||, CODE, READONLY, ALIGN=2

                  SPI_WriteByte PROC
;;;92       */
;;;93     void SPI_WriteByte(uint8_t TxData)
000000  bf00              NOP      
                  |L9.2|
;;;94     {				
;;;95     	#ifdef MCBR03
;;;96     	while((SPI3->SR&SPI_I2S_FLAG_TXE)==0);	//等待发送区空		  
;;;97     	SPI3->DR=TxData;	 	  									//发送一个byte 
;;;98     	while((SPI3->SR&SPI_I2S_FLAG_RXNE)==0); //等待接收完一个byte  
;;;99     	SPI3->DR;	
;;;100    	#else	
;;;101    	while((SPI2->SR&SPI_I2S_FLAG_TXE)==0);	//等待发送区空		  
000002  490a              LDR      r1,|L9.44|
000004  8809              LDRH     r1,[r1,#0]
000006  f0010102          AND      r1,r1,#2
00000a  2900              CMP      r1,#0
00000c  d0f9              BEQ      |L9.2|
;;;102    	SPI2->DR=TxData;	 	  									//发送一个byte 
00000e  4907              LDR      r1,|L9.44|
000010  1d09              ADDS     r1,r1,#4
000012  8008              STRH     r0,[r1,#0]
;;;103    	while((SPI2->SR&SPI_I2S_FLAG_RXNE)==0); //等待接收完一个byte  
000014  bf00              NOP      
                  |L9.22|
000016  4905              LDR      r1,|L9.44|
000018  8809              LDRH     r1,[r1,#0]
00001a  f0010101          AND      r1,r1,#1
00001e  2900              CMP      r1,#0
000020  d0f9              BEQ      |L9.22|
;;;104    	SPI2->DR;	
000022  4902              LDR      r1,|L9.44|
000024  1d09              ADDS     r1,r1,#4
000026  8809              LDRH     r1,[r1,#0]
;;;105      #endif	
;;;106    }
000028  4770              BX       lr
;;;107    /**
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0x40003808

;*** Start embedded assembler ***

#line 1 "..\\..\\Ethernet\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_ccc5250d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_spi_c_ccc5250d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_ccc5250d____REVSH|
#line 128
|__asm___5_spi_c_ccc5250d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
